//Logic axioms and proofs

axiom axiom_absurdity[P]: false -> P;
axiom axiom_true: true;

//Demorgans laws

prove demorgan0[P, Q]: ~P & ~Q -> ~(P | Q){
	implies p{
		not q{
			return branch(q, side, side){
				return left(p)(side);
			} or {
				return right(p)(side);
			};
		}
	}
}

prove demorgan1[P, Q]: ~(P | Q) -> ~P & ~Q{
	implies p{
		define P_true: P;
		define Q_true: Q;
		prove lemma0: ~P{
			not g{
				P_or_Q = or(g, (Q_true));
				return p(P_or_Q);
			}
		}
		prove lemma1: ~Q{
			not g{
				P_or_Q = swap(or(g, (P_true)));
				return p(P_or_Q);
			}
		}
		return and(lemma0, lemma1);
	}
}

prove demorgan2[P, Q]: ~P | ~Q -> ~(P & Q){
	implies p{
		not q{
			return branch(p, n, n){
				return n(left(q));
			} or {
				return n(right(q));
			};
		}
	}
}

//I'm not a constructivist lmao
axiom axiom_LEM[P]: P | ~P;

prove demorgan3[P, Q]: ~(P & Q) -> ~P | ~Q{
	implies p{
		excluded_middle = axiom_LEM[P];
		return branch(excluded_middle, P_value, P_value){
			prove lemma: ~Q{
				not Q_true{
					return p(and(P_value, Q_true));
				}
			}
			define not_P: ~P;
			return swap(or(lemma, (not_P)));
		} or {
			define not_Q: ~Q;
			return or(P_value, (not_Q));
		};
	}
}

//Proving that ~~P -> P (given LEM of course)

prove double_negation[P]: ~~P -> P{
	implies p{
		excluded_middle = axiom_LEM[P];
		return branch(excluded_middle, P_value, P_value){
			return P_value;
		} or {
			return axiom_absurdity[P](p(P_value));
		};
	}
}

//Proving the negation of quantifiers

prove negate_exists[P(1)]: ~^x(P(x)) -> *x(~P(x)){
	implies p{
		given x{
			not q{
				prove lemma: ^a(P(a)){
					choose x{
						return q;
					}
				}
				return p(lemma);
			}
		}
	}
}

prove negate_forall[P(1)]: ~*x(P(x)) -> ^x(~P(x)){
	implies p{
		define goal: ^x(~P(x));
		excluded_middle = axiom_LEM[(goal)];
		return branch(excluded_middle, goal_truth, goal_truth){
			return goal_truth;
		} or {
			define Q(x): ~P(x);
			all = negate_exists[(Q)](goal_truth);
			prove simplified: *x(P(x)){
				given x{
					define Px: P(x);
					return double_negation[(Px)](all(x));
				}
			}
			absurd = p(simplified);
			return axiom_absurdity[(goal)](absurd);
		};
	}
}

//Distribution of and, or

prove and_distribute0[P, Q, R]: (P | Q) & R -> (P & R) | (Q & R){
	implies p{
		define p_and_r: P & R;
		define q_and_r: Q & R;
		return branch(left(p), pq, pq){
			and_statement = and(pq, right(p));
			return or(and_statement, (q_and_r));
		} or {
			and_statement = and(pq, right(p));
			return swap(or(and_statement, (p_and_r)));
		};
	}
}

prove and_distribute1[P, Q, R]: (P & R) | (Q & R) -> (P | Q) & R{
	implies p{
		define p_or_q: P | Q;
		return branch(p, pr_qr, pr_qr){
			or_statement = or(left(pr_qr), Q);
			return and(or_statement, right(pr_qr));
		} or {
			or_statement = swap(or(left(pr_qr), P));
			return and(or_statement, right(pr_qr));
		};
	}
}

prove or_distribute0[P, Q, R]: (P & Q) | R -> (P | R) & (Q | R){
	implies p{
		return branch(p, or_val, or_val){
			or0 = or(left(or_val), R);
			or1 = or(right(or_val), R);
			return and(or0, or1);
		} or {
			or0 = swap(or(or_val, P));
			or1 = swap(or(or_val, Q));
			return and(or0, or1);
		};
	}
}

prove or_distribute1[P, Q, R]: (P | R) & (Q | R) -> (P & Q) | R{
	implies p{
		return branch(left(p), pr, pr){
			return branch(right(p), qr, qr){
				and_statement = and(pr, qr);
				return or(and_statement, R);
			} or {
				define and_statement: P & Q;
				return swap(or(qr, (and_statement)));
			};
		} or {
			define and_statement: P & Q;
			return swap(or(pr, (and_statement)));
		};
	}
}

//Associativity of and, or
prove and_associate0[P, Q, R]: (P & Q) & R -> P & (Q & R){
	implies a{
		p = left(left(a));
		q = right(left(a));
		r = right(a);
		q_and_r = and(q, r);
		return and(p, q_and_r);
	}
}

prove and_associate1[P, Q, R]: P & (Q & R) -> (P & Q) & R{
	implies a{
		p = left(a);
		q = left(right(a));
		r = right(right(a));
		p_and_q = and(p, q);
		return and(p_and_q, r);
	}
}

prove or_associate0[P, Q, R]: (P | Q) | R -> P | (Q | R){
	implies a{
		define q_or_r: Q | R;
		return branch(a, pqr, pqr){
			return branch(pqr, pq, pq){
				return or(pq, (q_or_r));
			} or {
				qr = or(pq, R);
				return swap(or(qr, P));
			};
		} or {
			qr = swap(or(pqr, Q));
			return swap(or(qr, P));
		};
	}
}

prove or_associate1[P, Q, R]: P | (Q | R) -> (P | Q) | R{
	implies a{
		define p_or_q: P | Q;
		return branch(a, pqr, pqr){
			pq = or(pqr, Q);
			return or(pq, R);
		} or {
			return branch(pqr, qr, qr){
				pq = swap(or(qr, P));
				return or(pq, R);
			} or {
				return swap(or(qr, (p_or_q)));
			};
		};
	}
}

prove and_left_implies[P, Q, R]: P & (P & Q -> R) -> (Q -> R){
	implies a{
		implies Q_true{
			P_and_Q = and(left(a), Q_true);
			return right(a)(P_and_Q);
		}
	}
}

prove or_combine[P]: P | P -> P{
	implies p{
		return branch(p, P_true, P_true){
			return P_true;
		} or {
			return P_true;
		};
	}
}

