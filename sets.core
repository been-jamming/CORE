//This file is for some basic set theory definitions and results

//Induction lemma for the natural numbers
prove induction_lemma: *Q((EMPTY_SET in Q & *X*Y(X in Q & is_successor(X, Y) -> Y in Q)) -> is_subset(NATURALS, Q)){
	given Q{
		implies both{
			prove lemma: ^S(S in Q & is_empty(S)){
				choose EMPTY_SET{
					return and(left(both), #is_empty(EMPTY_SET)(empty_set_condition));
				}
			}
			inductive = #is_inductive_set(Q)(and(lemma, right(both)));
			prove def: *X(X in NATURALS -> X in Q){
				given X{
					implies X_in_NAT{
						return left(naturals_definition(X))(X_in_NAT)(Q)(inductive);
					}
				}
			}
			return #is_subset(NATURALS)(Q)(def);
		}
	}
}

//The defining property of pairs. This will be used to prove the defining property of tuples.
prove pair_equal_condition: *A*B*C*D*E*F(is_pair(A, B, E) & is_pair(C, D, F) & equal_sets(E, F) -> equal_sets(A, C) | equal_sets(A, D)){
	given A{
		given B{
			given C{
				given D{
					given E{
						given F{
							implies p{
								pair_AB = is_pair#(A)(B)(E)(left(left(p)));
								pair_CD = is_pair#(C)(D)(F)(right(left(p)));
								equal_EF = equal_sets#(E)(F)(right(p));
								A_equal_A = equal_sets_reflexive(A);
								define A_equal_B: equal_sets(A, B);
								A_in_E = right(pair_AB(A))(or(A_equal_A, (A_equal_B)));
								A_in_F = left(equal_EF(A))(A_in_E);
								return left(pair_CD(A))(A_in_F);
							}
						}
					}
				}
			}
		}
	}
}

//Swapping elements of pair still gives the same pair
prove pair_swap_equal: *A*B*C(is_pair(A, B, C) -> is_pair(B, A, C)){
	given A{
		given B{
			given C{
				implies pair0{
					pair0_def = is_pair#(A)(B)(C)(pair0);
					prove pair1_def: *X((X in C -> equal_sets(X, B) | equal_sets(X, A)) & (equal_sets(X, B) | equal_sets(X, A) -> X in C)){
						given X{
							prove lemma0: X in C -> equal_sets(X, B) | equal_sets(X, A){
								implies p{
									return swap(left(pair0_def(X))(p));
								}
							}
							prove lemma1: equal_sets(X, B) | equal_sets(X, A) -> X in C{
								implies p{
									return right(pair0_def(X))(swap(p));
								}
							}
							return and(lemma0, lemma1);
						}
					}
					return #is_pair(B)(A)(C)(pair1_def);
				}
			}
		}
	}
}

//Now in order to define relations, we have to define tuples (A, B)
//I will use the standard definition that (A, B) = {{A}, {A, B}}
define is_tuple(A, B, C): ^D^E(is_pair(A, A, D) & is_pair(A, B, E) & is_pair(D, E, C));

//tuples exists
prove tuple_exists: *A*B^C(is_tuple(A, B, C)){
	given A{
		given B{
			pair_AA = pair_exists(A)(A)(D);
			pair_AB = pair_exists(A)(B)(E);
			pair_DE = pair_exists(D)(E)(C);
			choose C{
				prove def: ^D^E(is_pair(A, A, D) & is_pair(A, B, E) & is_pair(D, E, C)){
					choose D{
						choose E{
							return and(and(pair_AA, pair_AB), pair_DE);
						}
					}
				}
				return #is_tuple(A)(B)(C)(def);
			}
		}
	}
}

//tuples are unique
prove tuple_unique: *A*B*C*D(is_tuple(A, B, C) & is_tuple(A, B, D) -> equal_sets(C, D)){
	given A{
		given B{
			given C{
				given D{
					implies both{
						C_tuple = is_tuple#(A)(B)(C)(left(both))(AA_pairC)(AB_pairC);
						D_tuple = is_tuple#(A)(B)(D)(right(both))(AA_pairD)(AB_pairD);
						AA_pairC_equal_AA_pairD = pair_unique(A)(A)(AA_pairC)(AA_pairD)(and(left(left(C_tuple)), left(left(D_tuple))));
						AB_pairC_equal_AB_pairD = pair_unique(A)(B)(AB_pairC)(AB_pairD)(and(right(left(C_tuple)), right(left(D_tuple))));
						define pair(X): is_pair(X, AB_pairC, C);
						intermediate_pair = left(equality_consistency[(pair)](AA_pairC)(AA_pairD)(AA_pairC_equal_AA_pairD))(right(C_tuple));
						define pair(X): is_pair(AA_pairD, X, C);
						intermediate_pair = left(equality_consistency[(pair)](AB_pairC)(AB_pairD)(AB_pairC_equal_AB_pairD))(intermediate_pair);
						return pair_unique(AA_pairD)(AB_pairD)(C)(D)(and(intermediate_pair, right(D_tuple)));
					}
				}
			}
		}
	}
}
//So tuples (ordered pairs) are well defined
//Why are they called ordered pairs? Because of this:

//Defining property of tuples
prove tuple_equal_condition: *A*B*C*D*E*F(is_tuple(A, B, E) & is_tuple(C, D, F) & equal_sets(E, F) -> equal_sets(A, C) & equal_sets(B, D)){
	given A{
		given B{
			given C{
				given D{
					given E{
						given F{
							implies p{
								AB_tuple_condition = is_tuple#(A)(B)(E)(left(left(p)))(AA_pair)(AB_pair);
								CD_tuple_condition = is_tuple#(C)(D)(F)(right(left(p)))(CC_pair)(CD_pair);
								AA_CC_or_AA_CD = pair_equal_condition(AA_pair)(AB_pair)(CC_pair)(CD_pair)(E)(F)(and(and(right(AB_tuple_condition), right(CD_tuple_condition)), right(p)));
								AC_or_AD = branch(AA_CC_or_AA_CD, AA_CC, AA_CD){
									AC_or_AC = pair_equal_condition(A)(A)(C)(C)(AA_pair)(CC_pair)(and(and(left(left(AB_tuple_condition)), left(left(CD_tuple_condition))), AA_CC));
									define AC: equal_sets(A, C);
									define AD: equal_sets(A, D);
									return or(or_combine[(AC)](AC_or_AC), (AD));
								} or {
									return pair_equal_condition(A)(A)(C)(D)(AA_pair)(CD_pair)(and(and(left(left(AB_tuple_condition)), right(left(CD_tuple_condition))), AA_CD));
								};
								is_swap_tuple = pair_swap_equal(AA_pair)(AB_pair)(E)(right(AB_tuple_condition));
								AB_CC_or_AB_CD = pair_equal_condition(AB_pair)(AA_pair)(CC_pair)(CD_pair)(E)(F)(and(and(is_swap_tuple, right(CD_tuple_condition)), right(p)));
								BA_condition = pair_swap_equal(A)(B)(AB_pair)(right(left(AB_tuple_condition)));
								BC_or_BD = branch(AB_CC_or_AB_CD, AB_CC, AB_CD){
									BC_or_BC = pair_equal_condition(B)(A)(C)(C)(AB_pair)(CC_pair)(and(and(BA_condition, left(left(CD_tuple_condition))), AB_CC));
									define BC: equal_sets(B, C);
									define BD: equal_sets(B, D);
									return or(or_combine[(BC)](BC_or_BC), (BD));
								} or {
									return pair_equal_condition(B)(A)(C)(D)(AB_pair)(CD_pair)(and(and(BA_condition, right(left(CD_tuple_condition))), AB_CD));
								};

								FE = equal_sets_symmetric(E)(F)(right(p));
								CC_AA_or_CC_AB = pair_equal_condition(CC_pair)(CD_pair)(AA_pair)(AB_pair)(F)(E)(and(and(right(CD_tuple_condition), right(AB_tuple_condition)), FE));
								CA_or_CB = branch(CC_AA_or_CC_AB, CC_AA, CC_AB){
									CA_or_CA = pair_equal_condition(C)(C)(A)(A)(CC_pair)(AA_pair)(and(and(left(left(CD_tuple_condition)), left(left(AB_tuple_condition))), CC_AA));
									define CA: equal_sets(C, A);
									define CB: equal_sets(C, B);
									return or(or_combine[(CA)](CA_or_CA), (CB));
								} or {
									return pair_equal_condition(C)(C)(A)(B)(CC_pair)(AB_pair)(and(and(left(left(CD_tuple_condition)), right(left(AB_tuple_condition))), CC_AB));
								};
								
								is_swap_tuple = pair_swap_equal(CC_pair)(CD_pair)(F)(right(CD_tuple_condition));
								CD_AA_or_CD_AB = pair_equal_condition(CD_pair)(CC_pair)(AA_pair)(AB_pair)(F)(E)(and(and(is_swap_tuple, right(AB_tuple_condition)), FE));
								DC_condition = pair_swap_equal(C)(D)(CD_pair)(right(left(CD_tuple_condition)));
								DA_or_DB = branch(CD_AA_or_CD_AB, CD_AA, CD_AB){
									DA_or_DA = pair_equal_condition(D)(C)(A)(A)(CD_pair)(AA_pair)(and(and(DC_condition, left(left(AB_tuple_condition))), CD_AA));
									define DA: equal_sets(D, A);
									define DB: equal_sets(D, B);
									return or(or_combine[(DA)](DA_or_DA), (DB));
								} or {
									return pair_equal_condition(D)(C)(A)(B)(CD_pair)(AB_pair)(and(and(DC_condition, right(left(AB_tuple_condition))), CD_AB));
								};

								//Now we split into 4 cases
								return branch(AC_or_AD, AC, AD){
									return branch(BC_or_BD, BC, BD){
										AB = equal_sets_transitive(A)(C)(B)(and(AC, equal_sets_symmetric(B)(C)(BC)));
										return branch(DA_or_DB, DA, DB){
											DB = equal_sets_transitive(D)(A)(B)(and(DA, AB));
											return and(AC, equal_sets_symmetric(D)(B)(DB));
										} or {
											return and(AC, equal_sets_symmetric(D)(B)(DB));
										};
									} or {
										return and(AC, BD);
									};
								} or {
									return branch(BC_or_BD, BC, BD){
										//The critical case
										define XX_pair_condition(X): is_pair(X, X, AA_pair);
										DD_pair_condition = left(equality_consistency[(XX_pair_condition)](A)(D)(AD))(left(left(AB_tuple_condition)));
										CD = branch(AA_CC_or_AA_CD, AA_CC, AA_CD){
											CD_or_CD = pair_equal_condition(C)(C)(D)(D)(CC_pair)(AA_pair)(and(and(left(left(CD_tuple_condition)), DD_pair_condition), equal_sets_symmetric(AA_pair)(CC_pair)(AA_CC)));
											define CD: equal_sets(C, D);
											return or_combine[(CD)](CD_or_CD);
										} or {
											CD_or_CD = pair_equal_condition(C)(D)(D)(D)(CD_pair)(AA_pair)(and(and(right(left(CD_tuple_condition)), DD_pair_condition), equal_sets_symmetric(AA_pair)(CD_pair)(AA_CD)));
											define CD: equal_sets(C, D);
											return or_combine[(CD)](CD_or_CD);
										};
										AC = equal_sets_transitive(A)(D)(C)(and(AD, equal_sets_symmetric(C)(D)(CD)));
										BD = equal_sets_transitive(B)(C)(D)(and(BC, CD));
										return and(AC, BD);
									} or {
										AB = equal_sets_transitive(A)(D)(B)(and(AD, equal_sets_symmetric(B)(D)(BD)));
										return branch(CA_or_CB, CA, CB){
											return and(equal_sets_symmetric(C)(A)(CA), BD);
										} or {
											CA = equal_sets_transitive(C)(B)(A)(and(CB, equal_sets_symmetric(A)(B)(AB)));
											return and(equal_sets_symmetric(C)(A)(CA), BD);
										};
									};
								};
							}
						}
					}
				}
			}
		}
	}
}
