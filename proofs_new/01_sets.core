//Just for copying a set
prove copy_set: *A^B(A = B){
	given |A|;
	choose A;
	return equal_reflexive(A);
}

prove empty_unique: *A*B(is_empty(A) & is_empty(B) -> A = B){
	given |A, B|;
	implies empty_A, empty_B;
	prove A_eq_B: *X(X in A <-> X in B){
		given |X|;
		prove lemma0: X in A -> X in B{
			implies X_in_A;
			return absurdity[goal](expand(empty_A)(X)(X_in_A));
		}
		prove lemma1: X in B -> X in A{
			implies X_in_B;
			return absurdity[goal](expand(empty_B)(X)(X_in_B));
		}
		return iff(lemma0, lemma1);
	}
	return #=(A, B)(A_eq_B);
}

prove subset_reflexive: *A(A <= A){
	given |A|;

	prove subset_def: *X(X in A -> X in A){
		given |X|;
		implies X_in_A;
		return X_in_A;
	}
	return #<=(A, A)(subset_def);
}

prove subset_transitive: *A*B*C(A <= B & B <= C -> A <= C){
	given |A, B, C|;
	implies A_subset_B, B_subset_C;
	prove A_subset_C: *X(X in A -> X in C){
		given |X|;
		implies X_in_A;
		X_in_B = expand(A_subset_B)(X)(X_in_A);
		return expand(B_subset_C)(X)(X_in_B);
	}
	return #<=(A, C)(A_subset_C);
}

prove successor_subset: *A*B(successor(A, B) -> A <= B){
	given |A, B|;
	implies successor_B;
	prove A_subset_B: *X(X in A -> X in B){
		given |X|;
		implies X_in_A;
		return expand(successor_B)(X)(or(X_in_A, <: X = A>));
	}
	return #<=(A, B)(A_subset_B);
}

//I need to prove that we can't have A in B & B in A
prove no_recursive_membership: *A*B(~B in A | ~A in B){
	given |A, B|;
	pair_C = pair(A, B)|C|;
	A_in_C = expand(pair_C)(A)(or(equal_reflexive(A), <: A = B>));
	B_in_C = expand(pair_C)(B)(or(<: B = A>, equal_reflexive(B)));
	prove C_not_empty: ^X(X in C){
		choose A;
		return A_in_C;
	}
	X_in_C, disjoint = axiom_regularity(C)(C_not_empty)|X|;
	return branch(expand(pair_C)(X)(X_in_C), X_eq_A, X_eq_B){
		return branch(disjoint(B), B_not_in_X, B_not_in_C){
			return or(replace[<Q: ~B in Q>](X, A)(X_eq_A)(B_not_in_X), <: ~A in B>);
		} or {
			contradiction = B_not_in_C(B_in_C);
			return absurdity[goal](contradiction);
		};
	} or {
		return branch(disjoint(A), A_not_in_X, A_not_in_C){
			return or(<: ~B in A>, replace[<Q: ~A in Q>](X, B)(X_eq_B)(A_not_in_X));
		} or {
			contradiction = A_not_in_C(A_in_C);
			return absurdity[goal](contradiction);
		};
	};
}

define is_power_set(A, B): *X(X in B <-> X <= A);

prove power_set: *A^B(is_power_set(A, B)){
	given |A|;
	contains_subsets = axiom_power_set(A)|B_BIG|;
	restricted = specify[<X: X <= A>](B_BIG)|B|;
	choose B;
	prove power_set_def: *X(X in B <-> X <= A){
		given |X|;
		prove lemma0: X in B -> X <= A{
			implies X_in_B;
			X_in_B_BIG, result = restricted(X)(X_in_B);
			return result;
		}
		prove lemma1: X <= A -> X in B{
			implies X_subset_A;
			X_in_B_BIG = contains_subsets(X)(X_subset_A);
			return restricted(X)(X_in_B_BIG, X_subset_A);
		}
		return iff(lemma0, lemma1);
	}
	return #is_power_set(A, B)(power_set_def);
}

prove power_set_unique: *A*B*C(is_power_set(A, B) & is_power_set(A, C) -> B = C){
	given |A, B, C|;
	implies power_set_B, power_set_C;
	return definition_uniqueness_lemma[<X: X <= A>](B, C)(expand(power_set_B), expand(power_set_C));
}

define is_tuple(A, B, C): *E*F(is_pair(A, A, E) & is_pair(A, B, F) -> is_pair(E, F, C));

prove tuple: *A*B^C(is_tuple(A, B, C)){
	given |A, B|;
	E_pair = pair(A, A)|E|;
	F_pair = pair(A, B)|F|;
	C_pair = pair(E, F)|C|;
	choose C;
	prove tuple_def: *E_OTHER*F_OTHER(is_pair(A, A, E_OTHER) & is_pair(A, B, F_OTHER) -> is_pair(E_OTHER, F_OTHER, C)){
		given |E_OTHER, F_OTHER|;
		implies pair_E_OTHER, pair_F_OTHER;
		E_equals_E_OTHER = pair_unique(A, A, E, E_OTHER)(E_pair, pair_E_OTHER);
		F_equals_F_OTHER = pair_unique(A, B, F, F_OTHER)(F_pair, pair_F_OTHER);
		result = replace[<X: is_pair(X, F, C)>](E, E_OTHER)(E_equals_E_OTHER)(C_pair);
		return replace[<X: is_pair(E_OTHER, X, C)>](F, F_OTHER)(F_equals_F_OTHER)(result);
	}
	return #is_tuple(A, B, C)(tuple_def);
}

prove tuple_unique: *A*B*C*D(is_tuple(A, B, C) & is_tuple(A, B, D) -> C = D){
	given |A, B, C, D|;
	implies tuple_C, tuple_D;
	condition_C = expand(tuple_C);
	condition_D = expand(tuple_D);
	E_pair = pair(A, A)|E|;
	F_pair = pair(A, B)|F|;
	pair_C = condition_C(E, F)(E_pair, F_pair);
	pair_D = condition_D(E, F)(E_pair, F_pair);
	return pair_unique(E, F, C, D)(pair_C, pair_D);
}

prove tuple_equal: *A*B*C*D*E(is_tuple(A, B, E) & is_tuple(C, D, E) -> A = C & B = D){
	given |A, B, C, D, E|;
	implies tuple_A_B, tuple_C_D;
	pair_G = pair(A, A)|G|;
	pair_H = pair(A, B)|H|;
	pair_E = expand(tuple_A_B)(G, H)(pair_G, pair_H);
	G_in_E = expand(pair_E)(G)(or(equal_reflexive(G), <:G = H>));
	H_in_E = expand(pair_E)(H)(or(<:H = G>, equal_reflexive(H)));

	pair_I = pair(C, C)|I|;
	pair_J = pair(C, D)|J|;
	pair_E2 = expand(tuple_C_D)(I, J)(pair_I, pair_J);
	I_in_E = expand(pair_E2)(I)(or(equal_reflexive(I), <:I = J>));
	J_in_E = expand(pair_E2)(J)(or(<:J = I>, equal_reflexive(J)));
	G_equal_I_or_G_equal_J = expand(pair_E2)(G)(G_in_E);
	H_equal_I_or_H_equal_J = expand(pair_E2)(H)(H_in_E);
	A_in_G = expand(pair_G)(A)(or(equal_reflexive(A), equal_reflexive(A)));
	A_in_H = expand(pair_H)(A)(or(equal_reflexive(A), <:A = B>));
	B_in_H = expand(pair_H)(B)(or(<:B = A>, equal_reflexive(B)));
	I_equal_G_or_I_equal_H = expand(pair_E)(I)(I_in_E);
	J_equal_G_or_J_equal_H = expand(pair_E)(J)(J_in_E);
	C_in_I = expand(pair_I)(C)(or(equal_reflexive(C), equal_reflexive(C)));
	D_in_J = expand(pair_J)(D)(or(<:D = C>, equal_reflexive(D)));

	A_equal_C_or_D = branch(G_equal_I_or_G_equal_J, G_equal_I, G_equal_J){
		A_in_I = replace[<Q: A in Q>](G, I)(G_equal_I)(A_in_G);
		A_equal_C_or = expand(pair_I)(A)(A_in_I);
		A_equal_C = branch(A_equal_C_or, A_equal_C, A_equal_C){return A_equal_C;} or {return A_equal_C;};
		return or(A_equal_C, <:A = D>);
	} or {
		A_in_J = replace[<Q: A in Q>](G, J)(G_equal_J)(A_in_G);
		return expand(pair_J)(A)(A_in_J);
	};
	return branch(A_equal_C_or_D, A_equal_C, A_equal_D){
		return branch(H_equal_I_or_H_equal_J, H_equal_I, H_equal_J){
			B_in_I = replace[<Q: B in Q>](H, I)(H_equal_I)(B_in_H);
			B_equal_C_or = expand(pair_I)(B)(B_in_I);
			B_equal_C = branch(B_equal_C_or, B_equal_C, B_equal_C){return B_equal_C;} or {return B_equal_C;};
			A_equal_B = equal_transitive(A, C, B)(A_equal_C, equal_symmetric(B, C)(B_equal_C));
			D_equal_B = branch(J_equal_G_or_J_equal_H, J_equal_G, J_equal_H){
				D_in_G = replace[<Q: D in Q>](J, G)(J_equal_G)(D_in_J);
				D_equal_A_or = expand(pair_G)(D)(D_in_G);
				D_equal_A = branch(D_equal_A_or, D_equal_A, D_equal_A){return D_equal_A;} or {return D_equal_A;};
				return equal_transitive(D, A, B)(D_equal_A, A_equal_B);
			} or {
				D_in_H = replace[<Q: D in Q>](J, H)(J_equal_H)(D_in_J);
				D_equal_A_or_B = expand(pair_H)(D)(D_in_H);
				return branch(D_equal_A_or_B, D_equal_A, D_equal_B){
					return equal_transitive(D, A, B)(D_equal_A, A_equal_B);
				} or {
					return D_equal_B;
				};
			};
			return and(A_equal_C, equal_symmetric(D, B)(D_equal_B));
		} or {
			B_in_J = replace[<Q: B in Q>](H, J)(H_equal_J)(B_in_H);
			B_equal_C_or_D = expand(pair_J)(B)(B_in_J);
			return branch(B_equal_C_or_D, B_equal_C, B_equal_D){
				D_equal_A_or_B = branch(J_equal_G_or_J_equal_H, J_equal_G, J_equal_H){
					D_in_G = replace[<Q: D in Q>](J, G)(J_equal_G)(D_in_J);
					D_equal_A_or = expand(pair_G)(D)(D_in_G);
					D_equal_A = branch(D_equal_A_or, D_equal_A, D_equal_A){return D_equal_A;} or {return D_equal_A;};
					return or(D_equal_A, <:D = B>);
				} or {
					D_in_H = replace[<Q: D in Q>](J, H)(J_equal_H)(D_in_J);
					return expand(pair_H)(D)(D_in_H);
				};
				return branch(D_equal_A_or_B, D_equal_A, D_equal_B){
					D_equal_C = equal_transitive(D, A, C)(D_equal_A, A_equal_C);
					B_equal_D = equal_transitive(B, C, D)(B_equal_C, equal_symmetric(D, C)(D_equal_C));
					return and(A_equal_C, B_equal_D);
				} or {
					return and(A_equal_C, equal_symmetric(D, B)(D_equal_B));
				};
			} or {
				return and(A_equal_C, B_equal_D);
			};
		};
	} or {
		A_in_I = branch(I_equal_G_or_I_equal_H, I_equal_G, I_equal_H){
			return replace[<Q: A in Q>](I, G)(I_equal_G)(A_in_G);
		} or {
			return replace[<Q: A in Q>](I, H)(I_equal_H)(A_in_H);
		};
		A_equal_C_or = expand(pair_I)(A)(A_in_I);
		A_equal_C = branch(A_equal_C_or, A_equal_C, A_equal_C){return A_equal_C;} or {return A_equal_C;};
		B_equal_C_or_D = branch(H_equal_I_or_H_equal_J, H_equal_I, H_equal_J){
			B_in_I = replace[<Q: B in Q>](H, I)(H_equal_I)(B_in_H);
			B_equal_C_or = expand(pair_I)(B)(B_in_I);
			B_equal_C = branch(B_equal_C_or, B_equal_C, B_equal_C){return B_equal_C;} or {return B_equal_C;};
			return or(B_equal_C, <:B = D>);
		} or {
			B_in_J = replace[<Q: B in Q>](H, J)(H_equal_J)(B_in_H);
			return expand(pair_J)(B)(B_in_J);
		};
		return branch(B_equal_C_or_D, B_equal_C, B_equal_D){
			D_equal_A_or_B = branch(J_equal_G_or_J_equal_H, J_equal_G, J_equal_H){
				D_in_G = replace[<Q: D in Q>](J, G)(J_equal_G)(D_in_J);
				D_equal_A_or = expand(pair_G)(D)(D_in_G);
				D_equal_A = branch(D_equal_A_or, D_equal_A, D_equal_A){return D_equal_A;} or {return D_equal_A;};
				return or(D_equal_A, <:D = B>);
			} or {
				D_in_H = replace[<Q: D in Q>](J, H)(J_equal_H)(D_in_J);
				return expand(pair_H)(D)(D_in_H);
			};
			return branch(D_equal_A_or_B, D_equal_A, D_equal_B){
				D_equal_C = equal_transitive(D, A, C)(D_equal_A, A_equal_C);
				D_equal_B = equal_transitive(D, C, B)(D_equal_C, equal_symmetric(B, C)(B_equal_C));
				return and(A_equal_C, equal_symmetric(D, B)(D_equal_B));
			} or {
				return and(A_equal_C, equal_symmetric(D, B)(D_equal_B));
			};
		} or {
			return and(A_equal_C, B_equal_D);
		};
	};
}

define is_intersection(A, B): *X(X in B <-> *Y(Y in A -> X in Y));

prove intersection: *A(not_empty(A) -> ^B(is_intersection(A, B))){
	given |A|;
	implies nonempty;
	F_in_A = expand(nonempty)|F|;
	restriction = specify[<Q: *Y(Y in A -> Q in Y)>](F)|B|;
	choose B;
	prove intersection_def: *X(X in B <-> *Y(Y in A -> X in Y)){
		given |X|;
		prove lemma0: X in B -> *Y(Y in A -> X in Y){
			implies X_in_B;
			X_in_F, result = restriction(X)(X_in_B);
			return result;
		}
		prove lemma1: *Y(Y in A -> X in Y) -> X in B{
			implies premise;
			X_in_F = premise(F)(F_in_A);
			return restriction(X)(X_in_F, premise);
		}
		return iff(lemma0, lemma1);
	}
	return #is_intersection(A, B)(intersection_def);
}

prove intersection_unique: *A*B*C(is_intersection(A, B) & is_intersection(A, C) -> B = C){
	given |A, B, C|;
	implies intersection_B, intersection_C;
	return definition_uniqueness_lemma[<X: *Y(Y in A -> X in Y)>](B, C)(expand(intersection_B), expand(intersection_C));
}

prove intersection_subset: *R*F*I(is_intersection(F, I) & *J(J in F -> R <= J) -> R <= I){
	given |R, F, I|;
	implies intersection_I, condition;
	prove subset_def: *X(X in R -> X in I){
		given |X|;
		implies X_in_R;
		prove X_in_I: *J(J in F -> X in J){
			given |J|;
			implies J_in_F;
			return expand(condition(J)(J_in_F))(X)(X_in_R);
		}
		return expand(intersection_I)(X)(X_in_I);
	}
	return #<=(R, I)(subset_def);
}

prove operation_uniqueness_lemma[P(1), Q(1)]: ^X(P(X)) & *X*Y(P(X) & P(Y) -> X = Y) -> (*X(P(X) -> Q(X)) <-> ^X(P(X) & Q(X))){
	implies exists, unique;
	
	prove lemma0: *X(P(X) -> Q(X)) -> ^X(P(X) & Q(X)){
		implies premise;

		P_X = exists|X|;
		choose X;
		Q_X = premise(X)(P_X);
		return P_X, Q_X;
	}

	prove lemma1: ^X(P(X) & Q(X)) -> *X(P(X) -> Q(X)){
		implies premise;

		P_X, Q_X = premise|X|;
		given |Y|;
		implies P_Y;
		X_eq_Y = unique(X, Y)(P_X, P_Y);
		return replace[<J: Q(J)>](X, Y)(X_eq_Y)(Q_X);
	}

	return iff(lemma0, lemma1);
}

prove pairs: *A*B^P*X(X in P <-> ^Y^Z(Y in A & Z in B & is_pair(Y, Z, X))){
	given |A, B|;
	
	pair_Q = pair(A, B)|Q|;
	union_U = union(Q)|U|;
	power_set_R = power_set(U)|R|;
	specified_P = specify[<X: ^Y^Z(Y in A & Z in B & is_pair(Y, Z, X))>](R)|P|;
	choose P;
	given |X|;

	prove lemma0: X in P -> ^Y^Z(Y in A & Z in B & is_pair(Y, Z, X)){
		implies X_in_P;
		X_in_R, result = specified_P(X)(X_in_P);
		return result;
	}

	prove lemma1: ^Y^Z(Y in A & Z in B & is_pair(Y, Z, X)) -> X in P{
		implies exists;
		Y_in_A, Z_in_B, pair_X = exists|Y, Z|;
		prove Y_in_U: ^J(J in Q & Y in J){
			choose A;
			return expand(pair_Q)(A)(or(equal_reflexive(A), <:A = B>)), Y_in_A;
		}
		Y_in_U = expand(union_U)(Y)(Y_in_U);
		prove Z_in_U: ^J(J in Q & Z in J){
			choose B;
			return expand(pair_Q)(B)(or(<:B = A>, equal_reflexive(B))), Z_in_B;
		}
		Z_in_U = expand(union_U)(Z)(Z_in_U);
		
		prove X_subset_U: *J(J in X -> J in U){
			given |J|;
			implies J_in_X;
			either_Y_Z = expand(pair_X)(J)(J_in_X);
			return branch(either_Y_Z, J_eq_Y, J_eq_Z){
				return replace[<K: K in U>](J, Y)(J_eq_Y)(Y_in_U);
			} or {
				return replace[<K: K in U>](J, Z)(J_eq_Z)(Z_in_U);
			};
		}
		X_subset_U = #<=(X, U)(X_subset_U);
		X_in_R = expand(power_set_R)(X)(X_subset_U);
		return specified_P(X)(X_in_R, exists);
	}

	return iff(lemma0, lemma1);
}

define is_cross_product(A, B, C): *X(X in C <-> ^Y^Z(Y in A & Z in B & is_tuple(Y, Z, X)));

prove cross_product: *A*B^C(is_cross_product(A, B, C)){
	given |A, B|;

	pairs_AA = pairs(A, A)|AA|;
	pairs_AB = pairs(A, B)|AB|;
	pairs_T = pairs(AA, AB)|T|;
	specified_C = specify[<Q: ^Y^Z(Y in A & Z in B & is_tuple(Y, Z, Q))>](T)|C|;
	choose C;

	prove cross_product_def: *X(X in C <-> ^Y^Z(Y in A & Z in B & is_tuple(Y, Z, X))){
		given |X|;
		prove lemma0: X in C -> ^Y^Z(Y in A & Z in B & is_tuple(Y, Z, X)){
			implies X_in_C;
			X_in_T, result = specified_C(X)(X_in_C);
			return result;
		}

		prove lemma1: ^Y^Z(Y in A & Z in B & is_tuple(Y, Z, X)) -> X in C{
			implies exists;
			Y_in_A, Z_in_B, tuple_X = exists|Y, Z|;
			pair_YY = pair(Y, Y)|YY|;
			prove YY_in_AA: ^J^K(J in A & K in A & is_pair(J, K, YY)){
				choose Y, Y;
				return Y_in_A, Y_in_A, pair_YY;
			}
			YY_in_AA = pairs_AA(YY)(YY_in_AA);
			pair_YZ = pair(Y, Z)|YZ|;
			prove YZ_in_AB: ^J^K(J in A & K in B & is_pair(J, K, YZ)){
				choose Y, Z;
				return Y_in_A, Z_in_B, pair_YZ;
			}
			YZ_in_AB = pairs_AB(YZ)(YZ_in_AB);
			
			pair_X = expand(tuple_X)(YY, YZ)(pair_YY, pair_YZ);
			prove X_in_T: ^J^K(J in AA & K in AB & is_pair(J, K, X)){
				choose YY, YZ;
				return YY_in_AA, YZ_in_AB, pair_X;
			}
			X_in_T = pairs_T(X)(X_in_T);

			return specified_C(X)(X_in_T, exists);
		}

		return iff(lemma0, lemma1);
	}

	return #is_cross_product(A, B, C)(cross_product_def);
}

prove cross_product_unique: *A*B*C*D(is_cross_product(A, B, C) & is_cross_product(A, B, D) -> C = D){
	given |A, B, C, D|;
	implies cross_product_C, cross_product_D;
	return definition_uniqueness_lemma[<Q: ^X^Y(X in A & Y in B & is_tuple(X, Y, Q))>](C, D)(expand(cross_product_C), expand(cross_product_D));
}

prove negate_exists[P(1)]: ~^X(P(X)) <-> *X(~P(X)){
	prove lemma0: ~^X(P(X)) -> *X(~P(X)){
		implies premise;
		given |X|;
		not P_X;
		prove exists: ^X(P(X)){
			choose X;
			return P_X;
		}
		return premise(exists);
	}

	prove lemma1: *X(~P(X)) -> ~^X(P(X)){
		implies premise;
		not exists;
		P_X = exists|X|;
		return premise(X)(P_X);
	}

	return iff(lemma0, lemma1);
}
