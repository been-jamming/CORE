//Just for copying a set
prove copy_set: *A^B(A = B){
	given |A|;
	choose A;
	return equal_reflexive(A);
}

define is_power_set(A, B): *X(X in B <-> X <= A);

prove power_set: *A^B(is_power_set(A, B)){
	given |A|;
	contains_subsets = axiom_power_set(A)|B_BIG|;
	restricted = specify[<X: X <= A>](B_BIG)|B|;
	choose B;
	prove power_set_def: *X(X in B <-> X <= A){
		given |X|;
		prove lemma0: X in B -> X <= A{
			implies X_in_B;
			X_in_B_BIG, result = restricted(X)(X_in_B);
			return result;
		}
		prove lemma1: X <= A -> X in B{
			implies X_subset_A;
			X_in_B_BIG = contains_subsets(X)(X_subset_A);
			return restricted(X)(X_in_B_BIG, X_subset_A);
		}
		return iff(lemma0, lemma1);
	}
	return #is_power_set(A, B)(power_set_def);
}

define is_tuple(A, B, C): *E*F(is_pair(A, A, E) & is_pair(A, B, F) -> is_pair(E, F, C));

prove tuple: *A*B^C(is_tuple(A, B, C)){
	given |A, B|;
	E_pair = pair(A, A)|E|;
	F_pair = pair(A, B)|F|;
	C_pair = pair(E, F)|C|;
	choose C;
	prove tuple_def: *E_OTHER*F_OTHER(is_pair(A, A, E_OTHER) & is_pair(A, B, F_OTHER) -> is_pair(E_OTHER, F_OTHER, C)){
		given |E_OTHER, F_OTHER|;
		implies pair_E_OTHER, pair_F_OTHER;
		E_equals_E_OTHER = pair_unique(A, A, E, E_OTHER)(E_pair, pair_E_OTHER);
		F_equals_F_OTHER = pair_unique(A, B, F, F_OTHER)(F_pair, pair_F_OTHER);
		result = replace[<X: is_pair(X, F, C)>](E, E_OTHER)(E_equals_E_OTHER)(C_pair);
		return replace[<X: is_pair(E_OTHER, X, C)>](F, F_OTHER)(F_equals_F_OTHER)(result);
	}
	return #is_tuple(A, B, C)(tuple_def);
}

prove tuple_unique: *A*B*C*D(is_tuple(A, B, C) & is_tuple(A, B, D) -> C = D){
	given |A, B, C, D|;
	implies tuple_C, tuple_D;
	condition_C = expand(tuple_C);
	condition_D = expand(tuple_D);
	E_pair = pair(A, A)|E|;
	F_pair = pair(A, B)|F|;
	pair_C = condition_C(E, F)(E_pair, F_pair);
	pair_D = condition_D(E, F)(E_pair, F_pair);
	return pair_unique(E, F, C, D)(pair_C, pair_D);
}

prove tuple_equal: *A*B*C*D*E(is_tuple(A, B, E) & is_tuple(C, D, E) -> A = C & B = D){
	given |A, B, C, D, E|;
	implies tuple_A_B, tuple_C_D;
	pair_G = pair(A, A)|G|;
	pair_H = pair(A, B)|H|;
	pair_E = expand(tuple_A_B)(G, H)(pair_G, pair_H);
	G_in_E = expand(pair_E)(G)(or(equal_reflexive(G), <:G = H>));
	H_in_E = expand(pair_E)(H)(or(<:H = G>, equal_reflexive(H)));

	pair_I = pair(C, C)|I|;
	pair_J = pair(C, D)|J|;
	pair_E2 = expand(tuple_C_D)(I, J)(pair_I, pair_J);
	I_in_E = expand(pair_E2)(I)(or(equal_reflexive(I), <:I = J>));
	J_in_E = expand(pair_E2)(J)(or(<:J = I>, equal_reflexive(J)));
	G_equal_I_or_G_equal_J = expand(pair_E2)(G)(G_in_E);
	H_equal_I_or_H_equal_J = expand(pair_E2)(H)(H_in_E);
	A_in_G = expand(pair_G)(A)(or(equal_reflexive(A), equal_reflexive(A)));
	A_in_H = expand(pair_H)(A)(or(equal_reflexive(A), <:A = B>));
	B_in_H = expand(pair_H)(B)(or(<:B = A>, equal_reflexive(B)));
	I_equal_G_or_I_equal_H = expand(pair_E)(I)(I_in_E);
	J_equal_G_or_J_equal_H = expand(pair_E)(J)(J_in_E);
	C_in_I = expand(pair_I)(C)(or(equal_reflexive(C), equal_reflexive(C)));
	D_in_J = expand(pair_J)(D)(or(<:D = C>, equal_reflexive(D)));

	A_equal_C_or_D = branch(G_equal_I_or_G_equal_J, G_equal_I, G_equal_J){
		A_in_I = replace[<Q: A in Q>](G, I)(G_equal_I)(A_in_G);
		A_equal_C_or = expand(pair_I)(A)(A_in_I);
		A_equal_C = branch(A_equal_C_or, A_equal_C, A_equal_C){return A_equal_C;} or {return A_equal_C;};
		return or(A_equal_C, <:A = D>);
	} or {
		A_in_J = replace[<Q: A in Q>](G, J)(G_equal_J)(A_in_G);
		return expand(pair_J)(A)(A_in_J);
	};
	return branch(A_equal_C_or_D, A_equal_C, A_equal_D){
		return branch(H_equal_I_or_H_equal_J, H_equal_I, H_equal_J){
			B_in_I = replace[<Q: B in Q>](H, I)(H_equal_I)(B_in_H);
			B_equal_C_or = expand(pair_I)(B)(B_in_I);
			B_equal_C = branch(B_equal_C_or, B_equal_C, B_equal_C){return B_equal_C;} or {return B_equal_C;};
			A_equal_B = equal_transitive(A, C, B)(A_equal_C, equal_symmetric(B, C)(B_equal_C));
			D_equal_B = branch(J_equal_G_or_J_equal_H, J_equal_G, J_equal_H){
				D_in_G = replace[<Q: D in Q>](J, G)(J_equal_G)(D_in_J);
				D_equal_A_or = expand(pair_G)(D)(D_in_G);
				D_equal_A = branch(D_equal_A_or, D_equal_A, D_equal_A){return D_equal_A;} or {return D_equal_A;};
				return equal_transitive(D, A, B)(D_equal_A, A_equal_B);
			} or {
				D_in_H = replace[<Q: D in Q>](J, H)(J_equal_H)(D_in_J);
				D_equal_A_or_B = expand(pair_H)(D)(D_in_H);
				return branch(D_equal_A_or_B, D_equal_A, D_equal_B){
					return equal_transitive(D, A, B)(D_equal_A, A_equal_B);
				} or {
					return D_equal_B;
				};
			};
			return and(A_equal_C, equal_symmetric(D, B)(D_equal_B));
		} or {
			B_in_J = replace[<Q: B in Q>](H, J)(H_equal_J)(B_in_H);
			B_equal_C_or_D = expand(pair_J)(B)(B_in_J);
			return branch(B_equal_C_or_D, B_equal_C, B_equal_D){
				D_equal_A_or_B = branch(J_equal_G_or_J_equal_H, J_equal_G, J_equal_H){
					D_in_G = replace[<Q: D in Q>](J, G)(J_equal_G)(D_in_J);
					D_equal_A_or = expand(pair_G)(D)(D_in_G);
					D_equal_A = branch(D_equal_A_or, D_equal_A, D_equal_A){return D_equal_A;} or {return D_equal_A;};
					return or(D_equal_A, <:D = B>);
				} or {
					D_in_H = replace[<Q: D in Q>](J, H)(J_equal_H)(D_in_J);
					return expand(pair_H)(D)(D_in_H);
				};
				return branch(D_equal_A_or_B, D_equal_A, D_equal_B){
					D_equal_C = equal_transitive(D, A, C)(D_equal_A, A_equal_C);
					B_equal_D = equal_transitive(B, C, D)(B_equal_C, equal_symmetric(D, C)(D_equal_C));
					return and(A_equal_C, B_equal_D);
				} or {
					return and(A_equal_C, equal_symmetric(D, B)(D_equal_B));
				};
			} or {
				return and(A_equal_C, B_equal_D);
			};
		};
	} or {
		A_in_I = branch(I_equal_G_or_I_equal_H, I_equal_G, I_equal_H){
			return replace[<Q: A in Q>](I, G)(I_equal_G)(A_in_G);
		} or {
			return replace[<Q: A in Q>](I, H)(I_equal_H)(A_in_H);
		};
		A_equal_C_or = expand(pair_I)(A)(A_in_I);
		A_equal_C = branch(A_equal_C_or, A_equal_C, A_equal_C){return A_equal_C;} or {return A_equal_C;};
		B_equal_C_or_D = branch(H_equal_I_or_H_equal_J, H_equal_I, H_equal_J){
			B_in_I = replace[<Q: B in Q>](H, I)(H_equal_I)(B_in_H);
			B_equal_C_or = expand(pair_I)(B)(B_in_I);
			B_equal_C = branch(B_equal_C_or, B_equal_C, B_equal_C){return B_equal_C;} or {return B_equal_C;};
			return or(B_equal_C, <:B = D>);
		} or {
			B_in_J = replace[<Q: B in Q>](H, J)(H_equal_J)(B_in_H);
			return expand(pair_J)(B)(B_in_J);
		};
		return branch(B_equal_C_or_D, B_equal_C, B_equal_D){
			D_equal_A_or_B = branch(J_equal_G_or_J_equal_H, J_equal_G, J_equal_H){
				D_in_G = replace[<Q: D in Q>](J, G)(J_equal_G)(D_in_J);
				D_equal_A_or = expand(pair_G)(D)(D_in_G);
				D_equal_A = branch(D_equal_A_or, D_equal_A, D_equal_A){return D_equal_A;} or {return D_equal_A;};
				return or(D_equal_A, <:D = B>);
			} or {
				D_in_H = replace[<Q: D in Q>](J, H)(J_equal_H)(D_in_J);
				return expand(pair_H)(D)(D_in_H);
			};
			return branch(D_equal_A_or_B, D_equal_A, D_equal_B){
				D_equal_C = equal_transitive(D, A, C)(D_equal_A, A_equal_C);
				D_equal_B = equal_transitive(D, C, B)(D_equal_C, equal_symmetric(B, C)(B_equal_C));
				return and(A_equal_C, equal_symmetric(D, B)(D_equal_B));
			} or {
				return and(A_equal_C, equal_symmetric(D, B)(D_equal_B));
			};
		} or {
			return and(A_equal_C, B_equal_D);
		};
	};
}

define is_intersection(A, B): *X(X in B <-> *Y(Y in A -> X in Y));

prove intersection: *A(not_empty(A) -> ^B(is_intersection(A, B))){
	given |A|;
	implies nonempty;
	F_in_A = expand(nonempty)|F|;
	restriction = specify[<Q: *Y(Y in A -> Q in Y)>](F)|B|;
	choose B;
	prove intersection_def: *X(X in B <-> *Y(Y in A -> X in Y)){
		given |X|;
		prove lemma0: X in B -> *Y(Y in A -> X in Y){
			implies X_in_B;
			X_in_F, result = restriction(X)(X_in_B);
			return result;
		}
		prove lemma1: *Y(Y in A -> X in Y) -> X in B{
			implies premise;
			X_in_F = premise(F)(F_in_A);
			return restriction(X)(X_in_F, premise);
		}
		return iff(lemma0, lemma1);
	}
	return #is_intersection(A, B)(intersection_def);
}

prove intersection_unique: *A*B*C(is_intersection(A, B) & is_intersection(A, C) -> B = C){
	given |A, B, C|;
	implies intersection_B, intersection_C;
	return definition_uniqueness_lemma[<X: *Y(Y in A -> X in Y)>](B, C)(expand(intersection_B), expand(intersection_C));
}

