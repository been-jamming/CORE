define related(A, B, R): *T(is_tuple(A, B, T) -> T in R);

define reflexive(A, R): *X(X in A -> related(X, X, R));

define symmetric(R): *X*Y(related(X, Y, R) -> related(Y, X, R));

define transitive(R): *X*Y*Z(related(X, Y, R) & related(Y, Z, R) -> related(X, Z, R));

define relation_between(A, B, R): *C(is_cross_product(A, B, C) -> R <= C);

define equiv_relation(A, R): relation_between(A, A, R) & reflexive(A, R) & symmetric(R) & transitive(R);

define equiv_class(A, R, C): ^P(P in A & *X(X in C <-> related(P, X, R)));

define equiv_classes(A, R, C): *X(X in C <-> equiv_class(A, R, X));

define function(A, B, F): relation_between(A, B, F) & *X(X in A -> ^Y(Y in B & related(X, Y, F))) & *X*Y*Z(related(X, Y, F) & related(X, Z, F) -> Y = Z);

//When H is a composition of functions F: A->B and G: B->C
define composition(F, G, H): *X*Y(related(X, Y, H) <-> *Z(related(X, Z, G) -> related(Z, Y, F)));

prove equiv_class_subset: *A*R*C(equiv_relation(A, R) & equiv_class(A, R, C) -> C <= A){
	given |A, R, C|;
	implies equiv_relation_R, class_C;
	between_R, reflexive_R, symmetric_R, transitive_R = expand(equiv_relation_R);
	P_in_A, C_cond = expand(class_C)|P|;
	prove subset_def: *X(X in C -> X in A){
		given |X|;
		implies X_in_C;
		P_related_X = C_cond(X)(X_in_C);
		tuple_T = tuple(P, X)|T|;
		T_in_R = expand(P_related_X)(T)(tuple_T);
		cross_S = cross_product(A, A)|S|;
		T_in_S = expand(expand(between_R)(S)(cross_S))(T)(T_in_R);
		OTHER_P_in_A, OTHER_X_in_A, other_tuple_T = expand(cross_S)(T)(T_in_S)|OTHER_P, OTHER_X|;
		equal_P, equal_X = tuple_equal(P, X, OTHER_P, OTHER_X, T)(tuple_T, other_tuple_T);
		return replace[<Q: Q in A>](X, OTHER_X)(equal_X)(OTHER_X_in_A);
	}
	return #[<=](C, A)(subset_def);
}

prove equiv_classes_exists: *A*R(equiv_relation(A, R) -> ^C(equiv_classes(A, R, C))){
	given |A, R|;
	implies equiv_relation_R;
	power_set_P = power_set(A)|P|;
	specified_C = specify[<Q: equiv_class(A, R, Q)>](P)|C|;
	choose C;
	prove equiv_classes_def: *X(X in C <-> equiv_class(A, R, X)){
		given |X|;
		prove lemma0: X in C -> equiv_class(A, R, X){
			implies X_in_C;
			X_in_P, result = specified_C(X)(X_in_C);
			return result;
		}
		prove lemma1: equiv_class(A, R, X) -> X in C{
			implies equiv_class_X;
			X_subset_A = equiv_class_subset(A, R, X)(equiv_relation_R, equiv_class_X);
			X_in_P = expand(power_set_P)(X)(X_subset_A);
			return specified_C(X)(X_in_P, equiv_class_X);
		}
		return iff(lemma0, lemma1);
	}
	return #equiv_classes(A, R, C)(equiv_classes_def);
}

prove equiv_classes_unique: *A*R*C*D(equiv_classes(A, R, C) & equiv_classes(A, R, D) -> C = D){
	given |A, R, C, D|;
	implies classes_C, classes_D;
	return definition_uniqueness_lemma[<Q: equiv_class(A, R, Q)>](C, D)(expand(classes_C), expand(classes_D));
}

prove equiv_classes_disjoint: *A*R*C*D*X(equiv_relation(A, R) & equiv_class(A, R, C) & equiv_class(A, R, D) & X in C & X in D -> C = D){
	given |A, R, C, D, X|;
	implies equiv_relation_R, equiv_class_C, equiv_class_D, X_in_C, X_in_D;
	between_R, reflexive_R, symmetric_R, transitive_R = expand(equiv_relation_R);
	C_REP_in_A, C_cond = expand(equiv_class_C)|C_REP|;
	D_REP_in_A, D_cond = expand(equiv_class_D)|D_REP|;
	C_REP_related_X = C_cond(X)(X_in_C);
	D_REP_related_X = D_cond(X)(X_in_D);
	prove C_eq_D: *Y(Y in C <-> Y in D){
		given |Y|;
		prove lemma0: Y in C -> Y in D{
			implies Y_in_C;
			C_REP_related_Y = C_cond(Y)(Y_in_C);
			Y_related_C_REP = expand(symmetric_R)(C_REP, Y)(C_REP_related_Y);
			Y_related_X = expand(transitive_R)(Y, C_REP, X)(Y_related_C_REP, C_REP_related_X);
			X_related_Y = expand(symmetric_R)(Y, X)(Y_related_X);
			D_REP_related_Y = expand(transitive_R)(D_REP, X, Y)(D_REP_related_X, X_related_Y);
			return D_cond(Y)(D_REP_related_Y);
		}

		prove lemma1: Y in D -> Y in C{
			implies Y_in_D;
			D_REP_related_Y = D_cond(Y)(Y_in_D);
			Y_related_D_REP = expand(symmetric_R)(D_REP, Y)(D_REP_related_Y);
			Y_related_X = expand(transitive_R)(Y, D_REP, X)(Y_related_D_REP, D_REP_related_X);
			X_related_Y = expand(symmetric_R)(Y, X)(Y_related_X);
			C_REP_related_Y = expand(transitive_R)(C_REP, X, Y)(C_REP_related_X, X_related_Y);
			return C_cond(Y)(C_REP_related_Y);
		}
		return iff(lemma0, lemma1);
	}
	return #[=](C, D)(C_eq_D);
}

prove equiv_class_exists: *A*R*X(equiv_relation(A, R) & X in A -> ^C(equiv_class(A, R, C) & X in C)){
	given |A, R, X|;
	implies equiv_relation_R, X_in_A;
	between_R, reflexive_R, symmetric_R, transitive_R = expand(equiv_relation_R);
	specified_C = specify[<Q: related(X, Q, R)>](A)|C|;
	choose C;
	X_in_C = specified_C(X)(X_in_A, expand(reflexive_R)(X)(X_in_A));
	prove equiv_class_C: ^P(P in A & *Y(Y in C <-> related(P, Y, R))){
		choose X;
		prove condition: *Y(Y in C <-> related(X, Y, R)){
			given |Y|;
			prove lemma0: Y in C -> related(X, Y, R){
				implies Y_in_C;
				Y_in_A, result = specified_C(Y)(Y_in_C);
				return result;
			}

			prove lemma1: related(X, Y, R) -> Y in C{
				implies X_related_Y;
				cross_S = cross_product(A, A)|S|;
				R_subset_S = expand(between_R)(S)(cross_S);
				tuple_T = tuple(X, Y)|T|;
				T_in_R = expand(X_related_Y)(T)(tuple_T);
				T_in_S = expand(R_subset_S)(T)(T_in_R);
				OTHER_X_in_A, OTHER_Y_in_A, other_tuple_T = expand(cross_S)(T)(T_in_S)|OTHER_X, OTHER_Y|;
				X_eq, Y_eq = tuple_equal(X, Y, OTHER_X, OTHER_Y, T)(tuple_T, other_tuple_T);
				Y_in_A = replace[<Q: Q in A>](Y, OTHER_Y)(Y_eq)(OTHER_Y_in_A);
				return specified_C(Y)(Y_in_A, X_related_Y);
			}
			return iff(lemma0, lemma1);
		}
		return X_in_A, condition;
	}
	return #equiv_class(A, R, C)(equiv_class_C), X_in_C;
}

prove relation_existence_lemma[P(2)]: *A*B^R*X*Y(related(X, Y, R) <-> X in A & Y in B & P(X, Y)){
	given |A, B|;
	cross_product_T = cross_product(A, B)|T|;
	specified_R = specify[<Q: *X*Y(is_tuple(X, Y, Q) -> P(X, Y))>](T)|R|;
	choose R;
	given |X, Y|;
	prove lemma0: related(X, Y, R) -> X in A & Y in B & P(X, Y){
		implies X_related_Y;
		tuple_Q = tuple(X, Y)|Q|;
		Q_in_R = expand(X_related_Y)(Q)(tuple_Q);
		Q_in_T, condition = specified_R(Q)(Q_in_R);
		P_X_Y = condition(X, Y)(tuple_Q);
		X_OTHER_in_A, Y_OTHER_in_B, other_tuple_Q = expand(cross_product_T)(Q)(Q_in_T)|X_OTHER, Y_OTHER|;
		X_eq, Y_eq = tuple_equal(X, Y, X_OTHER, Y_OTHER, Q)(tuple_Q, other_tuple_Q);
		X_in_A = replace[<K: K in A>](X, X_OTHER)(X_eq)(X_OTHER_in_A);
		Y_in_B = replace[<K: K in B>](Y, Y_OTHER)(Y_eq)(Y_OTHER_in_B);
		return X_in_A, Y_in_B, P_X_Y;
	}

	prove lemma1: X in A & Y in B & P(X, Y) -> related(X, Y, R){
		implies X_in_A, Y_in_B, P_X_Y;
		prove X_related_Y: *K(is_tuple(X, Y, K) -> K in R){
			given |K|;
			implies tuple_K;

			prove K_in_T: ^X^Y(X in A & Y in B & is_tuple(X, Y, K)){
				choose X, Y;
				return X_in_A, Y_in_B, tuple_K;
			}
			K_in_T = expand(cross_product_T)(K)(K_in_T);

			prove condition: *X_OTHER*Y_OTHER(is_tuple(X_OTHER, Y_OTHER, K) -> P(X_OTHER, Y_OTHER)){
				given |X_OTHER, Y_OTHER|;
				implies other_tuple_K;
				X_eq, Y_eq = tuple_equal(X, Y, X_OTHER, Y_OTHER, K)(tuple_K, other_tuple_K);
				result = replace[<V: P(V, Y)>](X, X_OTHER)(X_eq)(P_X_Y);
				return replace[<V: P(X_OTHER, V)>](Y, Y_OTHER)(Y_eq)(result);
			}

			return specified_R(K)(K_in_T, condition);
		}
		return #related(X, Y, R)(X_related_Y);
	}

	return iff(lemma0, lemma1);
}

prove equiv_relation_sup: *A*R(relation_between(A, A, R) -> ^S(equiv_relation(A, S) & R <= S & *T(equiv_relation(A, T) & R <= T -> S <= T))){
	given |A, R|;
	implies between;

	cross_product_C = cross_product(A, A)|C|;
	R_subset_C = expand(between)(C)(cross_product_C);
	power_set_P = power_set(C)|P|;
	C_in_P = expand(power_set_P)(C)(subset_reflexive(C));
	specified_F = specify[<V: equiv_relation(A, V) & R <= V>](P)|F|;

	//I need to prove that this family of equivalence relations is not empty
	//Luckily, the relation where everything is related is an equivalence relation
	prove C_between_A: *D(is_cross_product(A, A, D) -> C <= D){
		given |D|;
		implies cross_product_D;
		C_eq_D = cross_product_unique(A, A, C, D)(cross_product_C, cross_product_D);
		return replace[<V: C <= V>](C, D)(C_eq_D)(subset_reflexive(C));
	}
	C_between_A = #relation_between(A, A, C)(C_between_A);

	prove C_reflexive: *X(X in A -> related(X, X, C)){
		given |X|;
		implies X_in_A;
		prove related_def: *T(is_tuple(X, X, T) -> T in C){
			given |T|;
			implies tuple_T;
			prove T_in_C: ^I^J(I in A & J in A & is_tuple(I, J, T)){
				choose X, X;
				return X_in_A, X_in_A, tuple_T;
			}
			return expand(cross_product_C)(T)(T_in_C);
		}
		return #related(X, X, C)(related_def);
	}
	C_reflexive = #reflexive(A, C)(C_reflexive);

	//A lemma for symmetry and transitivity
	prove C_lemma: *X*Y(related(X, Y, C) <-> X in A & Y in A){
		given |X, Y|;

		prove lemma0: related(X, Y, C) -> X in A & Y in A{
			implies X_related_Y;
			tuple_T = tuple(X, Y)|T|;
			T_in_C = expand(X_related_Y)(T)(tuple_T);
			X_OTHER_in_A, Y_OTHER_in_A, other_tuple_T = expand(cross_product_C)(T)(T_in_C)|X_OTHER, Y_OTHER|;
			X_eq, Y_eq = tuple_equal(X, Y, X_OTHER, Y_OTHER, T)(tuple_T, other_tuple_T);
			X_in_A = replace[<V: V in A>](X, X_OTHER)(X_eq)(X_OTHER_in_A);
			Y_in_A = replace[<V: V in A>](Y, Y_OTHER)(Y_eq)(Y_OTHER_in_A);
			return X_in_A, Y_in_A;
		}

		prove lemma1: X in A & Y in A -> related(X, Y, C){
			implies X_in_A, Y_in_A;
			prove related_def: *T(is_tuple(X, Y, T) -> T in C){
				given |T|;
				implies tuple_T;
				prove T_in_C: ^X^Y(X in A & Y in A & is_tuple(X, Y, T)){
					choose X, Y;
					return X_in_A, Y_in_A, tuple_T;
				}
				return expand(cross_product_C)(T)(T_in_C);
			}
			return #related(X, Y, C)(related_def);
		}

		return iff(lemma0, lemma1);
	}

	prove C_symmetric: *X*Y(related(X, Y, C) -> related(Y, X, C)){
		given |X, Y|;
		implies X_related_Y;
		X_in_A, Y_in_A = C_lemma(X, Y)(X_related_Y);
		return C_lemma(Y, X)(Y_in_A, X_in_A);
	}
	C_symmetric = #symmetric(C)(C_symmetric);

	prove C_transitive: *X*Y*Z(related(X, Y, C) & related(Y, Z, C) -> related(X, Z, C)){
		given |X, Y, Z|;
		implies X_related_Y, Y_related_Z;
		X_in_A, Y_in_A = C_lemma(X, Y)(X_related_Y);
		Y_in_A, Z_in_A = C_lemma(Y, Z)(Y_related_Z);
		return C_lemma(X, Z)(X_in_A, Z_in_A);
	}
	C_transitive = #transitive(C)(C_transitive);

	C_equiv_relation = #equiv_relation(A, C)(C_between_A, C_reflexive, C_symmetric, C_transitive);
	C_in_F = specified_F(C)(C_in_P, C_equiv_relation, R_subset_C);
	prove F_not_empty: ^C(C in F){
		choose C;
		return C_in_F;
	}
	F_not_empty = #not_empty(F)(F_not_empty);
	intersection_S = intersection(F)(F_not_empty)|S|;
	choose S;

	//A lemma for symmetry and transitivity of S
	prove S_lemma: *X*Y(related(X, Y, S) <-> *J(J in F -> related(X, Y, J))){
		given |X, Y|;
		prove lemma0: related(X, Y, S) -> *J(J in F -> related(X, Y, J)){
			implies X_related_Y;
			given |J|;
			implies J_in_F;
			prove related_J: *T(is_tuple(X, Y, T) -> T in J){
				given |T|;
				implies tuple_T;
				T_in_S = expand(X_related_Y)(T)(tuple_T);
				return expand(intersection_S)(T)(T_in_S)(J)(J_in_F);
			}
			return #related(X, Y, J)(related_J);
		}

		prove lemma1: *J(J in F -> related(X, Y, J)) -> related(X, Y, S){
			implies condition;
			prove related_S: *T(is_tuple(X, Y, T) -> T in S){
				given |T|;
				implies tuple_T;
				prove in_all: *J(J in F -> T in J){
					given |J|;
					implies J_in_F;
					return expand(condition(J)(J_in_F))(T)(tuple_T);
				}
				return expand(intersection_S)(T)(in_all);
			}
			return #related(X, Y, S)(related_S);
		}
		return iff(lemma0, lemma1);
	}

	prove S_reflexive: *X(X in A -> related(X, X, S)){
		given |X|;
		implies X_in_A;
		prove related_in_all: *J(J in F -> related(X, X, J)){
			given |J|;
			implies J_in_F;
			J_in_P, J_equiv, R_subset_J = specified_F(J)(J_in_F);
			J_between, J_reflexive, J_symmetric, J_transitive = expand(J_equiv);
			return expand(J_reflexive)(X)(X_in_A);
		}
		return S_lemma(X, X)(related_in_all);
	}
	S_reflexive = #reflexive(A, S)(S_reflexive);

	prove S_symmetric: *X*Y(related(X, Y, S) -> related(Y, X, S)){
		given |X, Y|;
		implies X_Y_related_S;
		related_in_J = S_lemma(X, Y)(X_Y_related_S);
		prove related_in_all: *J(J in F -> related(Y, X, J)){
			given |J|;
			implies J_in_F;
			X_Y_related_J = related_in_J(J)(J_in_F);
			J_in_P, J_equiv, R_subset_J = specified_F(J)(J_in_F);
			J_between, J_reflexive, J_symmetric, J_transitive = expand(J_equiv);
			return expand(J_symmetric)(X, Y)(X_Y_related_J);
		}
		return S_lemma(Y, X)(related_in_all);
	}
	S_symmetric = #symmetric(S)(S_symmetric);

	prove S_transitive: *X*Y*Z(related(X, Y, S) & related(Y, Z, S) -> related(X, Z, S)){
		given |X, Y, Z|;
		implies related_X_Y, related_Y_Z;
		J_related_X_Y = S_lemma(X, Y)(related_X_Y);
		J_related_Y_Z = S_lemma(Y, Z)(related_Y_Z);
		prove related_in_all: *J(J in F -> related(X, Z, J)){
			given |J|;
			implies J_in_F;
			X_Y_related = J_related_X_Y(J)(J_in_F);
			Y_Z_related = J_related_Y_Z(J)(J_in_F);
			J_in_P, J_equiv, R_subset_J = specified_F(J)(J_in_F);
			J_between, J_reflexive, J_symmetric, J_transitive = expand(J_equiv);
			return expand(J_transitive)(X, Y, Z)(X_Y_related, Y_Z_related);
		}
		return S_lemma(X, Z)(related_in_all);
	}
	S_transitive = #transitive(S)(S_transitive);

	prove S_between: *C(is_cross_product(A, A, C) -> S <= C){
		given |D|;
		implies cross;
		C_eq_D = cross_product_unique(A, A, C, D)(cross_product_C, cross);
		D_in_F = replace[<Q: Q in F>](C, D)(C_eq_D)(C_in_F);
		prove subset_def: *X(X in S -> X in D){
			given |X|;
			implies X_in_S;
			return expand(intersection_S)(X)(X_in_S)(D)(D_in_F);
		}
		return #[<=](S, D)(subset_def);
	}
	S_between = #relation_between(A, A, S)(S_between);

	S_equiv = #equiv_relation(A, S)(S_between, S_reflexive, S_symmetric, S_transitive);
	prove R_subset_all: *J(J in F -> R <= J){
		given |J|;
		implies J_in_F;
		J_in_P, J_equiv, result = specified_F(J)(J_in_F);
		return result;
	}
	R_subset_S = intersection_subset(R, F, S)(intersection_S, R_subset_all);
	
	prove S_min: *T(equiv_relation(A, T) & R <= T -> S <= T){
		given |T|;
		implies T_equiv, R_subset_T;
		T_between, T_reflexive, T_symmetric, T_transitive = expand(T_equiv);
		T_subset_C = expand(T_between)(C)(cross_product_C);
		T_in_P = expand(power_set_P)(T)(T_subset_C);
		T_in_F = specified_F(T)(T_in_P, T_equiv, R_subset_T);
		prove S_subset_T: *X(X in S -> X in T){
			given |X|;
			implies X_in_S;
			return expand(intersection_S)(X)(X_in_S)(T)(T_in_F);
		}
		return #[<=](S, T)(S_subset_T);
	}

	//Well this was longer than expected
	return S_equiv, R_subset_S, S_min;
}

