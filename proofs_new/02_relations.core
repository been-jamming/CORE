define related(A, B, R): *T(is_tuple(A, B, T) -> T in R);

define reflexive(A, R): *X(X in A -> related(X, X, R));

define symmetric(R): *X*Y(related(X, Y, R) -> related(Y, X, R));

define transitive(R): *X*Y*Z(related(X, Y, R) & related(Y, Z, R) -> related(X, Z, R));

define relation_between(A, B, R): *C(is_cross_product(A, B, C) -> R <= C);

define equiv_relation(A, R): relation_between(A, A, R) & reflexive(A, R) & symmetric(R) & transitive(R);

define equiv_class(A, R, C): ^P(P in A & *X(X in C <-> related(P, X, R)));

prove relation_existence_lemma[P(2)]: *A*B^R*X*Y(related(X, Y, R) <-> X in A & Y in B & P(X, Y)){
	given |A, B|;
	cross_product_T = cross_product(A, B)|T|;
	specified_R = specify[<Q: *X*Y(is_tuple(X, Y, Q) -> P(X, Y))>](T)|R|;
	choose R;
	given |X, Y|;
	prove lemma0: related(X, Y, R) -> X in A & Y in B & P(X, Y){
		implies X_related_Y;
		tuple_Q = tuple(X, Y)|Q|;
		Q_in_R = expand(X_related_Y)(Q)(tuple_Q);
		Q_in_T, condition = specified_R(Q)(Q_in_R);
		P_X_Y = condition(X, Y)(tuple_Q);
		X_OTHER_in_A, Y_OTHER_in_B, other_tuple_Q = expand(cross_product_T)(Q)(Q_in_T)|X_OTHER, Y_OTHER|;
		X_eq, Y_eq = tuple_equal(X, Y, X_OTHER, Y_OTHER, Q)(tuple_Q, other_tuple_Q);
		X_in_A = replace[<K: K in A>](X, X_OTHER)(X_eq)(X_OTHER_in_A);
		Y_in_B = replace[<K: K in B>](Y, Y_OTHER)(Y_eq)(Y_OTHER_in_B);
		return X_in_A, Y_in_B, P_X_Y;
	}

	prove lemma1: X in A & Y in B & P(X, Y) -> related(X, Y, R){
		implies X_in_A, Y_in_B, P_X_Y;
		prove X_related_Y: *K(is_tuple(X, Y, K) -> K in R){
			given |K|;
			implies tuple_K;

			prove K_in_T: ^X^Y(X in A & Y in B & is_tuple(X, Y, K)){
				choose X, Y;
				return X_in_A, Y_in_B, tuple_K;
			}
			K_in_T = expand(cross_product_T)(K)(K_in_T);

			prove condition: *X_OTHER*Y_OTHER(is_tuple(X_OTHER, Y_OTHER, K) -> P(X_OTHER, Y_OTHER)){
				given |X_OTHER, Y_OTHER|;
				implies other_tuple_K;
				X_eq, Y_eq = tuple_equal(X, Y, X_OTHER, Y_OTHER, K)(tuple_K, other_tuple_K);
				result = replace[<V: P(V, Y)>](X, X_OTHER)(X_eq)(P_X_Y);
				return replace[<V: P(X_OTHER, V)>](Y, Y_OTHER)(Y_eq)(result);
			}

			return specified_R(K)(K_in_T, condition);
		}
		return #related(X, Y, R)(X_related_Y);
	}

	return iff(lemma0, lemma1);
}

prove equiv_relation_sup: *A*R(relation_between(A, A, R) -> ^S(equiv_relation(A, S) & R <= S & *T(equiv_relation(A, T) & R <= T -> S <= T))){
	given |A, R|;
	implies between;

	cross_product_C = cross_product(A, A)|C|;
	R_subset_C = expand(between)(C)(cross_product_C);
	power_set_P = power_set(C)|P|;
	C_in_P = expand(power_set_P)(C)(subset_reflexive(C));
	specified_F = specify[<V: equiv_relation(A, V) & R <= V>](P)|F|;

	//I need to prove that this family of equivalence relations is not empty
	//Luckily, the relation where everything is related is an equivalence relation
	prove C_between_A: *D(is_cross_product(A, A, D) -> C <= D){
		given |D|;
		implies cross_product_D;
		C_eq_D = cross_product_unique(A, A, C, D)(cross_product_C, cross_product_D);
		return replace[<V: C <= V>](C, D)(C_eq_D)(subset_reflexive(C));
	}
	C_between_A = #relation_between(A, A, C)(C_between_A);

	prove C_reflexive: *X(X in A -> related(X, X, C)){
		given |X|;
		implies X_in_A;
		prove related_def: *T(is_tuple(X, X, T) -> T in C){
			given |T|;
			implies tuple_T;
			prove T_in_C: ^I^J(I in A & J in A & is_tuple(I, J, T)){
				choose X, X;
				return X_in_A, X_in_A, tuple_T;
			}
			return expand(cross_product_C)(T)(T_in_C);
		}
		return #related(X, X, C)(related_def);
	}
	C_reflexive = #reflexive(A, C)(C_reflexive);

	//A lemma for symmetry and transitivity
	prove C_lemma: *X*Y(related(X, Y, C) <-> X in A & Y in A){
		given |X, Y|;

		prove lemma0: related(X, Y, C) -> X in A & Y in A{
			implies X_related_Y;
			tuple_T = tuple(X, Y)|T|;
			T_in_C = expand(X_related_Y)(T)(tuple_T);
			X_OTHER_in_A, Y_OTHER_in_A, other_tuple_T = expand(cross_product_C)(T)(T_in_C)|X_OTHER, Y_OTHER|;
			X_eq, Y_eq = tuple_equal(X, Y, X_OTHER, Y_OTHER, T)(tuple_T, other_tuple_T);
			X_in_A = replace[<V: V in A>](X, X_OTHER)(X_eq)(X_OTHER_in_A);
			Y_in_A = replace[<V: V in A>](Y, Y_OTHER)(Y_eq)(Y_OTHER_in_A);
			return X_in_A, Y_in_A;
		}

		prove lemma1: X in A & Y in A -> related(X, Y, C){
			implies X_in_A, Y_in_A;
			prove related_def: *T(is_tuple(X, Y, T) -> T in C){
				given |T|;
				implies tuple_T;
				prove T_in_C: ^X^Y(X in A & Y in A & is_tuple(X, Y, T)){
					choose X, Y;
					return X_in_A, Y_in_A, tuple_T;
				}
				return expand(cross_product_C)(T)(T_in_C);
			}
			return #related(X, Y, C)(related_def);
		}

		return iff(lemma0, lemma1);
	}

	prove C_symmetric: *X*Y(related(X, Y, C) -> related(Y, X, C)){
		given |X, Y|;
		implies X_related_Y;
		X_in_A, Y_in_A = C_lemma(X, Y)(X_related_Y);
		return C_lemma(Y, X)(Y_in_A, X_in_A);
	}
	C_symmetric = #symmetric(C)(C_symmetric);

	prove C_transitive: *X*Y*Z(related(X, Y, C) & related(Y, Z, C) -> related(X, Z, C)){
		given |X, Y, Z|;
		implies X_related_Y, Y_related_Z;
		X_in_A, Y_in_A = C_lemma(X, Y)(X_related_Y);
		Y_in_A, Z_in_A = C_lemma(Y, Z)(Y_related_Z);
		return C_lemma(X, Z)(X_in_A, Z_in_A);
	}
	C_transitive = #transitive(C)(C_transitive);

	C_equiv_relation = #equiv_relation(A, C)(C_between_A, C_reflexive, C_symmetric, C_transitive);
	C_in_F = specified_F(C)(C_in_P, C_equiv_relation, R_subset_C);
	prove F_not_empty: ^C(C in F){
		choose C;
		return C_in_F;
	}
	F_not_empty = #not_empty(F)(F_not_empty);
	intersection_S = intersection(F)(F_not_empty)|S|;
	choose S;

	//A lemma for symmetry and transitivity of S
	prove S_lemma: *X*Y(related(X, Y, S) <-> *J(J in F -> related(X, Y, J))){
		given |X, Y|;
		prove lemma0: related(X, Y, S) -> *J(J in F -> related(X, Y, J)){
			implies X_related_Y;
			given |J|;
			implies J_in_F;
			prove related_J: *T(is_tuple(X, Y, T) -> T in J){
				given |T|;
				implies tuple_T;
				T_in_S = expand(X_related_Y)(T)(tuple_T);
				return expand(intersection_S)(T)(T_in_S)(J)(J_in_F);
			}
			return #related(X, Y, J)(related_J);
		}

		prove lemma1: *J(J in F -> related(X, Y, J)) -> related(X, Y, S){
			implies condition;
			prove related_S: *T(is_tuple(X, Y, T) -> T in S){
				given |T|;
				implies tuple_T;
				prove in_all: *J(J in F -> T in J){
					given |J|;
					implies J_in_F;
					return expand(condition(J)(J_in_F))(T)(tuple_T);
				}
				return expand(intersection_S)(T)(in_all);
			}
			return #related(X, Y, S)(related_S);
		}
		return iff(lemma0, lemma1);
	}

	prove S_reflexive: *X(X in A -> related(X, X, S)){
		given |X|;
		implies X_in_A;
		prove related_in_all: *J(J in F -> related(X, X, J)){
			given |J|;
			implies J_in_F;
			J_in_P, J_equiv, R_subset_J = specified_F(J)(J_in_F);
			J_between, J_reflexive, J_symmetric, J_transitive = expand(J_equiv);
			return expand(J_reflexive)(X)(X_in_A);
		}
		return S_lemma(X, X)(related_in_all);
	}
	S_reflexive = #reflexive(A, S)(S_reflexive);

	prove S_symmetric: *X*Y(related(X, Y, S) -> related(Y, X, S)){
		given |X, Y|;
		implies X_Y_related_S;
		related_in_J = S_lemma(X, Y)(X_Y_related_S);
		prove related_in_all: *J(J in F -> related(Y, X, J)){
			given |J|;
			implies J_in_F;
			X_Y_related_J = related_in_J(J)(J_in_F);
			J_in_P, J_equiv, R_subset_J = specified_F(J)(J_in_F);
			J_between, J_reflexive, J_symmetric, J_transitive = expand(J_equiv);
			return expand(J_symmetric)(X, Y)(X_Y_related_J);
		}
		return S_lemma(Y, X)(related_in_all);
	}
	S_symmetric = #symmetric(S)(S_symmetric);

	prove S_transitive: *X*Y*Z(related(X, Y, S) & related(Y, Z, S) -> related(X, Z, S)){
		given |X, Y, Z|;
		implies related_X_Y, related_Y_Z;
		J_related_X_Y = S_lemma(X, Y)(related_X_Y);
		J_related_Y_Z = S_lemma(Y, Z)(related_Y_Z);
		prove related_in_all: *J(J in F -> related(X, Z, J)){
			given |J|;
			implies J_in_F;
			X_Y_related = J_related_X_Y(J)(J_in_F);
			Y_Z_related = J_related_Y_Z(J)(J_in_F);
			J_in_P, J_equiv, R_subset_J = specified_F(J)(J_in_F);
			J_between, J_reflexive, J_symmetric, J_transitive = expand(J_equiv);
			return expand(J_transitive)(X, Y, Z)(X_Y_related, Y_Z_related);
		}
		return S_lemma(X, Z)(related_in_all);
	}
	S_transitive = #transitive(S)(S_transitive);

	prove S_between: *C(is_cross_product(A, A, C) -> S <= C){
		given |D|;
		implies cross;
		C_eq_D = cross_product_unique(A, A, C, D)(cross_product_C, cross);
		D_in_F = replace[<Q: Q in F>](C, D)(C_eq_D)(C_in_F);
		prove subset_def: *X(X in S -> X in D){
			given |X|;
			implies X_in_S;
			return expand(intersection_S)(X)(X_in_S)(D)(D_in_F);
		}
		return #[<=](S, D)(subset_def);
	}
	S_between = #relation_between(A, A, S)(S_between);

	S_equiv = #equiv_relation(A, S)(S_between, S_reflexive, S_symmetric, S_transitive);
	prove R_subset_all: *J(J in F -> R <= J){
		given |J|;
		implies J_in_F;
		J_in_P, J_equiv, result = specified_F(J)(J_in_F);
		return result;
	}
	R_subset_S = intersection_subset(R, F, S)(intersection_S, R_subset_all);
	
	prove S_min: *T(equiv_relation(A, T) & R <= T -> S <= T){
		given |T|;
		implies T_equiv, R_subset_T;
		T_between, T_reflexive, T_symmetric, T_transitive = expand(T_equiv);
		T_subset_C = expand(T_between)(C)(cross_product_C);
		T_in_P = expand(power_set_P)(T)(T_subset_C);
		T_in_F = specified_F(T)(T_in_P, T_equiv, R_subset_T);
		prove S_subset_T: *X(X in S -> X in T){
			given |X|;
			implies X_in_S;
			return expand(intersection_S)(X)(X_in_S)(T)(T_in_F);
		}
		return #[<=](S, T)(S_subset_T);
	}

	//Well this was longer than expected
	return S_equiv, R_subset_S, S_min;
}

