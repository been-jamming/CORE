INDUCTIVE_SET_inductive = axiom_infinity|INDUCTIVE_SET|;
EMPTY_in_INDUCTIVE_SET, INDUCTIVE_SET_closure = expand(INDUCTIVE_SET_inductive);
EMPTY_in_INDUCTIVE_SET, empty_definition = EMPTY_in_INDUCTIVE_SET|EMPTY|;
empty_definition = expand(empty_definition);

prove naturals: ^N*X(X in N <-> *I(is_inductive_set(I) -> X in I)){
	specified_N = specify[<Q: *I(is_inductive_set(I) -> Q in I)>](INDUCTIVE_SET)|N|;
	choose N;
	given |X|;
	prove lemma0: X in N -> *I(is_inductive_set(I) -> X in I){
		implies X_in_N;
		X_in_INDUCTIVE_SET, result = specified_N(X)(X_in_N);
		return result;
	}

	prove lemma1: *I(is_inductive_set(I) -> X in I) -> X in N{
		implies condition;
		X_in_INDUCTIVE_SET = condition(INDUCTIVE_SET)(INDUCTIVE_SET_inductive);
		return specified_N(X)(X_in_INDUCTIVE_SET, condition);
	}
	return iff(lemma0, lemma1);
}

naturals_definition = naturals|NATURALS|;

prove naturals_inductive_set: ^E(E in NATURALS & is_empty(E)) & *Y*Z(Y in NATURALS & successor(Y, Z) -> Z in NATURALS){
	prove lemma0: ^E(E in NATURALS & is_empty(E)){
		choose EMPTY;
		EMPTY_empty = #is_empty(EMPTY)(empty_definition);
		prove EMPTY_in_NATURALS: *I(is_inductive_set(I) -> EMPTY in I){
			given |I|;
			implies inductive_I;
			empty_exists, closure = expand(inductive_I);
			empty_in_I, empty_is_empty = empty_exists|E|;
			empty_equal = empty_unique(E, EMPTY)(empty_is_empty, EMPTY_empty);
			return replace[<Q: Q in I>](E, EMPTY)(empty_equal)(empty_in_I);
		}
		return naturals_definition(EMPTY)(EMPTY_in_NATURALS), EMPTY_empty;
	}

	prove lemma1: *Y*Z(Y in NATURALS & successor(Y, Z) -> Z in NATURALS){
		given |Y, Z|;
		implies Y_in_NATURALS, successor_Z;
		prove Z_in_NATURALS: *I(is_inductive_set(I) -> Z in I){
			given |I|;
			implies inductive_I;
			empty_in_I, closure_I = expand(inductive_I);
			Y_in_I = naturals_definition(Y)(Y_in_NATURALS)(I)(inductive_I);
			return closure_I(Y, Z)(Y_in_I, successor_Z);
		}
		return naturals_definition(Z)(Z_in_NATURALS);
	}
	return lemma0, lemma1;
}
naturals_inductive_set = #is_inductive_set(NATURALS)(naturals_inductive_set);

zero_definition = copy_set(EMPTY)|ZERO|;
prove ZERO_in_NATURALS: *I(is_inductive_set(I) -> ZERO in I){
	given |I|;
	implies inductive_I;
	empty_in_I, closure_I = expand(inductive_I);
	E_in_I, empty_E = empty_in_I|E|;
	empty_equal = empty_unique(E, EMPTY)(empty_E, #is_empty(EMPTY)(empty_definition));
	EMPTY_in_I = replace[<Q: Q in I>](E, EMPTY)(empty_equal)(E_in_I);
	return replace[<Q: Q in I>](EMPTY, ZERO)(zero_definition)(EMPTY_in_I);
}
ZERO_in_NATURALS = naturals_definition(ZERO)(ZERO_in_NATURALS);

//The relation < on the naturals is just set membership given our successor operation
relation A < B: A in B;

prove zero_minimal: *X(~X < ZERO){
	given |X|;
	not X_lt_ZERO;
	X_in_ZERO = expand(X_lt_ZERO);
	X_in_EMPTY = replace[<Q: X in Q>](EMPTY, ZERO)(zero_definition)(X_in_ZERO);
	return empty_definition(X)(X_in_EMPTY);
}

prove zero_minimum: *X(ZERO <= X){
	given |X|;
	prove subset_def: *Y(Y in ZERO -> Y in X){
		given |Y|;
		implies Y_in_ZERO;
		Y_in_EMPTY = replace[<Q: Y in Q>](EMPTY, ZERO)(zero_definition)(Y_in_ZERO);
		return absurdity[goal](empty_definition(Y)(Y_in_EMPTY));
	}
	return #[<=](ZERO, X)(subset_def);
}

prove naturals_successor_closure: *X*Y(X in NATURALS & successor(X, Y) -> Y in NATURALS){
	empty_in_naturals, result = expand(naturals_inductive_set);
	return result;
}

prove naturals_induction[P(1)]: P(ZERO) & *X*Y(P(X) & successor(X, Y) -> P(Y)) -> *N(N in NATURALS -> P(N)){
	implies P_ZERO, closure_P;
	P_empty = replace[<Q: P(Q)>](EMPTY, ZERO)(zero_definition)(P_ZERO);
	specified_R = specify[<Q: P(Q)>](NATURALS)|R|;
	prove empty_in_R: ^E(E in R & is_empty(E)){
		choose EMPTY;
		EMPTY_in_NATURALS = replace[<Q: Q in NATURALS>](EMPTY, ZERO)(zero_definition)(ZERO_in_NATURALS);
		return specified_R(EMPTY)(EMPTY_in_NATURALS, P_empty), #is_empty(EMPTY)(empty_definition);
	}
	prove closure_R: *X*Y(X in R & successor(X, Y) -> Y in R){
		given |X, Y|;
		implies X_in_R, successor_Y;
		X_in_NATURALS, P_X = specified_R(X)(X_in_R);
		Y_in_NATURALS = naturals_successor_closure(X, Y)(X_in_NATURALS, successor_Y);
		P_Y = closure_P(X, Y)(P_X, successor_Y);
		return specified_R(Y)(Y_in_NATURALS, P_Y);
	}
	R_inductive = #is_inductive_set(R)(empty_in_R, closure_R);
	given |N|;
	implies N_in_NATURALS;
	N_in_R = naturals_definition(N)(N_in_NATURALS)(R)(R_inductive);
	N_in_NATURALS, result = specified_R(N)(N_in_R);
	return result;
}

prove naturals_strong_induction[P(1)]: *X(X in NATURALS & *Y(Y < X -> P(Y)) -> P(X)) -> *N(N in NATURALS -> P(N)){
	//The statement we will actually induct on
	define Q(X): X in NATURALS & *Y(Y < X -> P(Y));
	//The strong inductive hypothesis
	implies hypothesis;

	prove Q_ZERO: *Y(Y < ZERO -> P(Y)){
		given |Y|;
		implies Y_lt_ZERO;
		return absurdity[goal](zero_minimal(Y)(Y_lt_ZERO));
	}
	Q_ZERO = #Q(ZERO)(ZERO_in_NATURALS, Q_ZERO);
	
	prove Q_successor: *Y*Z(Q(Y) & successor(Y, Z) -> Q(Z)){
		given |Y, Z|;
		implies Q_Y, successor_Z;
		Y_in_NATURALS, closure_Y = expand(Q_Y);
		Z_in_NATURALS = naturals_successor_closure(Y, Z)(Y_in_NATURALS, successor_Z);
		prove Q_Z: *K(K < Z -> P(K)){
			given |K|;
			implies K_lt_Z; K_in_Z = expand(K_lt_Z);
			return branch(expand(successor_Z)(K)(K_in_Z), K_in_Y, K_eq_Y){
				K_lt_Y = #[<](K, Y)(K_in_Y);
				return closure_Y(K)(K_lt_Y);
			} or {
				Q_K = replace[<B: Q(B)>](K, Y)(K_eq_Y)(Q_Y);
				return hypothesis(K)(expand(Q_K));
			};
		}
		return #Q(Z)(Z_in_NATURALS, Q_Z);
	}

	Q_all = naturals_induction[<B: Q(B)>](Q_ZERO, Q_successor);
	//Almost there
	given |N|;
	implies N_in_NATURALS;
	Q_N = Q_all(N)(N_in_NATURALS);
	return hypothesis(N)(expand(Q_N));
}

//This proves that the elements of a natural number are natural numbers
prove naturals_membership: *N*M(N in NATURALS & M in N -> M in NATURALS){
	//The statement to induct on
	define Q(X): X in NATURALS & *M(M in X -> M in NATURALS);

	prove Q_ZERO: *M(M in ZERO -> M in NATURALS){
		given |M|;
		implies M_in_ZERO;
		M_in_EMPTY = replace[<X: M in X>](EMPTY, ZERO)(zero_definition)(M_in_ZERO);
		return absurdity[goal](empty_definition(M)(M_in_EMPTY));
	}

	Q_ZERO = #Q(ZERO)(ZERO_in_NATURALS, Q_ZERO);

	prove Q_closure: *M*N(Q(M) & successor(M, N) -> Q(N)){
		given |M, N|;
		implies Q_M, successor_N;
		M_in_NATURALS, M_closed = expand(Q_M);
		N_in_NATURALS = naturals_successor_closure(M, N)(M_in_NATURALS, successor_N);
		prove Q_N: *K(K in N -> K in NATURALS){
			given |K|;
			implies K_in_N;
			return branch(expand(successor_N)(K)(K_in_N), K_in_M, K_eq_M){
				return M_closed(K)(K_in_M);
			} or {
				return replace[<S: S in NATURALS>](K, M)(K_eq_M)(M_in_NATURALS);
			};
		}
		return #Q(N)(N_in_NATURALS, Q_N);
	}

	result = naturals_induction[<S: Q(S)>](Q_ZERO, Q_closure);

	given |N, M|;
	implies N_in_NATURALS, M_in_N;
	Q_N = result(N)(N_in_NATURALS);
	N_in_NATURALS, N_closure = expand(Q_N);
	return N_closure(M)(M_in_N);
}

//We need to prove that any natural is either larger than 0 or equals 0
prove naturals_zero_dichotomy: *N(N in NATURALS -> ZERO < N | ZERO = N){
	//The statement to induct on
	define Q(X): ZERO < X | ZERO = X;

	Q_ZERO = #Q(ZERO)(or(<: ZERO < ZERO>, equal_reflexive(ZERO)));

	prove Q_closure: *N*M(Q(N) & successor(N, M) -> Q(M)){
		given |N, M|;
		implies Q_N, successor_M;
		ZERO_in_M = branch(expand(Q_N), ZERO_lt_N, ZERO_eq_N){
			return expand(successor_M)(ZERO)(or(expand(ZERO_lt_N), <: ZERO = N>));
		} or {
			return expand(successor_M)(ZERO)(or(<: ZERO in N>, ZERO_eq_N));
		};
		return #Q(M)(or(#[<](ZERO, M)(ZERO_in_M), <: ZERO = M>));
	}

	result = naturals_induction[<K: Q(K)>](Q_ZERO, Q_closure);
	given |N|;
	implies N_in_NATURALS;
	Q_N = result(N)(N_in_NATURALS);
	return expand(Q_N);
}

prove naturals_subset_lemma: *N*M*K(N in NATURALS & K in NATURALS & successor(N, M) & N < K -> M < K | M = K){
	define Q(X): X in NATURALS & *N*M(N in NATURALS & successor(N, M) & N < X -> M < X | M = X);

	prove Q_ZERO: *N*M(N in NATURALS & successor(N, M) & N < ZERO -> M < ZERO | M = ZERO){
		given |N, M|;
		implies N_in_NATURALS, successor_M, N_lt_ZERO;
		contradiction = zero_minimal(N)(N_lt_ZERO);
		return absurdity[goal](contradiction);
	}

	Q_ZERO = #Q(ZERO)(ZERO_in_NATURALS, Q_ZERO);

	prove Q_closure: *N*M(Q(N) & successor(N, M) -> Q(M)){
		given |N, M|;
		implies Q_N, successor_M;
		N_in_NATURALS, N_condition = expand(Q_N);
		M_in_NATURALS = naturals_successor_closure(N, M)(N_in_NATURALS, successor_M);
		prove M_condition: *J*K(J in NATURALS & successor(J, K) & J < M -> K < M | K = M){
			given |J, K|;
			implies J_in_NATURALS, successor_K, J_lt_M;
			J_in_M = expand(J_lt_M);
			return branch(expand(successor_M)(J)(J_in_M), J_in_N, J_eq_N){
				J_lt_N = #[<](J, N)(J_in_N);
				K_lt_N_or_K_eq_N = N_condition(J, K)(J_in_NATURALS, successor_K, J_lt_N);
				return branch(K_lt_N_or_K_eq_N, K_lt_N, K_eq_N){
					K_in_N = expand(K_lt_N);
					K_in_M = expand(successor_M)(K)(or(K_in_N, <: K = N>));
					K_lt_M = #[<](K, M)(K_in_M);
					return or(K_lt_M, <: K = M>);
				} or {
					K_in_M = expand(successor_M)(K)(or(<: K in N>, K_eq_N));
					K_lt_M = #[<](K, M)(K_in_M);
					return or(K_lt_M, <: K = M>);
				};
			} or {
				successor_M2 = replace[<X: successor(X, M)>](J, N)(J_eq_N)(successor_M);
				K_eq_M = successor_unique(J, K, M)(successor_K, successor_M2);
				return or(<: K < M>, K_eq_M);
			};
		}
		return #Q(M)(M_in_NATURALS, M_condition);
	}

	result = naturals_induction[<X: Q(X)>](Q_ZERO, Q_closure);
	given |N, M, K|;
	implies N_in_NATURALS, K_in_NATURALS, successor_M, N_lt_K;
	Q_K = result(K)(K_in_NATURALS);
	K_in_NATURALS, Q_K = expand(Q_K);
	return Q_K(N, M)(N_in_NATURALS, successor_M, N_lt_K);
}

//Next we prove that every non-zero natural has a predecessor
prove naturals_predecessor: *N(N in NATURALS -> N = ZERO | ^M(M in NATURALS & successor(M, N))){
	//The statement to induct on
	define Q(X): X in NATURALS & (X = ZERO | ^M(M in NATURALS & successor(M, X)));

	Q_ZERO = #Q(ZERO)(ZERO_in_NATURALS, or(equal_reflexive(ZERO), <: ^M(M in NATURALS & successor(M, ZERO))>));

	prove Q_closure: *N*M(Q(N) & successor(N, M) -> Q(M)){
		given |N, M|;
		implies Q_N, successor_M;
		N_in_NATURALS, either = expand(Q_N);
		M_in_NATURALS = naturals_successor_closure(N, M)(N_in_NATURALS, successor_M);
		prove exists: ^N(N in NATURALS & successor(N, M)){
			choose N;
			return N_in_NATURALS, successor_M;
		}
		return #Q(M)(M_in_NATURALS, or(<: M = ZERO>, exists));
	}

	result = naturals_induction[<X: Q(X)>](Q_ZERO, Q_closure);

	given |N|;
	implies N_in_NATURALS;
	Q_N = result(N)(N_in_NATURALS);
	N_in_NATURALS, rest = expand(Q_N);
	return rest;
}

//This is actually true even for sets which aren't naturals
prove predecessor_unique: *A*B*C(successor(A, C) & successor(B, C) -> A = B){
	given |A, B, C|;
	implies predecessor_A, predecessor_B;
	A_in_C = expand(predecessor_A)(A)(or(<: A in A>, equal_reflexive(A)));
	return branch(expand(predecessor_B)(A)(A_in_C), A_in_B, A_eq_B){
		B_in_C = expand(predecessor_B)(B)(or(<: B in B>, equal_reflexive(B)));
		return branch(expand(predecessor_A)(B)(B_in_C), B_in_A, B_eq_A){
			return branch(no_recursive_membership(A, B), B_not_in_A, A_not_in_B){
				contradiction = B_not_in_A(B_in_A);
				return absurdity[goal](contradiction);
			} or {
				contradiction = A_not_in_B(A_in_B);
				return absurdity[goal](contradiction);
			};
		} or {
			return equal_symmetric(B, A)(B_eq_A);
		};
	} or {
		return A_eq_B;
	};
}

//We need to prove that if A + 1 <= B + 1, A <= B
prove predecessor_subset: *N*M*J*K(successor(J, N) & successor(K, M) & N <= M -> J <= K){
	given |N, M, J, K|;
	implies predecessor_J, predecessor_K, N_subset_M;
	prove J_subset_K: *X(X in J -> X in K){
		given |X|;
		implies X_in_J;
		X_in_N = expand(predecessor_J)(X)(or(X_in_J, <: X = J>));
		X_in_M = expand(N_subset_M)(X)(X_in_N);
		return branch(expand(predecessor_K)(X)(X_in_M), X_in_K, X_eq_K){
			return X_in_K;
		} or {
			
		};
	}
}

//We need to prove that if a natural N is a subset of a natural M, then either
//N < M or N = M
prove naturals_subset: *N*M(N in NATURALS & M in NATURALS & N <= M -> N < M | N = M){
	//The statement to induct on
	define Q(X): X in NATURALS & *M(M in NATURALS & X <= M -> X < M | X = M);

	prove Q_ZERO: *M(M in NATURALS & ZERO <= M -> ZERO < M | ZERO = M){
		given |M|;
		implies M_in_NATURALS, ZERO_subset_M;
		return naturals_zero_dichotomy(M)(M_in_NATURALS);
	}

	Q_ZERO = #Q(ZERO)(ZERO_in_NATURALS, Q_ZERO);

	prove Q_closed: *N*M(Q(N) & successor(N, M) -> Q(M)){
		given |N, M|;
		implies Q_N, successor_M;
		N_in_NATURALS, N_subset = expand(Q_N);
		M_in_NATURALS = naturals_successor_closure(N, M)(N_in_NATURALS, successor_M);
		prove M_subset: *Y(Y in NATURALS & M <= Y -> M < Y | M = Y){
			given |Y|;
			implies Y_in_NATURALS, M_subset_Y;
			Y_eq_ZERO_or_predecessor_exists = naturals_predecessor(Y)(Y_in_NATURALS);
			return branch(Y_eq_ZERO_or_predecessor_exists, Y_eq_ZERO, predecessor_exists){
				ZERO_subset_M = zero_minimum(M);
				M_subset_ZERO = replace[<X: M <= X>](Y, ZERO)(Y_eq_ZERO)(M_subset_Y);
				prove M_eq_ZERO: *X(X in M <-> X in ZERO){
					given |X|;
					return iff(expand(ZERO_subset_M)(X), expand(M_subset_ZERO)(X));
				}
				M_eq_ZERO = #[=](M, ZERO)(M_eq_ZERO);
				M_eq_Y = replace[<X: M = X>](Y, ZERO)(Y_eq_ZERO)(M_eq_ZERO);
				return or(<: M < Y>, M_eq_Y);
			} or {
				P_in_NATURALS, successor_Y = predecessor_exists|P|;
				print N_subset(P);
			};
		}
	}
}

//We need this lemma in order to prove the well ordering theorem on the naturals
prove naturals_dichotomy: *A*B(A in NATURALS & B in NATURALS -> A < B | B <= A){
	//The statement to induct on
	define Q(B): B in NATURALS & *A(A in NATURALS -> A < B | B <= A);

	prove Q_ZERO: *A(A in NATURALS -> A < ZERO | ZERO <= A){
		given |A|;
		implies A_in_NATURALS;
		return or(<: A < ZERO>, zero_minimum(A));
	}
	Q_ZERO = #Q(ZERO)(ZERO_in_NATURALS, Q_ZERO);

	prove Q_closed: *X*Y(Q(X) & successor(X, Y) -> Q(Y)){
		given |X, Y|;
		implies Q_X, successor_Y;
		X_in_NATURALS, X_closure = expand(Q_X);
		Y_in_NATURALS = naturals_successor_closure(X, Y)(X_in_NATURALS, successor_Y);
		prove Q_Y: *A(A in NATURALS -> A < Y | Y <= A){
			given |A|;
			implies A_in_NATURALS;
			return branch(X_closure(A)(A_in_NATURALS), A_lt_X, X_lteq_A){
				A_in_X = expand(A_lt_X);
				A_in_Y = expand(successor_Y)(A)(or(A_in_X, <: A = X>));
				return or(#[<](A, Y)(A_in_Y), <: Y <= A>);
			} or {
				
			};
		}
	}
}

prove naturals_well_ordering: *S(S <= NATURALS -> ^M(M in S & *N(N in S -> M <= N))){
	given |S|;
	implies S_subset_NATURALS;
	//The statement to induct on
	define Q(X): X in S -> ^M(M in S & *N(N in S -> M <= N));

	prove hypothesis: *X(X in NATURALS & *Y(Y < X -> Q(Y)) -> Q(X)){
		given |X|;
		implies X_in_NATURALS, closure;
		prove Q_X: X in S -> ^M(M in S & *N(N in S -> M <= N)){
			implies X_in_S;
			//Here, either there is J in S with J < X or there isn't
			//This is the first time I'm having to use the law of excluded middle. I wish I didn't have to
			return branch(excluded_middle[<: ^J(J in S & J < X)>], X_not_min, X_min){
				J_in_S, J_lt_X = X_not_min|J|;
				return expand(closure(J)(J_lt_X))(J_in_S);
			} or {
				prove is_min: *N(N in S -> X <= N){
					given |N|;
					implies N_in_S;
					N_not_lt_X = branch(excluded_middle[<: N < X>], N_lt_X, N_not_lt_X){
						return absurdity[<: ~N < X>](negate_exists[<J: J in S & J < X>](X_min)(N)(N_in_S, N_lt_X));
					} or {
						return N_not_lt_X;
					};
					print N_not_lt_X;
				}
			};
		}
	}
}

