<!DOCTYPE html><html><head><title>file</title></head><body><div class="header">CORE Source</div><div class="CORE_source"><code style="white-space: pre-wrap;"><b style="color: blue">define </b>is_natural_numbers(N): *X(X in N &lt-&gt *I(is_inductive_set(I) -&gt X in I));

<b style="color: blue">prove </b>natural_numbers_exist: ^N(is_natural_numbers(N)){
	is_inductive = axiom_infinity|INDUCTIVE_SET|;
	specified = axiom_specify[&ltX: *I(is_inductive_set(I) -&gt X in I)&gt](INDUCTIVE_SET)|N|;
	<b style="color: blue">choose </b>N;
	<b style="color: blue">prove </b>natural_numbers_def: *X(X in N &lt-&gt *I(is_inductive_set(I) -&gt X in I)){
		<b style="color: blue">given </b>|X|;
		<b style="color: blue">prove </b>lemma0: X in N -&gt *I(is_inductive_set(I) -&gt X in I){
			<b style="color: blue">implies </b>X_in_N;
			<b style="color: blue">extract </b>specified(X)(X_in_N): X_in_INDUCTIVE_SET, result;
			<b style="color: blue">return </b>result;
		}
		<b style="color: blue">prove </b>lemma1: *I(is_inductive_set(I) -&gt X in I) -&gt X in N{
			<b style="color: blue">implies </b>in_all_inductive;
			X_in_INDUCTIVE_SET = in_all_inductive(INDUCTIVE_SET)(is_inductive);
			<b style="color: blue">return </b>specified(X)(X_in_INDUCTIVE_SET, in_all_inductive);
		}
		<b style="color: blue">return </b>iff(lemma0, lemma1);
	}
	<b style="color: blue">return </b>#is_natural_numbers(N)(natural_numbers_def);
}

<b style="color: blue">prove </b>natural_numbers_unique: *N*M(is_natural_numbers(N) & is_natural_numbers(M) -&gt equal_sets(N, M)){
	<b style="color: blue">given </b>|N, M|;
	<b style="color: blue">implies </b>both_natural_numbers;
	<b style="color: blue">extract </b>both_natural_numbers: natural_numbers_N, natural_numbers_M;
	<b style="color: blue">return </b>definition_uniqueness_lemma[&ltX: *I(is_inductive_set(I) -&gt X in I)&gt](N, M)(expand(natural_numbers_N), expand(natural_numbers_M));
}

naturals_definition = expand(natural_numbers_exist|NATURALS|);

<b style="color: blue">prove </b>NATURALS_inductive: is_inductive_set(NATURALS){
	<b style="color: blue">prove </b>lemma0: ^E(E in NATURALS & is_empty(E)){
		<b style="color: blue">choose </b>EMPTY_SET;
		empty = #is_empty(EMPTY_SET)(empty_set_condition);
		<b style="color: blue">prove </b>lemma: *I(is_inductive_set(I) -&gt EMPTY_SET in I){
			<b style="color: blue">given </b>|I|;
			<b style="color: blue">implies </b>is_inductive;
			<b style="color: blue">extract </b>expand(is_inductive): empty_condition, closure;
			<b style="color: blue">extract </b>empty_condition|EMPTY_OTHER|: empty_in, is_empty_other;
			empty_equal = empty_set_unique(EMPTY_OTHER, EMPTY_SET)(is_empty_other, empty);
			<b style="color: blue">return </b>equality_consistency[&ltX: X in I&gt](EMPTY_OTHER, EMPTY_SET)(empty_equal)(empty_in);
		}
		<b style="color: blue">return </b>naturals_definition(EMPTY_SET)(lemma), empty;
	}
	<b style="color: blue">prove </b>lemma1: *Y*Z(Y in NATURALS & is_successor(Y, Z) -&gt Z in NATURALS){
		<b style="color: blue">given </b>|Y, Z|;
		<b style="color: blue">implies </b>both;
		<b style="color: blue">extract </b>both: Y_in_NATURALS, Z_successor;
		<b style="color: blue">prove </b>lemma: *I(is_inductive_set(I) -&gt Z in I){
			<b style="color: blue">given </b>|I|;
			<b style="color: blue">implies </b>is_inductive;
			<b style="color: blue">extract </b>expand(is_inductive): empty_condition, closure;
			Y_in_I = naturals_definition(Y)(Y_in_NATURALS)(I)(is_inductive);
			<b style="color: blue">return </b>closure(Y, Z)(Y_in_I, Z_successor);
		}
		<b style="color: blue">return </b>naturals_definition(Z)(lemma);
	}
	<b style="color: blue">return </b>#is_inductive_set(NATURALS)(lemma0, lemma1);
}

<b style="color: blue">prove </b>NATURALS_contain_EMPTY_SET: EMPTY_SET in NATURALS{
	<b style="color: blue">extract </b>expand(NATURALS_inductive): empty_in_NATURALS, NATURALS_closure;
	<b style="color: blue">extract </b>empty_in_NATURALS|EMPTY_OTHER|: EMPTY_OTHER_in_NATURALS, EMPTY_OTHER_def;
	empty_EMPTY = #is_empty(EMPTY_SET)(empty_set_condition);
	EMPTY_equal = empty_set_unique(EMPTY_OTHER, EMPTY_SET)(EMPTY_OTHER_def, empty_EMPTY);
	<b style="color: blue">return </b>equality_consistency[&ltS: S in NATURALS&gt](EMPTY_OTHER, EMPTY_SET)(EMPTY_equal)(EMPTY_OTHER_in_NATURALS);
}

zero_definition = copy_set(EMPTY_SET)|ZERO|;
zero_is_natural = equality_consistency[&ltS: S in NATURALS&gt](EMPTY_SET, ZERO)(zero_definition)(NATURALS_contain_EMPTY_SET);
one_definition = successor(ZERO)|ONE|;
<b style="color: blue">prove </b>one_is_natural: ONE in NATURALS{
	<b style="color: blue">extract </b>expand(NATURALS_inductive): empty_in_naturals, closure_naturals;
	<b style="color: blue">return </b>closure_naturals(ZERO, ONE)(zero_is_natural, one_definition);
}
two_definition = successor(ONE)|TWO|;
<b style="color: blue">prove </b>two_is_natural: TWO in NATURALS{
	<b style="color: blue">extract </b>expand(NATURALS_inductive): empty_in_naturals, closure_naturals;
	<b style="color: blue">return </b>closure_naturals(ONE, TWO)(one_is_natural, two_definition);
}
three_definition = successor(TWO)|THREE|;
<b style="color: blue">prove </b>three_is_natural: THREE in NATURALS{
	<b style="color: blue">extract </b>expand(NATURALS_inductive): empty_in_naturals, closure_naturals;
	<b style="color: blue">return </b>closure_naturals(TWO, THREE)(two_is_natural, three_definition);
}
four_definition = successor(THREE)|FOUR|;
<b style="color: blue">prove </b>four_is_natural: FOUR in NATURALS{
	<b style="color: blue">extract </b>expand(NATURALS_inductive): empty_in_naturals, closure_naturals;
	<b style="color: blue">return </b>closure_naturals(THREE, FOUR)(three_is_natural, four_definition);
}

<b style="color: blue">prove </b>NATURALS_induction: *S(ZERO in S & *Y*Z(Y in S & is_successor(Y, Z) -&gt Z in S) -&gt is_subset(NATURALS, S)){
	<b style="color: blue">given </b>|S|;
	<b style="color: blue">implies </b>premise;
	<b style="color: blue">extract </b>premise: ZERO_in_S, closure;
	<b style="color: blue">prove </b>lemma: ^E(E in S & is_empty(E)){
		<b style="color: blue">choose </b>EMPTY_SET;
		EMPTY_SET_in_S = equality_consistency[&ltX: X in S&gt](EMPTY_SET, ZERO)(zero_definition)(ZERO_in_S);
		<b style="color: blue">return </b>EMPTY_SET_in_S, #is_empty(EMPTY_SET)(empty_set_condition);
	}
	inductive_S = #is_inductive_set(S)(lemma, closure);
	<b style="color: blue">prove </b>subset_def: *X(X in NATURALS -&gt X in S){
		<b style="color: blue">given </b>|X|;
		<b style="color: blue">implies </b>X_in_NATURALS;
		<b style="color: blue">return </b>naturals_definition(X)(X_in_NATURALS)(S)(inductive_S);
	}
	<b style="color: blue">return </b>#is_subset(NATURALS, S)(subset_def);
}

<b style="color: blue">prove </b>NATURALS_nonzero_successor: *N(N in NATURALS -&gt equal_sets(N, ZERO) | ^M(M in NATURALS & is_successor(M, N))){
	S_def = axiom_specify[&ltN: equal_sets(N, ZERO) | ^M(M in NATURALS & is_successor(M, N))&gt](NATURALS)|S|;
	ZERO_in_S = S_def(ZERO)(zero_is_natural, or(equal_sets_reflexive(ZERO), &lt:^M(M in NATURALS & is_successor(M, ZERO))&gt));
	<b style="color: blue">extract </b>expand(NATURALS_inductive): contains_empty, NATURALS_closure;
	<b style="color: blue">prove </b>closure: *Y*Z(Y in S & is_successor(Y, Z) -&gt Z in S){
		<b style="color: blue">given </b>|Y, Z|;
		<b style="color: blue">implies </b>Y_in_S, successor_Y;
		<b style="color: blue">extract </b>S_def(Y)(Y_in_S): Y_in_NATURALS, condition;
		Z_in_NATURALS = NATURALS_closure(Y, Z)(Y_in_NATURALS, successor_Y);
		<b style="color: blue">prove </b>lemma: ^M(M in NATURALS & is_successor(M, Z)){
			<b style="color: blue">choose </b>Y;
			<b style="color: blue">return </b>Y_in_NATURALS, successor_Y;
		}
		<b style="color: blue">return </b>S_def(Z)(Z_in_NATURALS, or(&lt:equal_sets(Z, ZERO)&gt, lemma));
	}
	NATURALS_subset_S = NATURALS_induction(S)(ZERO_in_S, closure);
	<b style="color: blue">given </b>|N|;
	<b style="color: blue">implies </b>N_in_NATURALS;
	N_in_S = expand(NATURALS_subset_S)(N)(N_in_NATURALS);
	<b style="color: blue">extract </b>S_def(N)(N_in_S): N_in_NATURALS, result;
	<b style="color: blue">return </b>result;
}

//We want to show that if a number has a successor, that the number is not zero (for later purposes)
<b style="color: blue">prove </b>NATURAL_successor_nonzero: *A*B(is_successor(A, B) -&gt ~equal_sets(B, ZERO)){
	<b style="color: blue">given </b>|A, B|;
	<b style="color: blue">implies </b>successor_B;
	not equal_B_ZERO;
	equal_B_EMPTY_SET = equality_consistency[&ltQ: equal_sets(B, Q)&gt](EMPTY_SET, ZERO)(zero_definition)(equal_B_ZERO);
	A_in_B = expand(successor_B)(A)(or(&lt:A in A&gt, equal_sets_reflexive(A)));
	A_in_EMPTY_SET = equality_consistency[&ltQ: A in Q&gt](B, EMPTY_SET)(equal_B_EMPTY_SET)(A_in_B);
	<b style="color: blue">return </b>empty_set_condition(A)(A_in_EMPTY_SET);
}

//Define what it means for one natural number to be less than (or equal to) another
//Note that the definition is the same as the definition of a subset
<b style="color: blue">define </b>NATURAL_less_than(A, B): *X(X in A -&gt X in B);

<b style="color: blue">prove </b>NATURAL_less_than_reflexive: *A(NATURAL_less_than(A, A)){
	<b style="color: blue">given </b>|A|;
	<b style="color: blue">prove </b>less_than_def: *X(X in A -&gt X in A){
		<b style="color: blue">given </b>|X|;
		<b style="color: blue">implies </b>X_in_A;
		<b style="color: blue">return </b>X_in_A;
	}
	<b style="color: blue">return </b>#NATURAL_less_than(A, A)(less_than_def);
}

<b style="color: blue">prove </b>NATURAL_less_than_transitive: *X*Y*Z(NATURAL_less_than(X, Y) & NATURAL_less_than(Y, Z) -&gt NATURAL_less_than(X, Z)){
	<b style="color: blue">given </b>|X, Y, Z|;
	<b style="color: blue">implies </b>less_than_XY, less_than_YZ;
	<b style="color: blue">prove </b>less_than_def: *S(S in X -&gt S in Z){
		<b style="color: blue">given </b>|S|;
		<b style="color: blue">implies </b>S_in_X;
		S_in_Y = expand(less_than_XY)(S)(S_in_X);
		<b style="color: blue">return </b>expand(less_than_YZ)(S)(S_in_Y);
	}
	<b style="color: blue">return </b>#NATURAL_less_than(X, Z)(less_than_def);
}

<b style="color: blue">define </b>NATURAL_less_than_strict(A, B): ^S(is_successor(A, S) & NATURAL_less_than(S, B));

<b style="color: blue">prove </b>NATURAL_less_than_strict_successor: *A*B(is_successor(A, B) -&gt NATURAL_less_than_strict(A, B)){
	<b style="color: blue">given </b>|A, B|;
	<b style="color: blue">implies </b>successor_B;
	<b style="color: blue">prove </b>less_than_strict_def: ^S(is_successor(A, S) & NATURAL_less_than(S, B)){
		<b style="color: blue">choose </b>B;
		<b style="color: blue">return </b>successor_B, NATURAL_less_than_reflexive(B);
	}
	<b style="color: blue">return </b>#NATURAL_less_than_strict(A, B)(less_than_strict_def);
}

<b style="color: blue">prove </b>NATURAL_less_than_weaken: *A*B(NATURAL_less_than_strict(A, B) -&gt NATURAL_less_than(A, B)){
	<b style="color: blue">given </b>|A, B|;
	<b style="color: blue">implies </b>less_than_strict;
	<b style="color: blue">extract </b>expand(less_than_strict)|S|: successor_S, less_than;
	<b style="color: blue">prove </b>less_than_def: *X(X in A -&gt X in B){
		<b style="color: blue">given </b>|X|;
		<b style="color: blue">implies </b>X_in_A;
		X_in_S = expand(successor_S)(X)(or(X_in_A, &lt:equal_sets(X, A)&gt));
		<b style="color: blue">return </b>expand(less_than)(X)(X_in_S);
	}
	<b style="color: blue">return </b>#NATURAL_less_than(A, B)(less_than_def);
}

//The natural numbers here have been defined such that N is the set {0, 1..., N - 1}
//Here we formally <b style="color: blue">prove </b>this
<b style="color: blue">prove </b>NATURALS_interpretation: *N(N in NATURALS -&gt *X(X in N &lt-&gt X in NATURALS & NATURAL_less_than_strict(X, N))){
	//First we take the set of all natural numbers for which the statement is true
	//Then we will apply induction
	R_def = axiom_specify[&ltN: *X(X in N &lt-&gt X in NATURALS & NATURAL_less_than_strict(X, N))&gt](NATURALS)|R|;
	<b style="color: blue">prove </b>ZERO_in_R: *X(X in ZERO &lt-&gt X in NATURALS & NATURAL_less_than_strict(X, ZERO)){
		<b style="color: blue">given </b>|X|;
		<b style="color: blue">prove </b>lemma0: X in ZERO -&gt X in NATURALS & NATURAL_less_than_strict(X, ZERO){
			<b style="color: blue">implies </b>X_in_ZERO;
			X_in_EMPTY_SET = equality_consistency[&ltS: X in S&gt](EMPTY_SET, ZERO)(zero_definition)(X_in_ZERO);
			<b style="color: blue">return </b>axiom_absurdity[&lt:X in NATURALS & NATURAL_less_than_strict(X, ZERO)&gt](empty_set_condition(X)(X_in_EMPTY_SET));
		}
		<b style="color: blue">prove </b>lemma1: X in NATURALS & NATURAL_less_than_strict(X, ZERO) -&gt X in ZERO{
			<b style="color: blue">implies </b>X_in_NATURALS, less_than_strict;
			<b style="color: blue">extract </b>expand(less_than_strict)|S|: successor, less_than;
			X_in_S = expand(successor)(X)(or(&lt:X in X&gt, equal_sets_reflexive(X)));
			<b style="color: blue">return </b>expand(less_than)(X)(X_in_S);
		}
		<b style="color: blue">return </b>iff(lemma0, lemma1);
	}
	ZERO_in_R = R_def(ZERO)(zero_is_natural, ZERO_in_R);
	<b style="color: blue">prove </b>closure: *Y*Z(Y in R & is_successor(Y, Z) -&gt Z in R){
		<b style="color: blue">given </b>|Y, Z|;
		<b style="color: blue">implies </b>Y_in_R, successor_Z;
		<b style="color: blue">extract </b>R_def(Y)(Y_in_R): Y_in_NATURALS, Y_cond;
		<b style="color: blue">extract </b>expand(NATURALS_inductive): empty_exists, successor_closure;
		Z_in_NATURALS = successor_closure(Y, Z)(Y_in_NATURALS, successor_Z);
		<b style="color: blue">prove </b>Z_in_R: *X(X in Z &lt-&gt X in NATURALS & NATURAL_less_than_strict(X, Z)){
			<b style="color: blue">given </b>|X|;
			<b style="color: blue">prove </b>lemma0: X in Z -&gt X in NATURALS & NATURAL_less_than_strict(X, Z){
				<b style="color: blue">implies </b>X_in_Z;
				X_in_Y_or_equal_Z = expand(successor_Z)(X)(X_in_Z);
				<b style="color: blue">return </b>branch(X_in_Y_or_equal_Z, X_in_Y, equal_Y){
					<b style="color: blue">extract </b>Y_cond(X)(X_in_Y): X_in_NATURALS , X_less_than_strict;
					<b style="color: blue">extract </b>expand(X_less_than_strict)|T|: successor_T, T_less_than_Y;
					Y_less_than_Z = NATURAL_less_than_weaken(Y, Z)(NATURAL_less_than_strict_successor(Y, Z)(successor_Z));
					<b style="color: blue">prove </b>less_than_strict_def: ^S(is_successor(X, S) & NATURAL_less_than(S, Z)){
						<b style="color: blue">choose </b>T;
						<b style="color: blue">return </b>successor_T, NATURAL_less_than_transitive(T, Y, Z)(T_less_than_Y, Y_less_than_Z);
					}
					<b style="color: blue">return </b>X_in_NATURALS, #NATURAL_less_than_strict(X, Z)(less_than_strict_def);
				} or {
					X_in_NATURALS = equality_consistency[&ltS: S in NATURALS&gt](X, Y)(equal_Y)(Y_in_NATURALS);
					Y_less_than_strict_Z = NATURAL_less_than_strict_successor(Y, Z)(successor_Z);
					<b style="color: blue">return </b>X_in_NATURALS, equality_consistency[&ltS: NATURAL_less_than_strict(S, Z)&gt](X, Y)(equal_Y)(Y_less_than_strict_Z);
				};
			}
			<b style="color: blue">prove </b>lemma1: X in NATURALS & NATURAL_less_than_strict(X, Z) -&gt X in Z{
				<b style="color: blue">implies </b>X_in_NATURALS, X_less_than_strict_Z;
				<b style="color: blue">extract </b>expand(X_less_than_strict_Z)|T|: successor_T, T_less_than_Z;
				X_in_T = expand(successor_T)(X)(or(&lt:X in X&gt, equal_sets_reflexive(X)));
				<b style="color: blue">return </b>expand(T_less_than_Z)(X)(X_in_T);
			}
			<b style="color: blue">return </b>iff(lemma0, lemma1);
		}
		<b style="color: blue">return </b>R_def(Z)(Z_in_NATURALS, Z_in_R);
	}
	NATURALS_subset_R = NATURALS_induction(R)(ZERO_in_R, closure);
	<b style="color: blue">given </b>|N|;
	<b style="color: blue">implies </b>N_in_NATURALS;
	N_in_R = expand(NATURALS_subset_R)(N)(N_in_NATURALS);
	<b style="color: blue">extract </b>R_def(N)(N_in_R): N_in_NATURALS, result;
	<b style="color: blue">return </b>result;
}
//Because of the proof above, I am now sure that I have defined the natural numbers correctly

//We need to show that if the predecessor of a natural number exists, it is a natural number
<b style="color: blue">prove </b>NATURALS_predecessor_closure: *N*M(N in NATURALS & is_successor(M, N) -&gt M in NATURALS){
	<b style="color: blue">given </b>|N, M|;
	<b style="color: blue">implies </b>N_in_NATURALS, successor_N;
	M_in_N = expand(successor_N)(M)(or(&lt:M in M&gt, equal_sets_reflexive(M)));
	<b style="color: blue">extract </b>NATURALS_interpretation(N)(N_in_NATURALS)(M)(M_in_N): M_in_NATURALS, M_less_than_strict;
	<b style="color: blue">return </b>M_in_NATURALS;
}

//Define an "addition function"
//It's quite a hefty definition, but it's just a stepping stone towards a better definition of addition
//It is based on the definition of addition in Peano arithmetic
<b style="color: blue">define </b>is_addition_function(F): is_function(F) & ^T(is_cross_product(NATURALS, NATURALS, T) & is_domain(F, T)) & is_codomain(F, NATURALS) & *X*Z(X in NATURALS & is_tuple(ZERO, X, Z) -&gt are_related(Z, X, F)) & *X*Y*T0*Z0(is_tuple(X, Y, T0) & are_related(T0, Z0, F) -&gt ^SX^T1^Z1(is_successor(X, SX) & is_tuple(SX, Y, T1) & are_related(T1, Z1, F) & is_successor(Z0, Z1)));

//Prove that addition exists!
//There are a lot of irrelevant results and definitions that need to be made for this proof
//So I encapsulated them inside of this very large proof
//The definition of an "addition function" characterizes the peano axioms of arithmetic
<b style="color: blue">prove </b>addition_function_exists: ^ADDITION_FUNCTION(is_addition_function(ADDITION_FUNCTION)){
	C_cross_product = cross_product(NATURALS, NATURALS)|C|;
	C_def = expand(C_cross_product);
	<b style="color: blue">extract </b>expand(NATURALS_inductive): empty_in_naturals, closure_naturals;
	
	//We <b style="color: blue">define </b>an "addition class" to be the inverse image of the addition function for some N.
	//However, we construct it in an alternative way, which allows us to <b style="color: blue">define </b>addition
	//Despite the recursive definition of an addition function.

	//When A is the addition class for a natural number N
	<b style="color: blue">define </b>is_addition_class(N, A): *B(B in A &lt-&gt ^C^D(is_tuple(C, D, B) & ((equal_sets(C, ZERO) & equal_sets(D, N)) | ^P^S^T(is_successor(P, C) & is_successor(D, S) & is_tuple(P, S, T) & T in A))));

	//The second lemma for this theorem is that the addition classes exist for all natural numbers
	<b style="color: blue">prove </b>addition_classes_exist: *N(N in NATURALS -&gt ^A(is_addition_class(N, A) & is_subset(A, C))){
		//We proceed by induction
		R_def = axiom_specify[&ltN: ^A(is_addition_class(N, A) & is_subset(A, C))&gt](NATURALS)|R|;
		//Base case
		<b style="color: blue">prove </b>ZERO_in_R: ^A(is_addition_class(ZERO, A) & is_subset(A, C)){
			A_def = axiom_specify[&ltS: is_tuple(ZERO, ZERO, S)&gt](C)|A|;
			<b style="color: blue">choose </b>A;
			<b style="color: blue">prove </b>addition_class_def: *B(B in A &lt-&gt ^C^D(is_tuple(C, D, B) & ((equal_sets(C, ZERO) & equal_sets(D, ZERO)) | ^P^S^T(is_successor(P, C) & is_successor(D, S) & is_tuple(P, S, T) & T in A)))){
				<b style="color: blue">given </b>|B|;
				<b style="color: blue">prove </b>lemma0: B in A -&gt ^C^D(is_tuple(C, D, B) & ((equal_sets(C, ZERO) & equal_sets(D, ZERO)) | ^P^S^T(is_successor(P, C) & is_successor(D, S) & is_tuple(P, S, T) & T in A))){
					<b style="color: blue">implies </b>B_in_A;
					<b style="color: blue">extract </b>A_def(B)(B_in_A): B_in_C, B_tuple_ZERO_ZERO;
					<b style="color: blue">choose </b>ZERO, ZERO;
					condition = or(and(equal_sets_reflexive(ZERO), equal_sets_reflexive(ZERO)), &lt:^P^S^T(is_successor(P, ZERO) & is_successor(ZERO, S) & is_tuple(P, S, T) & T in A)&gt);
					<b style="color: blue">return </b>B_tuple_ZERO_ZERO, condition;
				}
				<b style="color: blue">prove </b>lemma1: ^C^D(is_tuple(C, D, B) & ((equal_sets(C, ZERO) & equal_sets(D, ZERO)) | ^P^S^T(is_successor(P, C) & is_successor(D, S) & is_tuple(P, S, T) & T in A))) -&gt B in A{
					<b style="color: blue">implies </b>premise;
					<b style="color: blue">extract </b>premise|C, D|: tuple_B, either_condition;
					<b style="color: blue">return </b>branch(either_condition, equal_ZERO, predecessor){
						<b style="color: blue">extract </b>equal_ZERO: C_equal_ZERO, D_equal_ZERO;
						B_tuple_ZERO_D = equality_consistency[&ltS: is_tuple(S, D, B)&gt](C, ZERO)(C_equal_ZERO)(tuple_B);
						B_tuple_ZERO_ZERO = equality_consistency[&ltS: is_tuple(ZERO, S, B)&gt](D, ZERO)(D_equal_ZERO)(B_tuple_ZERO_D);
						<b style="color: blue">prove </b>cross_product_condition: ^E^F(E in NATURALS & F in NATURALS & is_tuple(E, F, B)){
							<b style="color: blue">choose </b>ZERO, ZERO;
							<b style="color: blue">return </b>zero_is_natural, zero_is_natural, B_tuple_ZERO_ZERO;
						}
						B_in_C = C_def(B)(cross_product_condition);
						<b style="color: blue">return </b>A_def(B)(B_in_C, B_tuple_ZERO_ZERO);
					} or {
						<b style="color: blue">extract </b>predecessor|P, S, T|: predecessor_P, successor_S, tuple_T, T_in_A;
						D_in_S = expand(successor_S)(D)(or(&lt:D in D&gt, equal_sets_reflexive(D)));
						<b style="color: blue">extract </b>A_def(T)(T_in_A): T_in_C, tuple_ZERO_ZERO;
						T_equal_T = equal_sets_reflexive(T);
						<b style="color: blue">extract </b>tuple_equal_condition(P, S, ZERO, ZERO, T, T)(tuple_T, tuple_ZERO_ZERO, T_equal_T): equal_P_ZERO, equal_S_ZERO;
						equal_S_EMPTY_SET = equal_sets_transitive(S, ZERO, EMPTY_SET)(equal_S_ZERO, equal_sets_symmetric(EMPTY_SET, ZERO)(zero_definition));
						D_in_EMPTY_SET = equality_consistency[&ltU: D in U&gt](S, EMPTY_SET)(equal_S_EMPTY_SET)(D_in_S);
						absurdity = empty_set_condition(D)(D_in_EMPTY_SET);
						<b style="color: blue">return </b>axiom_absurdity[goal](absurdity);
					};
				}
				<b style="color: blue">return </b>iff(lemma0, lemma1);
			}
			addition_class = #is_addition_class(ZERO, A)(addition_class_def);
			<b style="color: blue">prove </b>subset_def: *X(X in A -&gt X in C){
				<b style="color: blue">given </b>|X|;
				<b style="color: blue">implies </b>X_in_A;
				<b style="color: blue">extract </b>A_def(X)(X_in_A): X_in_C, tuple_X;
				<b style="color: blue">return </b>X_in_C;
			}
			A_subset_C = #is_subset(A, C)(subset_def);
			<b style="color: blue">return </b>addition_class, A_subset_C;
		}
		ZERO_in_R = R_def(ZERO)(zero_is_natural, ZERO_in_R);
		//Inductive step
		<b style="color: blue">prove </b>closure_R: *Y*Z(Y in R & is_successor(Y, Z) -&gt Z in R){
			<b style="color: blue">given </b>|Y, Y_1|;
			<b style="color: blue">implies </b>Y_in_R, successor_Y_1;
			<b style="color: blue">extract </b>R_def(Y)(Y_in_R): Y_in_NATURALS, both;
			Y_1_in_NATURALS = closure_naturals(Y, Y_1)(Y_in_NATURALS, successor_Y_1);
			<b style="color: blue">extract </b>both|F|: addition_class, F_subset_C;
			F_addition_class = expand(addition_class);
			G_def = axiom_specify[&ltQ: ^C^D(is_tuple(C, D, Q) & ((equal_sets(C, ZERO) & equal_sets(D, Y_1)) | ^C_NEG1^T(is_successor(C_NEG1, C) & is_tuple(C_NEG1, D, T) & T in F)))&gt](C)|G|;
			<b style="color: blue">prove </b>G_addition_class: *B(B in G &lt-&gt ^C^D(is_tuple(C, D, B) & ((equal_sets(C, ZERO) & equal_sets(D, Y_1)) | ^C_NEG1^D_1^T(is_successor(C_NEG1, C) & is_successor(D, D_1) & is_tuple(C_NEG1, D_1, T) & T in G)))){
				<b style="color: blue">given </b>|B|;
				<b style="color: blue">prove </b>lemma0: B in G -&gt ^C^D(is_tuple(C, D, B) & ((equal_sets(C, ZERO) & equal_sets(D, Y_1)) | ^C_NEG1^D_1^T(is_successor(C_NEG1, C) & is_successor(D, D_1) & is_tuple(C_NEG1, D_1, T) & T in G))){
					<b style="color: blue">implies </b>B_in_G;
					<b style="color: blue">extract </b>G_def(B)(B_in_G): B_in_C, B_condition;
					<b style="color: blue">extract </b>B_condition|C, D|: tuple_B, either_B;
					<b style="color: blue">extract </b>C_def(B)(B_in_C)|C_OTHER, D_OTHER|: C_OTHER_in_NATURALS, D_OTHER_in_NATURALS, tuple_B_other;
					<b style="color: blue">extract </b>tuple_equal_condition(C, D, C_OTHER, D_OTHER, B, B)(tuple_B, tuple_B_other, equal_sets_reflexive(B)): C_equal, D_equal;
					C_in_NATURALS = equality_consistency[&ltQ: Q in NATURALS&gt](C, C_OTHER)(C_equal)(C_OTHER_in_NATURALS);
					D_in_NATURALS = equality_consistency[&ltQ: Q in NATURALS&gt](D, D_OTHER)(D_equal)(D_OTHER_in_NATURALS);
					<b style="color: blue">choose </b>C, D;
					<b style="color: blue">return </b>branch(either_B, equal_initial, predecessor_exists){
						<b style="color: blue">return </b>tuple_B, or(equal_initial, &lt:^C_NEG1^D_1^T(is_successor(C_NEG1, C) & is_successor(D, D_1) & is_tuple(C_NEG1, D_1, T) & T in G)&gt);
					} or {
						<b style="color: blue">extract </b>predecessor_exists|C_NEG1, T0|: predecessor_C_NEG1, tuple_T0, T0_in_F;
						<b style="color: blue">extract </b>F_addition_class(T0)(T0_in_F)|C_NEG1_OTHER, D_OTHER|: tuple_T0_other, either_T0;
						<b style="color: blue">extract </b>tuple_equal_condition(C_NEG1, D, C_NEG1_OTHER, D_OTHER, T0, T0)(tuple_T0, tuple_T0_other, equal_sets_reflexive(T0)): equal_C_NEG1, equal_D;
						//D_OTHER is a different object, so I overwrite this variable in this scope because I use it later
						D_OTHER_in_NATURALS = equality_consistency[&ltQ: Q in NATURALS&gt](D, D_OTHER)(equal_D)(D_in_NATURALS);
						<b style="color: blue">return </b>branch(either_T0, equal_initial, predecessor_exists){
							<b style="color: blue">extract </b>equal_initial: equal_C_NEG1_OTHER_ZERO, equal_D_OTHER_Y;
							equal_C_NEG1_ZERO = equal_sets_transitive(C_NEG1, C_NEG1_OTHER, ZERO)(equal_C_NEG1, equal_C_NEG1_OTHER_ZERO);
							equal_D_Y = equal_sets_transitive(D, D_OTHER, Y)(equal_D, equal_D_OTHER_Y);
							successor_D_1 = successor(D)|D_1|;
							successor_D_1_Y = equality_consistency[&ltQ: is_successor(Q, D_1)&gt](D, Y)(equal_D_Y)(successor_D_1);
							equal_D_1_Y_1 = successor_unique(Y, D_1, Y_1)(successor_D_1_Y, successor_Y_1);
							tuple_T = tuple(C_NEG1, D_1)|T|;
							C_NEG1_in_NATURALS = equality_consistency[&ltQ: Q in NATURALS&gt](C_NEG1, ZERO)(equal_C_NEG1_ZERO)(zero_is_natural);
							D_1_in_NATURALS = closure_naturals(Y, D_1)(Y_in_NATURALS, successor_D_1_Y);
							<b style="color: blue">prove </b>T_in_G: ^C^D(is_tuple(C, D, T) & ((equal_sets(C, ZERO) & equal_sets(D, Y_1)) | ^C_NEG1^T(is_successor(C_NEG1, C) & is_tuple(C_NEG1, D, T) & T in F))){
								<b style="color: blue">choose </b>C_NEG1, D_1;
								<b style="color: blue">return </b>tuple_T, or(and(equal_C_NEG1_ZERO, equal_D_1_Y_1), &lt:^C_NEG2^T(is_successor(C_NEG2, C_NEG1) & is_tuple(C_NEG2, D_1, T) & T in F)&gt);
							}
							<b style="color: blue">prove </b>T_in_C: ^C^D(C in NATURALS & D in NATURALS & is_tuple(C, D, T)){
								<b style="color: blue">choose </b>C_NEG1, D_1;
								<b style="color: blue">return </b>C_NEG1_in_NATURALS, D_1_in_NATURALS, tuple_T;
							}
							T_in_C = C_def(T)(T_in_C);
							T_in_G = G_def(T)(T_in_C, T_in_G);
							<b style="color: blue">prove </b>condition: ^C_NEG1^D_1^T(is_successor(C_NEG1, C) & is_successor(D, D_1) & is_tuple(C_NEG1, D_1, T) & T in G){
								<b style="color: blue">choose </b>C_NEG1, D_1, T;
								<b style="color: blue">return </b>predecessor_C_NEG1, successor_D_1, tuple_T, T_in_G;
							}
							<b style="color: blue">return </b>tuple_B, or(&lt:equal_sets(C, ZERO) & equal_sets(D, Y_1)&gt, condition);
						} or {
							<b style="color: blue">extract </b>predecessor_exists|C_NEG2, D_1, T1|: predecessor_C_NEG2, successor_D_1, tuple_T1, T1_in_F;
							predecessor_C_NEG2 = equality_consistency[&ltQ: is_successor(C_NEG2, Q)&gt](C_NEG1, C_NEG1_OTHER)(equal_C_NEG1)(predecessor_C_NEG2);
							tuple_T2 = tuple(C_NEG1, D_1)|T2|;
							D_1_in_NATURALS = closure_naturals(D_OTHER, D_1)(D_OTHER_in_NATURALS, successor_D_1);
							successor_D_1 = equality_consistency[&ltQ: is_successor(Q, D_1)&gt](D, D_OTHER)(equal_D)(successor_D_1);
							<b style="color: blue">prove </b>T2_in_C: ^C_NEG1^D_1(C_NEG1 in NATURALS & D_1 in NATURALS & is_tuple(C_NEG1, D_1, T2)){
								<b style="color: blue">choose </b>C_NEG1, D_1;
								C_NEG1_in_NATURALS = NATURALS_predecessor_closure(C, C_NEG1)(C_in_NATURALS, predecessor_C_NEG1);
								<b style="color: blue">return </b>C_NEG1_in_NATURALS, D_1_in_NATURALS, tuple_T2;
							}
							T2_in_C = C_def(T2)(T2_in_C);
							<b style="color: blue">prove </b>condition: ^C_NEG1^D_1(is_tuple(C_NEG1, D_1, T2) & ((equal_sets(C_NEG1, ZERO) & equal_sets(D_1, Y_1)) | ^C_NEG2^T1(is_successor(C_NEG2, C_NEG1) & is_tuple(C_NEG2, D_1, T1) & T1 in F))){
								<b style="color: blue">choose </b>C_NEG1, D_1;
								<b style="color: blue">prove </b>condition: ^C_NEG2^T1(is_successor(C_NEG2, C_NEG1) & is_tuple(C_NEG2, D_1, T1) & T1 in F){
									<b style="color: blue">choose </b>C_NEG2, T1;
									<b style="color: blue">return </b>predecessor_C_NEG2, tuple_T1, T1_in_F;
								}
								<b style="color: blue">return </b>tuple_T2, or(&lt:equal_sets(C_NEG1, ZERO) & equal_sets(D_1, Y_1)&gt, condition);
							}
							T2_in_G = G_def(T2)(T2_in_C, condition);
							<b style="color: blue">prove </b>condition: ^C_NEG1^D_1^T2(is_successor(C_NEG1, C) & is_successor(D, D_1) & is_tuple(C_NEG1, D_1, T2) & T2 in G){
								<b style="color: blue">choose </b>C_NEG1, D_1, T2;
								<b style="color: blue">return </b>predecessor_C_NEG1, successor_D_1, tuple_T2, T2_in_G;
							}
							<b style="color: blue">return </b>tuple_B, or(&lt:equal_sets(C, ZERO) & equal_sets(D, Y_1)&gt, condition);
						};
					};
				}
				<b style="color: blue">prove </b>lemma1: ^C^D(is_tuple(C, D, B) & ((equal_sets(C, ZERO) & equal_sets(D, Y_1)) | ^C_NEG1^D_1^T(is_successor(C_NEG1, C) & is_successor(D, D_1) & is_tuple(C_NEG1, D_1, T) & T in G))) -&gt B in G{
					<b style="color: blue">implies </b>premise;
					<b style="color: blue">extract </b>premise|C, D|: tuple_B, either_B;
					<b style="color: blue">return </b>branch(either_B, equal_both, G_condition){
						<b style="color: blue">extract </b>equal_both: equal_C_ZERO, equal_D_Y_1;
						<b style="color: blue">prove </b>condition: ^C^D(is_tuple(C, D, B) & ((equal_sets(C, ZERO) & equal_sets(D, Y_1)) | ^C_NEG1^T(is_successor(C_NEG1, C) & is_tuple(C_NEG1, D, T) & T in F))){
							<b style="color: blue">choose </b>C, D;
							<b style="color: blue">return </b>tuple_B, or(equal_both, &lt:^C_NEG1^T(is_successor(C_NEG1, C) & is_tuple(C_NEG1, D, T) & T in F)&gt);
						}
						<b style="color: blue">prove </b>B_in_C: ^C^D(C in NATURALS & D in NATURALS & is_tuple(C, D, B)){
							<b style="color: blue">choose </b>C, D;
							C_in_NATURALS = equality_consistency[&ltQ: Q in NATURALS&gt](C, ZERO)(equal_C_ZERO)(zero_is_natural);
							D_in_NATURALS = equality_consistency[&ltQ: Q in NATURALS&gt](D, Y_1)(equal_D_Y_1)(Y_1_in_NATURALS);
							<b style="color: blue">return </b>C_in_NATURALS, D_in_NATURALS, tuple_B;
						}
						B_in_C = C_def(B)(B_in_C);
						<b style="color: blue">return </b>G_def(B)(B_in_C, condition);
					} or {
						<b style="color: blue">extract </b>G_condition|C_NEG1, D_1, T|: predecessor_C_NEG1, successor_D_1, tuple_T, T_in_G;
						<b style="color: blue">extract </b>G_def(T)(T_in_G): T_in_C, T_condition;
						<b style="color: blue">extract </b>T_condition|C_NEG1_OTHER, D_1_OTHER|: tuple_T_other, either_T;
						<b style="color: blue">extract </b>tuple_equal_condition(C_NEG1, D_1, C_NEG1_OTHER, D_1_OTHER, T, T)(tuple_T, tuple_T_other, equal_sets_reflexive(T)): equal_C_NEG1, equal_D_1;
						<b style="color: blue">return </b>branch(either_T, equal_initial, F_condition){
							<b style="color: blue">extract </b>equal_initial: equal_C_NEG1_ZERO, equal_D_1_Y_1;
							equal_C_NEG1_ZERO = equality_consistency[&ltQ: equal_sets(Q, ZERO)&gt](C_NEG1, C_NEG1_OTHER)(equal_C_NEG1)(equal_C_NEG1_ZERO);
							equal_D_1_Y_1 = equality_consistency[&ltQ: equal_sets(Q, Y_1)&gt](D_1, D_1_OTHER)(equal_D_1)(equal_D_1_Y_1);
							successor_D_1_Y = equality_consistency[&ltQ: is_successor(Y, Q)&gt](D_1, Y_1)(equal_D_1_Y_1)(successor_Y_1);
							equal_D_Y = predecessor_unique(D, Y, D_1)(successor_D_1, successor_D_1_Y);
							tuple_T0 = tuple(C_NEG1, D)|T0|;
							<b style="color: blue">prove </b>T0_in_F: ^C_NEG1^D(is_tuple(C_NEG1, D, T0) & ((equal_sets(C_NEG1, ZERO) & equal_sets(D, Y)) | ^P^S^T(is_successor(P, C_NEG1) & is_successor(D, S) & is_tuple(P, S, T) & T in F))){
								<b style="color: blue">choose </b>C_NEG1, D;
								<b style="color: blue">return </b>tuple_T0, or(and(equal_C_NEG1_ZERO, equal_D_Y), &lt:^P^S^T(is_successor(P, C_NEG1) & is_successor(D, S) & is_tuple(P, S, T) & T in F)&gt);
							}
							T0_in_F = F_addition_class(T0)(T0_in_F);
							<b style="color: blue">prove </b>condition: ^C_NEG1^T0(is_successor(C_NEG1, C) & is_tuple(C_NEG1, D, T0) & T0 in F){
								<b style="color: blue">choose </b>C_NEG1, T0;
								<b style="color: blue">return </b>predecessor_C_NEG1, tuple_T0, T0_in_F;
							}
							<b style="color: blue">prove </b>condition: ^C^D(is_tuple(C, D, B) & ((equal_sets(C, ZERO) & equal_sets(D, Y_1)) | ^C_NEG1^T0(is_successor(C_NEG1, C) & is_tuple(C_NEG1, D, T0) & T0 in F))){
								<b style="color: blue">choose </b>C, D;
								<b style="color: blue">return </b>tuple_B, or(&lt:equal_sets(C, ZERO) & equal_sets(D, Y_1)&gt, condition);
							}
							<b style="color: blue">prove </b>B_in_C: ^C^D(C in NATURALS & D in NATURALS & is_tuple(C, D, B)){
								<b style="color: blue">choose </b>C, D;
								C_NEG1_in_NATURALS = equality_consistency[&ltQ: Q in NATURALS&gt](C_NEG1, ZERO)(equal_C_NEG1_ZERO)(zero_is_natural);
								C_in_NATURALS = closure_naturals(C_NEG1, C)(C_NEG1_in_NATURALS, predecessor_C_NEG1);
								D_in_NATURALS = equality_consistency[&ltQ: Q in NATURALS&gt](D, Y)(equal_D_Y)(Y_in_NATURALS);
								<b style="color: blue">return </b>C_in_NATURALS, D_in_NATURALS, tuple_B;
							}
							B_in_C = C_def(B)(B_in_C);
							<b style="color: blue">return </b>G_def(B)(B_in_C, condition);
						} or {
							<b style="color: blue">extract </b>F_condition|C_NEG2, T0|: predecessor_C_NEG2, tuple_T0, T0_in_F;
							predecessor_C_NEG2 = equality_consistency[&ltQ: is_successor(C_NEG2, Q)&gt](C_NEG1, C_NEG1_OTHER)(equal_C_NEG1)(predecessor_C_NEG2);
							tuple_T0 = equality_consistency[&ltQ: is_tuple(C_NEG2, Q, T0)&gt](D_1, D_1_OTHER)(equal_D_1)(tuple_T0);
							tuple_T1 = tuple(C_NEG1, D)|T1|;
							<b style="color: blue">prove </b>T1_in_F: ^C_NEG2^D_1^T0(is_successor(C_NEG2, C_NEG1) & is_successor(D, D_1) & is_tuple(C_NEG2, D_1, T0) & T0 in F){
								<b style="color: blue">choose </b>C_NEG2, D_1, T0;
								<b style="color: blue">return </b>predecessor_C_NEG2, successor_D_1, tuple_T0, T0_in_F;
							}
							<b style="color: blue">prove </b>T1_in_F: ^C_NEG1^D(is_tuple(C_NEG1, D, T1) & ((equal_sets(C_NEG1, ZERO) & equal_sets(D, Y)) | ^C_NEG2^D_1^T0(is_successor(C_NEG2, C_NEG1) & is_successor(D, D_1) & is_tuple(C_NEG2, D_1, T0) & T0 in F))){
								<b style="color: blue">choose </b>C_NEG1, D;
								<b style="color: blue">return </b>tuple_T1, or(&lt:equal_sets(C_NEG1, ZERO) & equal_sets(D, Y)&gt, T1_in_F);
							}
							T1_in_F = F_addition_class(T1)(T1_in_F);
							//Here is where we use the stronger condition
							T1_in_C = expand(F_subset_C)(T1)(T1_in_F);
							<b style="color: blue">extract </b>C_def(T1)(T1_in_C)|C_NEG1_OTHER, D_OTHER|: C_NEG1_OTHER_in_NATURALS, D_OTHER_in_NATURALS, tuple_T1_other;
							<b style="color: blue">extract </b>tuple_equal_condition(C_NEG1, D, C_NEG1_OTHER, D_OTHER, T1, T1)(tuple_T1, tuple_T1_other, equal_sets_reflexive(T1)): equal_C_NEG1, equal_D;
							C_NEG1_in_NATURALS = equality_consistency[&ltQ: Q in NATURALS&gt](C_NEG1, C_NEG1_OTHER)(equal_C_NEG1)(C_NEG1_OTHER_in_NATURALS);
							D_in_NATURALS = equality_consistency[&ltQ: Q in NATURALS&gt](D, D_OTHER)(equal_D)(D_OTHER_in_NATURALS);
							C_in_NATURALS = closure_naturals(C_NEG1, C)(C_NEG1_in_NATURALS, predecessor_C_NEG1);
							<b style="color: blue">prove </b>condition: ^C_NEG1^T1(is_successor(C_NEG1, C) & is_tuple(C_NEG1, D, T1) & T1 in F){
								<b style="color: blue">choose </b>C_NEG1, T1;
								<b style="color: blue">return </b>predecessor_C_NEG1, tuple_T1, T1_in_F;
							}
							<b style="color: blue">prove </b>condition: ^C^D(is_tuple(C, D, B) & ((equal_sets(C, ZERO) & equal_sets(D, Y_1)) | ^C_NEG1^T1(is_successor(C_NEG1, C) & is_tuple(C_NEG1, D, T1) & T1 in F))){
								<b style="color: blue">choose </b>C, D;
								<b style="color: blue">return </b>tuple_B, or(&lt:equal_sets(C, ZERO) & equal_sets(D, Y_1)&gt, condition);
							}
							<b style="color: blue">prove </b>B_in_C: ^C^D(C in NATURALS & D in NATURALS & is_tuple(C, D, B)){
								<b style="color: blue">choose </b>C, D;
								<b style="color: blue">return </b>C_in_NATURALS, D_in_NATURALS, tuple_B;
							}
							B_in_C = C_def(B)(B_in_C);
							<b style="color: blue">return </b>G_def(B)(B_in_C, condition);
						};
					};
				}
				<b style="color: blue">return </b>iff(lemma0, lemma1);
			}
			G_addition_class = #is_addition_class(Y_1, G)(G_addition_class);
			<b style="color: blue">prove </b>subset_def: *X(X in G -&gt X in C){
				<b style="color: blue">given </b>|X|;
				<b style="color: blue">implies </b>X_in_G;
				<b style="color: blue">extract </b>G_def(X)(X_in_G): X_in_C, G_condition;
				<b style="color: blue">return </b>X_in_C;
			}
			G_subset_C = #is_subset(G, C)(subset_def);
			<b style="color: blue">prove </b>Y_1_in_R: ^G(is_addition_class(Y_1, G) & is_subset(G, C)){
				<b style="color: blue">choose </b>G;
				<b style="color: blue">return </b>G_addition_class, G_subset_C;
			}
			<b style="color: blue">return </b>R_def(Y_1)(Y_1_in_NATURALS, Y_1_in_R);
		}
		NATURALS_subset_R = expand(NATURALS_induction(R)(ZERO_in_R, closure_R));
		<b style="color: blue">given </b>|N|;
		<b style="color: blue">implies </b>N_in_NATURALS;
		N_in_R = NATURALS_subset_R(N)(N_in_NATURALS);
		<b style="color: blue">extract </b>R_def(N)(N_in_R): N_in_NATURALS, addition_class_exists;
		result = addition_class_exists|A|;
		<b style="color: blue">choose </b>A;
		<b style="color: blue">return </b>result;
	}

	//Phew! That was the most important result of the proof. Next we need to <b style="color: blue">prove </b>that these addition classes cover all pairs of natural numbers.

	//This lemma shows that (0, x) belongs to an addition class of N if and only if x = N
	<b style="color: blue">prove </b>addition_class_initial_unique: *A*T*F*N(is_addition_class(N, F) & is_tuple(ZERO, A, T) -&gt (T in F &lt-&gt equal_sets(A, N))){
		<b style="color: blue">given </b>|A, T, F, N|;
		<b style="color: blue">implies </b>addition_class_F, tuple_T;
		<b style="color: blue">prove </b>lemma0: T in F -&gt equal_sets(A, N){
			<b style="color: blue">implies </b>T_in_F;
			<b style="color: blue">extract </b>expand(addition_class_F)(T)(T_in_F)|OTHER_ZERO, OTHER_A|: tuple_T_other, either;
			<b style="color: blue">extract </b>tuple_equal_condition(ZERO, A, OTHER_ZERO, OTHER_A, T, T)(tuple_T, tuple_T_other, equal_sets_reflexive(T)): equal_ZERO, equal_A;
			<b style="color: blue">return </b>branch(either, equal_both, predecessors){
				<b style="color: blue">extract </b>equal_both: equal_ZERO, equal_OTHER_A_N;
				<b style="color: blue">return </b>equal_sets_transitive(A, OTHER_A, N)(equal_A, equal_OTHER_A_N);
			} or {
				<b style="color: blue">extract </b>predecessors|C, D, T0|: predecessor_C, successor_D, tuple_T0, T0_in_F;
				not_zero = NATURAL_successor_nonzero(C, OTHER_ZERO)(predecessor_C);
				equal_OTHER_ZERO_ZERO = equal_sets_symmetric(ZERO, OTHER_ZERO)(equal_ZERO);
				absurdity = not_zero(equal_OTHER_ZERO_ZERO);
				<b style="color: blue">return </b>axiom_absurdity[goal](absurdity);
			};
		}
		<b style="color: blue">prove </b>lemma1: equal_sets(A, N) -&gt T in F{
			<b style="color: blue">implies </b>equal_A_N;
			<b style="color: blue">prove </b>condition: ^C^D(is_tuple(C, D, T) & ((equal_sets(C, ZERO) & equal_sets(D, N)) | ^P^S^T(is_successor(P, C) & is_successor(D, S) & is_tuple(P, S, T) & T in F))){
				<b style="color: blue">choose </b>ZERO, A;
				<b style="color: blue">return </b>tuple_T, or(and(equal_sets_reflexive(ZERO), equal_A_N), &lt:^P^S^T(is_successor(P, ZERO) & is_successor(A, S) & is_tuple(P, S, T) & T in F)&gt);
			}
			<b style="color: blue">return </b>expand(addition_class_F)(T)(condition);
		}
		<b style="color: blue">return </b>iff(lemma0, lemma1);
	}

	//Next we <b style="color: blue">prove </b>a crucial lemma to the next important result, again using induction
	//This result also shows the recursive peano <b style="color: blue">axiom </b>for addition
	<b style="color: blue">prove </b>addition_classes_cover_lemma: *A(A in NATURALS -&gt *B*T*F*N(N in NATURALS & is_addition_class(N, F) & is_tuple(A, B, T) & T in F -&gt ^S^T1^N1^F1(is_successor(A, S) & is_successor(N, N1) & is_addition_class(N1, F1) & is_tuple(S, B, T1) & T1 in F1))){
		//Again, we use induction!
		R_def = axiom_specify[&ltQ: *B*T*F*N(N in NATURALS & is_addition_class(N, F) & is_tuple(Q, B, T) & T in F -&gt ^S^T1^N1^F1(is_successor(Q, S) & is_successor(N, N1) & is_addition_class(N1, F1) & is_tuple(S, B, T1) & T1 in F1))&gt](NATURALS)|R|;
		//Base step
		<b style="color: blue">prove </b>ZERO_in_R: *B*T*F*N(N in NATURALS & is_addition_class(N, F) & is_tuple(ZERO, B, T) & T in F -&gt ^S^T1^N1^F1(is_successor(ZERO, S) & is_successor(N, N1) & is_addition_class(N1, F1) & is_tuple(S, B, T1) & T1 in F1)){
			<b style="color: blue">given </b>|B, T, F, N|;
			<b style="color: blue">implies </b>N_in_NATURALS, addition_class_F, tuple_T, T_in_F;
			equal_B_N = addition_class_initial_unique(B, T, F, N)(addition_class_F, tuple_T)(T_in_F);
			successor_N1 = successor(N)|N1|;
			N1_in_NATURALS = closure_naturals(N, N1)(N_in_NATURALS, successor_N1);
			tuple_T0 = tuple(ZERO, N1)|T0|;
			<b style="color: blue">extract </b>addition_classes_exist(N1)(N1_in_NATURALS)|F1|: addition_class_F1, F1_subset_C;
			T0_in_F1 = addition_class_initial_unique(N1, T0, F1, N1)(addition_class_F1, tuple_T0)(equal_sets_reflexive(N1));
			tuple_T1 = tuple(ONE, N)|T1|;
			<b style="color: blue">prove </b>T1_in_F1: ^ONE^N(is_tuple(ONE, N, T1) & ((equal_sets(ONE, ZERO) & equal_sets(N, N1)) | ^ZERO^N1^T0(is_successor(ZERO, ONE) & is_successor(N, N1) & is_tuple(ZERO, N1, T0) & T0 in F1))){
				<b style="color: blue">choose </b>ONE, N;
				<b style="color: blue">prove </b>condition: ^ZERO^N1^T0(is_successor(ZERO, ONE) & is_successor(N, N1) & is_tuple(ZERO, N1, T0) & T0 in F1){
					<b style="color: blue">choose </b>ZERO, N1, T0;
					<b style="color: blue">return </b>one_definition, successor_N1, tuple_T0, T0_in_F1;
				}
				<b style="color: blue">return </b>tuple_T1, or(&lt:equal_sets(ONE, ZERO) & equal_sets(N, N1)&gt, condition);
			}
			T1_in_F1 = expand(addition_class_F1)(T1)(T1_in_F1);
			tuple_T1 = equality_consistency[&ltQ: is_tuple(ONE, Q, T1)&gt](B, N)(equal_B_N)(tuple_T1);
			<b style="color: blue">choose </b>ONE, T1, N1, F1;
			<b style="color: blue">return </b>one_definition, successor_N1, addition_class_F1, tuple_T1, T1_in_F1;
		}
		ZERO_in_R = R_def(ZERO)(zero_is_natural, ZERO_in_R);
		//Inductive step
		<b style="color: blue">prove </b>closure_R: *Y*Z(Y in R & is_successor(Y, Z) -&gt Z in R){
			<b style="color: blue">given </b>|Y, Y1|;
			<b style="color: blue">implies </b>Y_in_R, successor_Y1;
			Y1_not_ZERO = NATURAL_successor_nonzero(Y, Y1)(successor_Y1);
			<b style="color: blue">extract </b>R_def(Y)(Y_in_R): Y_in_NATURALS, Y_condition;
			successor_Y2 = successor(Y1)|Y2|;
			Y2_not_ZERO = NATURAL_successor_nonzero(Y1, Y2)(successor_Y2);
			Y1_in_NATURALS = closure_naturals(Y, Y1)(Y_in_NATURALS, successor_Y1);
			<b style="color: blue">prove </b>Y1_in_R: *B*T*F*N(N in NATURALS & is_addition_class(N, F) & is_tuple(Y1, B, T) & T in F -&gt ^Y2^T1^N1^F1(is_successor(Y1, Y2) & is_successor(N, N1) & is_addition_class(N1, F1) & is_tuple(Y2, B, T1) & T1 in F1)){
				<b style="color: blue">given </b>|B, T, F, N|;
				<b style="color: blue">implies </b>N_in_NATURALS, addition_class_F, tuple_T, T_in_F;
				<b style="color: blue">extract </b>expand(addition_class_F)(T)(T_in_F)|OTHER_Y1, OTHER_B|: other_tuple_T, either_T;
				<b style="color: blue">extract </b>tuple_equal_condition(Y1, B, OTHER_Y1, OTHER_B, T, T)(tuple_T, other_tuple_T, equal_sets_reflexive(T)): equal_Y1, equal_B;
				predecessor_exists_T = branch(either_T, equal_initial_T, predecessor_exists_T){
					<b style="color: blue">extract </b>equal_initial_T: equal_OTHER_Y1_ZERO, equal_OTHER_B_N;
					equal_Y1_ZERO = equality_consistency[&ltS: equal_sets(S, ZERO)&gt](Y1, OTHER_Y1)(equal_Y1)(equal_OTHER_Y1_ZERO);
					absurdity = Y1_not_ZERO(equal_Y1_ZERO);
					<b style="color: blue">return </b>axiom_absurdity[&lt:^Y^B1^T0(is_successor(Y, OTHER_Y1) & is_successor(OTHER_B, B1) & is_tuple(Y, B1, T0) & T0 in F)&gt](absurdity);
				} or {
					<b style="color: blue">return </b>predecessor_exists_T;
				};
				<b style="color: blue">extract </b>predecessor_exists_T|OTHER_Y, B1, T0|: successor_OTHER_Y1, successor_B1, tuple_T0, T0_in_F;
				successor_Y1_OTHER_Y = equality_consistency[&ltS: is_successor(OTHER_Y, S)&gt](Y1, OTHER_Y1)(equal_Y1)(successor_OTHER_Y1);
				equal_Y = predecessor_unique(Y, OTHER_Y, Y1)(successor_Y1, successor_Y1_OTHER_Y);
				tuple_T0 = equality_consistency[&ltS: is_tuple(S, B1, T0)&gt](Y, OTHER_Y)(equal_Y)(tuple_T0);
				existence_in_F1 = Y_condition(B1, T0, F, N)(N_in_NATURALS, addition_class_F, tuple_T0, T0_in_F);

				//I want to overwrite OTHER_Y1 because I no longer need the older "version" of this object
				//So I must overwrite the other statements which refer to this old object
				other_tuple_T = axiom_true;
				either_T = axiom_true;
				equal_Y1 = axiom_true;
				predecessor_exists_T = axiom_true;
				successor_OTHER_Y1 = axiom_true;

				<b style="color: blue">extract </b>existence_in_F1|OTHER_Y1, T1_PRED, N1, F1|: successor_OTHER_Y1, successor_N1, addition_class_F1, tuple_T1_PRED, T1_PRED_in_F1;
				equal_Y1 = successor_unique(Y, Y1, OTHER_Y1)(successor_Y1, successor_OTHER_Y1);
				successor_B1 = equality_consistency[&ltS: is_successor(S, B1)&gt](B, OTHER_B)(equal_B)(successor_B1);
				tuple_T1_PRED = equality_consistency[&ltS: is_tuple(S, B1, T1_PRED)&gt](Y1, OTHER_Y1)(equal_Y1)(tuple_T1_PRED);
				successor_Y2 = successor(Y1)|Y2|;
				tuple_T1 = tuple(Y2, B)|T1|;
				<b style="color: blue">choose </b>Y2, T1, N1, F1;
				<b style="color: blue">prove </b>condition: ^P^S^T(is_successor(P, Y2) & is_successor(B, S) & is_tuple(P, S, T) & T in F1){
					<b style="color: blue">choose </b>Y1, B1, T1_PRED;
					<b style="color: blue">return </b>successor_Y2, successor_B1, tuple_T1_PRED, T1_PRED_in_F1;
				}
				<b style="color: blue">prove </b>T1_in_F1: ^Y2^B(is_tuple(Y2, B, T1) & ((equal_sets(Y2, ZERO) & equal_sets(B, N1)) | ^P^S^T(is_successor(P, Y2) & is_successor(B, S) & is_tuple(P, S, T) & T in F1))){
					<b style="color: blue">choose </b>Y2, B;
					<b style="color: blue">return </b>tuple_T1, or(&lt:equal_sets(Y2, ZERO) & equal_sets(B, N1)&gt, condition);
				}
				T1_in_F1 = expand(addition_class_F1)(T1)(T1_in_F1);
				<b style="color: blue">return </b>successor_Y2, successor_N1, addition_class_F1, tuple_T1, T1_in_F1;
			}
			<b style="color: blue">return </b>R_def(Y1)(Y1_in_NATURALS, Y1_in_R);
		}
		NATURALS_subset_R = NATURALS_induction(R)(ZERO_in_R, closure_R);
		<b style="color: blue">given </b>|A|;
		<b style="color: blue">implies </b>A_in_NATURALS;
		A_in_R = expand(NATURALS_subset_R)(A)(A_in_NATURALS);
		<b style="color: blue">extract </b>R_def(A)(A_in_R): A_in_NATURALS, result;

		<b style="color: blue">return </b>result;
	}

	//Now we <b style="color: blue">prove </b>that the addition classes "cover" the tuples of natural numbers
	<b style="color: blue">prove </b>addition_classes_cover: *A*B(A in NATURALS & B in NATURALS -&gt ^T^N^F(is_tuple(B, A, T) & N in NATURALS & is_addition_class(N, F) & T in F)){
		<b style="color: blue">given </b>|A, B|;
		<b style="color: blue">implies </b>A_in_NATURALS, B_in_NATURALS;
		R_def = axiom_specify[&ltS: ^T^N^F(is_tuple(S, A, T) & N in NATURALS & is_addition_class(N, F) & T in F)&gt](NATURALS)|R|;
		<b style="color: blue">prove </b>ZERO_in_R: ^T^N^F(is_tuple(ZERO, A, T) & N in NATURALS & is_addition_class(N, F) & T in F){
			tuple_T = tuple(ZERO, A)|T|;
			<b style="color: blue">extract </b>addition_classes_exist(A)(A_in_NATURALS)|F|: addition_class_F, F_subset_C;
			T_in_F = addition_class_initial_unique(A, T, F, A)(addition_class_F, tuple_T)(equal_sets_reflexive(A));
			<b style="color: blue">choose </b>T, A, F;
			<b style="color: blue">return </b>tuple_T, A_in_NATURALS, addition_class_F, T_in_F;
		}
		ZERO_in_R = R_def(ZERO)(zero_is_natural, ZERO_in_R);
		<b style="color: blue">prove </b>closure_R: *Y*Y1(Y in R & is_successor(Y, Y1) -&gt Y1 in R){
			<b style="color: blue">given </b>|Y, Y1|;
			<b style="color: blue">implies </b>Y_in_R, successor_Y1;
			<b style="color: blue">extract </b>R_def(Y)(Y_in_R): Y_in_NATURALS, Y_condition;
			<b style="color: blue">extract </b>Y_condition|T, N, F|: tuple_T, N_in_NATURALS, addition_class_F, T_in_F;
			next_exists = addition_classes_cover_lemma(Y)(Y_in_NATURALS)(A, T, F, N)(N_in_NATURALS, addition_class_F, tuple_T, T_in_F);
			<b style="color: blue">extract </b>next_exists|OTHER_Y1, T1, N1, F1|: successor_OTHER_Y1, successor_N1, addition_class_F1, tuple_T1, T1_in_F1;
			equal_Y1 = successor_unique(Y, Y1, OTHER_Y1)(successor_Y1, successor_OTHER_Y1);
			tuple_T1 = equality_consistency[&ltS: is_tuple(S, A, T1)&gt](Y1, OTHER_Y1)(equal_Y1)(tuple_T1);
			N1_in_NATURALS = closure_naturals(N, N1)(N_in_NATURALS, successor_N1);
			Y1_in_NATURALS = closure_naturals(Y, Y1)(Y_in_NATURALS, successor_Y1);
			<b style="color: blue">prove </b>Y1_in_R: ^T1^N1^F1(is_tuple(Y1, A, T1) & N1 in NATURALS & is_addition_class(N1, F1) & T1 in F1){
				<b style="color: blue">choose </b>T1, N1, F1;
				<b style="color: blue">return </b>tuple_T1, N1_in_NATURALS, addition_class_F1, T1_in_F1;
			}
			<b style="color: blue">return </b>R_def(Y1)(Y1_in_NATURALS, Y1_in_R);
		}
		NATURALS_subset_R = NATURALS_induction(R)(ZERO_in_R, closure_R);
		B_in_R = expand(NATURALS_subset_R)(B)(B_in_NATURALS);
		<b style="color: blue">extract </b>R_def(B)(B_in_R): B_in_NATURALS, result;
		
		<b style="color: blue">return </b>result;
	}

	//Here we <b style="color: blue">prove </b>that (A, B) can belong to at most one addition class
	<b style="color: blue">prove </b>addition_classes_unique: *A*B*N*M*FN*FM(A in NATURALS & B in NATURALS & is_addition_class(N, FN) & is_addition_class(M, FM) & ^T(is_tuple(A, B, T) & T in FN & T in FM) -&gt equal_sets(N, M)){
		R_def = axiom_specify[&ltS: *B*N*M*FN*FM(S in NATURALS & B in NATURALS & is_addition_class(N, FN) & is_addition_class(M, FM) & ^T(is_tuple(S, B, T) & T in FN & T in FM) -&gt equal_sets(N, M))&gt](NATURALS)|R|;
		<b style="color: blue">prove </b>ZERO_in_R: *B*N*M*FN*FM(ZERO in NATURALS & B in NATURALS & is_addition_class(N, FN) & is_addition_class(M, FM) & ^T(is_tuple(ZERO, B, T) & T in FN & T in FM) -&gt equal_sets(N, M)){
			<b style="color: blue">given </b>|B, N, M, FN, FM|;
			<b style="color: blue">implies </b>ZERO_in_NATURALS, B_in_NATURALS, addition_class_FN, addition_class_FM, T_exists;
			<b style="color: blue">extract </b>T_exists|T|: tuple_T, T_in_FN, T_in_FM;
			equal_B_N = addition_class_initial_unique(B, T, FN, N)(addition_class_FN, tuple_T)(T_in_FN);
			equal_B_M = addition_class_initial_unique(B, T, FM, M)(addition_class_FM, tuple_T)(T_in_FM);
			<b style="color: blue">return </b>equality_consistency[&ltS: equal_sets(S, M)&gt](B, N)(equal_B_N)(equal_B_M);
		}
		ZERO_in_R = R_def(ZERO)(zero_is_natural, ZERO_in_R);
		<b style="color: blue">prove </b>closure_R: *Y*Y1(Y in R & is_successor(Y, Y1) -&gt Y1 in R){
			<b style="color: blue">given </b>|Y, Y1|;
			<b style="color: blue">implies </b>Y_in_R, successor_Y1;
			<b style="color: blue">extract </b>R_def(Y)(Y_in_R): Y_in_NATURALS, Y_condition;
			Y1_in_NATURALS = closure_naturals(Y, Y1)(Y_in_NATURALS, successor_Y1);
			<b style="color: blue">prove </b>Y1_in_R: *B*N*M*FN*FM(Y1 in NATURALS & B in NATURALS & is_addition_class(N, FN) & is_addition_class(M, FM) & ^T(is_tuple(Y1, B, T) & T in FN & T in FM) -&gt equal_sets(N, M)){
				<b style="color: blue">given </b>|B, N, M, FN, FM|;
				<b style="color: blue">implies </b>Y1_in_NATURALS, B_in_NATURALS, addition_class_FN, addition_class_FM, T_exists;
				<b style="color: blue">extract </b>T_exists|T|: tuple_T, T_in_FN, T_in_FM;
				
				//First for FN
				<b style="color: blue">extract </b>expand(addition_class_FN)(T)(T_in_FN)|OTHER_Y1, OTHER_B|: other_tuple_T, either_T;
				<b style="color: blue">extract </b>tuple_equal_condition(Y1, B, OTHER_Y1, OTHER_B, T, T)(tuple_T, other_tuple_T, equal_sets_reflexive(T)): equal_Y1, equal_B;
				T_PRED_exists = branch(either_T, initial_T, T_PRED_exists){
					<b style="color: blue">extract </b>initial_T: equal_OTHER_Y1_ZERO, equal_B_N;
					equal_Y1_ZERO = equality_consistency[&ltS: equal_sets(S, ZERO)&gt](Y1, OTHER_Y1)(equal_Y1)(equal_OTHER_Y1_ZERO);
					not_equal_Y1_ZERO = NATURAL_successor_nonzero(Y, Y1)(successor_Y1);
					absurdity = not_equal_Y1_ZERO(equal_Y1_ZERO);
					<b style="color: blue">return </b>axiom_absurdity[&lt:^Y^B1^T1(is_successor(Y, OTHER_Y1) & is_successor(OTHER_B, B1) & is_tuple(Y, B1, T1) & T1 in FN)&gt](absurdity);
				} or {
					<b style="color: blue">return </b>T_PRED_exists;
				};
				<b style="color: blue">extract </b>T_PRED_exists|OTHER_Y, B1, T1|: other_successor_Y1, successor_B1, tuple_T1, T1_in_FN;
				other_successor_Y1 = equality_consistency[&ltS: is_successor(OTHER_Y, S)&gt](Y1, OTHER_Y1)(equal_Y1)(other_successor_Y1);
				equal_Y = predecessor_unique(Y, OTHER_Y, Y1)(successor_Y1, other_successor_Y1);
				tuple_T1 = equality_consistency[&ltS: is_tuple(S, B1, T1)&gt](Y, OTHER_Y)(equal_Y)(tuple_T1);
				successor_B1 = equality_consistency[&ltS: is_successor(S, B1)&gt](B, OTHER_B)(equal_B)(successor_B1);

				//Now the same for FM
				<b style="color: blue">extract </b>expand(addition_class_FM)(T)(T_in_FM)|M_OTHER_Y1, M_OTHER_B|: other_tuple_T, either_T;
				<b style="color: blue">extract </b>tuple_equal_condition(Y1, B, M_OTHER_Y1, M_OTHER_B, T, T)(tuple_T, other_tuple_T, equal_sets_reflexive(T)): equal_Y1, equal_B;
				T_PRED_exists = branch(either_T, initial_T, T_PRED_exists){
					<b style="color: blue">extract </b>initial_T: equal_M_OTHER_Y1_ZERO, equal_B_N;
					equal_Y1_ZERO = equality_consistency[&ltS: equal_sets(S, ZERO)&gt](Y1, M_OTHER_Y1)(equal_Y1)(equal_M_OTHER_Y1_ZERO);
					not_equal_Y1_ZERO = NATURAL_successor_nonzero(Y, Y1)(successor_Y1);
					absurdity = not_equal_Y1_ZERO(equal_Y1_ZERO);
					<b style="color: blue">return </b>axiom_absurdity[&lt:^Y^B1^T1(is_successor(Y, M_OTHER_Y1) & is_successor(M_OTHER_B, B1) & is_tuple(Y, B1, T1) & T1 in FM)&gt](absurdity);
				} or {
					<b style="color: blue">return </b>T_PRED_exists;
				};
				<b style="color: blue">extract </b>T_PRED_exists|M_OTHER_Y, M_B1, M_T1|: other_successor_Y1, M_successor_B1, tuple_M_T1, M_T1_in_FM;
				other_successor_Y1 = equality_consistency[&ltS: is_successor(M_OTHER_Y, S)&gt](Y1, M_OTHER_Y1)(equal_Y1)(other_successor_Y1);
				equal_Y = predecessor_unique(Y, M_OTHER_Y, Y1)(successor_Y1, other_successor_Y1);
				tuple_M_T1 = equality_consistency[&ltS: is_tuple(S, M_B1, M_T1)&gt](Y, M_OTHER_Y)(equal_Y)(tuple_M_T1);
				M_successor_B1 = equality_consistency[&ltS: is_successor(S, M_B1)&gt](B, M_OTHER_B)(equal_B)(M_successor_B1);

				B1_in_NATURALS = closure_naturals(B, B1)(B_in_NATURALS, successor_B1);
				equal_B1 = successor_unique(B, B1, M_B1)(successor_B1, M_successor_B1);
				tuple_M_T1 = equality_consistency[&ltS: is_tuple(Y, S, M_T1)&gt](B1, M_B1)(equal_B1)(tuple_M_T1);
				equal_T1 = tuple_unique(Y, B1, T1, M_T1)(tuple_T1, tuple_M_T1);
				T1_in_FM = equality_consistency[&ltS: S in FM&gt](T1, M_T1)(equal_T1)(M_T1_in_FM);

				<b style="color: blue">prove </b>condition: ^T1(is_tuple(Y, B1, T1) & T1 in FN & T1 in FM){
					<b style="color: blue">choose </b>T1;
					<b style="color: blue">return </b>tuple_T1, T1_in_FN, T1_in_FM;
				}
				<b style="color: blue">return </b>Y_condition(B1, N, M, FN, FM)(Y_in_NATURALS, B1_in_NATURALS, addition_class_FN, addition_class_FM, condition);
			}
			<b style="color: blue">return </b>R_def(Y1)(Y1_in_NATURALS, Y1_in_R);
		}
		NATURALS_subset_R = NATURALS_induction(R)(ZERO_in_R, closure_R);
		<b style="color: blue">given </b>|A, B, N, M, FN, FM|;
		<b style="color: blue">implies </b>premises;
		<b style="color: blue">extract </b>premises: A_in_NATURALS, rest_of_premises;
		A_in_R = expand(NATURALS_subset_R)(A)(A_in_NATURALS);
		<b style="color: blue">extract </b>R_def(A)(A_in_R): A_in_NATURALS, A_result;
		<b style="color: blue">return </b>A_result(B, N, M, FN, FM)(premises);
	}

	//FINALLY! IT'S TIME TO CONSTRUCT THE ADDITION FUNCTION!
	//Here it is!
	addition_function_definition = relation_existence_lemma[&ltT, Y: ^F(is_addition_class(Y, F) & T in F)&gt](C, NATURALS)|ADDITION_FUNCTION|;
	<b style="color: blue">choose </b>ADDITION_FUNCTION;

	//We must first <b style="color: blue">prove </b>that this is indeed a function
	<b style="color: blue">prove </b>ADDITION_FUNCTION_is_function: *X*Y*Z(are_related(X, Y, ADDITION_FUNCTION) & are_related(X, Z, ADDITION_FUNCTION) -&gt equal_sets(Y, Z)){
		<b style="color: blue">given </b>|X, Y, Z|;
		<b style="color: blue">implies </b>related_XY, related_XZ;

		<b style="color: blue">extract </b>addition_function_definition(X, Y)(related_XY): X_in_C, Y_in_NATURALS, F0_exists;
		<b style="color: blue">extract </b>F0_exists|F0|: addition_class_F0, X_in_F0;

		<b style="color: blue">extract </b>addition_function_definition(X, Z)(related_XZ): X_in_C, Z_in_NATURALS, F1_exists;
		<b style="color: blue">extract </b>F1_exists|F1|: addition_class_F1, X_in_F1;

		<b style="color: blue">extract </b>C_def(X)(X_in_C)|X0, X1|: X0_in_NATURALS, X1_in_NATURALS, tuple_X;
		<b style="color: blue">prove </b>condition: ^X(is_tuple(X0, X1, X) & X in F0 & X in F1){
			<b style="color: blue">choose </b>X;
			<b style="color: blue">return </b>tuple_X, X_in_F0, X_in_F1;
		}

		<b style="color: blue">return </b>addition_classes_unique(X0, X1, Y, Z, F0, F1)(X0_in_NATURALS, X1_in_NATURALS, addition_class_F0, addition_class_F1, condition);
	}

	ADDITION_FUNCTION_is_function = #is_function(ADDITION_FUNCTION)(ADDITION_FUNCTION_is_function);

	<b style="color: blue">prove </b>domain_C: *X(X in C -&gt ^Y(are_related(X, Y, ADDITION_FUNCTION))){
		<b style="color: blue">given </b>|X|;
		<b style="color: blue">implies </b>X_in_C;
		<b style="color: blue">extract </b>C_def(X)(X_in_C)|X0, X1|: X0_in_NATURALS, X1_in_NATURALS, tuple_X;
		<b style="color: blue">extract </b>addition_classes_cover(X1, X0)(X1_in_NATURALS, X0_in_NATURALS)|OTHER_X, Y, F|: tuple_OTHER_X, Y_in_NATURALS, addition_class_F, OTHER_X_in_F;
		<b style="color: blue">choose </b>Y;
		equal_X = tuple_unique(X0, X1, X, OTHER_X)(tuple_X, tuple_OTHER_X);
		X_in_F = equality_consistency[&ltS: S in F&gt](X, OTHER_X)(equal_X)(OTHER_X_in_F);
		<b style="color: blue">prove </b>related_XY: ^F(is_addition_class(Y, F) & X in F){
			<b style="color: blue">choose </b>F;
			<b style="color: blue">return </b>addition_class_F, X_in_F;
		}
		<b style="color: blue">return </b>addition_function_definition(X, Y)(X_in_C, Y_in_NATURALS, related_XY);
	}

	domain_C = #is_domain(ADDITION_FUNCTION, C)(domain_C);

	<b style="color: blue">prove </b>domain_exists: ^T(is_cross_product(NATURALS, NATURALS, T) & is_domain(ADDITION_FUNCTION, T)){
		<b style="color: blue">choose </b>C;
		<b style="color: blue">return </b>C_cross_product, domain_C;
	}

	<b style="color: blue">prove </b>codomain_NATURALS: *X*Y(are_related(X, Y, ADDITION_FUNCTION) -&gt Y in NATURALS){
		<b style="color: blue">given </b>|X, Y|;
		<b style="color: blue">implies </b>related_XY;
		<b style="color: blue">extract </b>addition_function_definition(X, Y)(related_XY): X_in_C, Y_in_NATURALS, addition_class_exists;
		<b style="color: blue">return </b>Y_in_NATURALS;
	}

	codomain_NATURALS = #is_codomain(ADDITION_FUNCTION, NATURALS)(codomain_NATURALS);

	<b style="color: blue">prove </b>zero_identity: *X*Z(X in NATURALS & is_tuple(ZERO, X, Z) -&gt are_related(Z, X, ADDITION_FUNCTION)){
		<b style="color: blue">given </b>|X, Z|;
		<b style="color: blue">implies </b>X_in_NATURALS, tuple_Z;
		<b style="color: blue">extract </b>addition_classes_exist(X)(X_in_NATURALS)|F|: addition_class_F, F_subset_C;
		Z_in_F = addition_class_initial_unique(X, Z, F, X)(addition_class_F, tuple_Z)(equal_sets_reflexive(X));
		<b style="color: blue">prove </b>related_ZX: ^F(is_addition_class(X, F) & Z in F){
			<b style="color: blue">choose </b>F;
			<b style="color: blue">return </b>addition_class_F, Z_in_F;
		}
		Z_in_C = expand(F_subset_C)(Z)(Z_in_F);
		<b style="color: blue">return </b>addition_function_definition(Z, X)(Z_in_C, X_in_NATURALS, related_ZX);
	}

	<b style="color: blue">prove </b>successor_recursion: *X*Y*T0*Z0(is_tuple(X, Y, T0) & are_related(T0, Z0, ADDITION_FUNCTION) -&gt ^SX^T1^Z1(is_successor(X, SX) & is_tuple(SX, Y, T1) & are_related(T1, Z1, ADDITION_FUNCTION) & is_successor(Z0, Z1))){
		<b style="color: blue">given </b>|X, Y, T0, Z0|;
		<b style="color: blue">implies </b>tuple_T0, related_T0Z0;
		<b style="color: blue">extract </b>addition_function_definition(T0, Z0)(related_T0Z0): T0_in_C, Z0_in_NATURALS, addition_class_exists;
		<b style="color: blue">extract </b>addition_class_exists|F0|: addition_class_F0, T0_in_F0;
		<b style="color: blue">extract </b>C_def(T0)(T0_in_C)|OTHER_X, OTHER_Y|: OTHER_X_in_NATURALS, OTHER_Y_in_NATURALS, other_tuple_T0;
		<b style="color: blue">extract </b>tuple_equal_condition(X, Y, OTHER_X, OTHER_Y, T0, T0)(tuple_T0, other_tuple_T0, equal_sets_reflexive(T0)): equal_X, equal_Y;
		X_in_NATURALS = equality_consistency[&ltS: S in NATURALS&gt](X, OTHER_X)(equal_X)(OTHER_X_in_NATURALS);
		Y_in_NATURALS = equality_consistency[&ltS: S in NATURALS&gt](Y, OTHER_Y)(equal_Y)(OTHER_Y_in_NATURALS);
		<b style="color: blue">extract </b>addition_classes_cover_lemma(X)(X_in_NATURALS)(Y, T0, F0, Z0)(Z0_in_NATURALS, addition_class_F0, tuple_T0, T0_in_F0)|SX, T1, Z1, F1|: successor_SX, successor_Z1, addition_class_F1, tuple_T1, T1_in_F1;
		<b style="color: blue">choose </b>SX, T1, Z1;
		SX_in_NATURALS = closure_naturals(X, SX)(X_in_NATURALS, successor_SX);
		<b style="color: blue">prove </b>T1_in_C: ^SX^Y(SX in NATURALS & Y in NATURALS & is_tuple(SX, Y, T1)){
			<b style="color: blue">choose </b>SX, Y;
			<b style="color: blue">return </b>SX_in_NATURALS, Y_in_NATURALS, tuple_T1;
		}
		T1_in_C = C_def(T1)(T1_in_C);
		Z1_in_NATURALS = closure_naturals(Z0, Z1)(Z0_in_NATURALS, successor_Z1);
		<b style="color: blue">prove </b>addition_class_exists: ^F1(is_addition_class(Z1, F1) & T1 in F1){
			<b style="color: blue">choose </b>F1;
			<b style="color: blue">return </b>addition_class_F1, T1_in_F1;
		}
		related_T1Z1 = addition_function_definition(T1, Z1)(T1_in_C, Z1_in_NATURALS, addition_class_exists);
		<b style="color: blue">return </b>successor_SX, tuple_T1, related_T1Z1, successor_Z1;
	}

	//Holy shit!
	<b style="color: blue">return </b>#is_addition_function(ADDITION_FUNCTION)(ADDITION_FUNCTION_is_function, domain_exists, codomain_NATURALS, zero_identity, successor_recursion);
}

naturals_addition_function_definition = addition_function_exists|NATURALS_ADDITION_FUNCTION|;

<b style="color: blue">define </b>is_natural_sum(X, Y, Z): X in NATURALS & Y in NATURALS & ^T(is_tuple(X, Y, T) & are_related(T, Z, NATURALS_ADDITION_FUNCTION));

<b style="color: blue">prove </b>natural_sum_zero_identity: *X(X in NATURALS -&gt is_natural_sum(ZERO, X, X)){
	<b style="color: blue">given </b>|X|;
	<b style="color: blue">implies </b>X_in_NATURALS;
	<b style="color: blue">extract </b>expand(naturals_addition_function_definition): is_function, domain_exists, codomain_NATURALS, zero_identity, successor_recursion;
	<b style="color: blue">extract </b>domain_exists|C|: cross_product_C, domain_C;
	tuple_T = tuple(ZERO, X)|T|;
	<b style="color: blue">prove </b>T_in_C: ^ZERO^X(ZERO in NATURALS & X in NATURALS & is_tuple(ZERO, X, T)){
		<b style="color: blue">choose </b>ZERO, X;
		<b style="color: blue">return </b>zero_is_natural, X_in_NATURALS, tuple_T;
	}
	T_in_C = expand(cross_product_C)(T)(T_in_C);
	related_TX = zero_identity(X, T)(X_in_NATURALS, tuple_T);
	<b style="color: blue">prove </b>natural_sum: ^T(is_tuple(ZERO, X, T) & are_related(T, X, NATURALS_ADDITION_FUNCTION)){
		<b style="color: blue">choose </b>T;
		<b style="color: blue">return </b>tuple_T, related_TX;
	}
	<b style="color: blue">return </b>#is_natural_sum(ZERO, X, X)(zero_is_natural, X_in_NATURALS, natural_sum);
}

<b style="color: blue">prove </b>natural_sum_successor_recursion: *X*Y*Z(is_natural_sum(X, Y, Z) -&gt ^X1^Z1(is_successor(X, X1) & is_successor(Z, Z1) & is_natural_sum(X1, Y, Z1))){
	<b style="color: blue">given </b>|X, Y, Z|;
	<b style="color: blue">implies </b>Z_natural_sum;
	<b style="color: blue">extract </b>expand(NATURALS_inductive): empty_in_naturals, closure_naturals;
	<b style="color: blue">extract </b>expand(Z_natural_sum): X_in_NATURALS, Y_in_NATURALS, T_exists;
	<b style="color: blue">extract </b>T_exists|T|: tuple_T, related_TZ;
	<b style="color: blue">extract </b>expand(naturals_addition_function_definition): is_function, domain_exists, codomain_NATURALS, zero_identity, successor_recursion;
	<b style="color: blue">extract </b>successor_recursion(X, Y, T, Z)(tuple_T, related_TZ)|X1, T1, Z1|: successor_X1, tuple_T1, related_T1Z1, successor_Z1;
	<b style="color: blue">choose </b>X1, Z1;
	<b style="color: blue">prove </b>natural_sum: ^T1(is_tuple(X1, Y, T1) & are_related(T1, Z1, NATURALS_ADDITION_FUNCTION)){
		<b style="color: blue">choose </b>T1;
		<b style="color: blue">return </b>tuple_T1, related_T1Z1;
	}
	X1_in_NATURALS = closure_naturals(X, X1)(X_in_NATURALS, successor_X1);
	natural_sum = #is_natural_sum(X1, Y, Z1)(X1_in_NATURALS, Y_in_NATURALS, natural_sum);
	<b style="color: blue">return </b>successor_X1, successor_Z1, natural_sum;
}

//We've bootstrapped the definition of addition so that we won't ever need the object "NATURALS_ADDITION_FUNCTION"
//We can use the "natural_sum" definition to calculate the sum of two natural numbers instead

//TIME TO PROVE THAT 2+2=4
<b style="color: blue">prove </b>TWO_plus_TWO_is_FOUR: is_natural_sum(TWO, TWO, FOUR){
	ZERO_plus_TWO = natural_sum_zero_identity(TWO)(two_is_natural);
	exists = natural_sum_successor_recursion(ZERO, TWO, TWO)(ZERO_plus_TWO);
	<b style="color: blue">extract </b>exists|OTHER_ONE, OTHER_THREE|: successor_OTHER_ONE, successor_OTHER_THREE, natural_sum;
	equal_ONE = successor_unique(ZERO, ONE, OTHER_ONE)(one_definition, successor_OTHER_ONE);
	equal_THREE = successor_unique(TWO, THREE, OTHER_THREE)(three_definition, successor_OTHER_THREE);
	natural_sum = equality_consistency[&ltS: is_natural_sum(OTHER_ONE, TWO, S)&gt](THREE, OTHER_THREE)(equal_THREE)(natural_sum);
	natural_sum = equality_consistency[&ltS: is_natural_sum(S, TWO, THREE)&gt](ONE, OTHER_ONE)(equal_ONE)(natural_sum);

	exists = natural_sum_successor_recursion(ONE, TWO, THREE)(natural_sum);
	<b style="color: blue">extract </b>exists|OTHER_TWO, OTHER_FOUR|: successor_OTHER_TWO, successor_OTHER_FOUR, natural_sum;
	equal_TWO = successor_unique(ONE, TWO, OTHER_TWO)(two_definition, successor_OTHER_TWO);
	equal_FOUR = successor_unique(THREE, FOUR, OTHER_FOUR)(four_definition, successor_OTHER_FOUR);
	natural_sum = equality_consistency[&ltS: is_natural_sum(OTHER_TWO, TWO, S)&gt](FOUR, OTHER_FOUR)(equal_FOUR)(natural_sum);
	<b style="color: blue">return </b>equality_consistency[&ltS: is_natural_sum(S, TWO, FOUR)&gt](TWO, OTHER_TWO)(equal_TWO)(natural_sum);
}

//Now we have to <b style="color: blue">prove </b>that the sum of two natural numbers actually exists
<b style="color: blue">prove </b>natural_sum: *X*Y(X in NATURALS & Y in NATURALS -&gt ^Z(Z in NATURALS & is_natural_sum(X, Y, Z))){
	<b style="color: blue">given </b>|X, Y|;
	<b style="color: blue">implies </b>X_in_NATURALS, Y_in_NATURALS;
	<b style="color: blue">extract </b>expand(naturals_addition_function_definition): is_function, domain_exists, codomain_NATURALS, zero_identity, successor_recursion;
	<b style="color: blue">extract </b>domain_exists|C|: cross_product_C, domain_C;
	tuple_T = tuple(X, Y)|T|;
	<b style="color: blue">prove </b>T_in_C: ^X^Y(X in NATURALS & Y in NATURALS & is_tuple(X, Y, T)){
		<b style="color: blue">choose </b>X, Y;
		<b style="color: blue">return </b>X_in_NATURALS, Y_in_NATURALS, tuple_T;
	}
	T_in_C = expand(cross_product_C)(T)(T_in_C);
	related_TZ = expand(domain_C)(T)(T_in_C)|Z|;
	<b style="color: blue">choose </b>Z;
	<b style="color: blue">prove </b>sum_Z: ^T(is_tuple(X, Y, T) & are_related(T, Z, NATURALS_ADDITION_FUNCTION)){
		<b style="color: blue">choose </b>T;
		<b style="color: blue">return </b>tuple_T, related_TZ;
	}
	Z_in_NATURALS = expand(codomain_NATURALS)(T, Z)(related_TZ);
	<b style="color: blue">return </b>Z_in_NATURALS, #is_natural_sum(X, Y, Z)(X_in_NATURALS, Y_in_NATURALS, sum_Z);
}

//We also have to <b style="color: blue">prove </b>that the sum of two natural numbers is unique
<b style="color: blue">prove </b>natural_sum_unique: *X*Y*Z0*Z1(is_natural_sum(X, Y, Z0) & is_natural_sum(X, Y, Z1) -&gt equal_sets(Z0, Z1)){
	<b style="color: blue">given </b>|X, Y, Z0, Z1|;
	<b style="color: blue">implies </b>natural_sum_Z0, natural_sum_Z1;
	<b style="color: blue">extract </b>expand(naturals_addition_function_definition): is_function, domain_exists, codomain_NATURALS, zero_identity, successor_recursion;
	<b style="color: blue">extract </b>expand(natural_sum_Z0): X_in_NATURALS, Y_in_NATURALS, T0_exists;
	<b style="color: blue">extract </b>expand(natural_sum_Z1): X_in_NATURALS, Y_in_NATURALS, T1_exists;
	<b style="color: blue">extract </b>T0_exists|T0|: tuple_T0, related_T0_Z0;
	<b style="color: blue">extract </b>T1_exists|T1|: tuple_T1, related_T1_Z1;
	equal_T = tuple_unique(X, Y, T0, T1)(tuple_T0, tuple_T1);
	related_T0_Z1 = equality_consistency[&ltS: are_related(S, Z1, NATURALS_ADDITION_FUNCTION)&gt](T0, T1)(equal_T)(related_T1_Z1);
	<b style="color: blue">return </b>expand(is_function)(T0, Z0, Z1)(related_T0_Z0, related_T0_Z1);
}

//Prove that if a natural sum exists then the sum must be a natural number
<b style="color: blue">prove </b>natural_sum_is_natural: *X*Y*Z(is_natural_sum(X, Y, Z) -&gt Z in NATURALS){
	<b style="color: blue">given </b>|X, Y, Z|;
	<b style="color: blue">implies </b>sum_Z;
	<b style="color: blue">extract </b>expand(sum_Z): X_in_NATURALS, Y_in_NATURALS, tuple_exists;
	<b style="color: blue">extract </b>natural_sum(X, Y)(X_in_NATURALS, Y_in_NATURALS)|OTHER_Z|: OTHER_Z_in_NATURALS, other_sum_Z;
	equal_Z = natural_sum_unique(X, Y, Z, OTHER_Z)(sum_Z, other_sum_Z);
	<b style="color: blue">return </b>equality_consistency[&ltQ: Q in NATURALS&gt](Z, OTHER_Z)(equal_Z)(OTHER_Z_in_NATURALS);
}

//Prove that addition commutes
//This is also a big theorem
<b style="color: blue">prove </b>natural_sum_commutative: *X*Y*Z(is_natural_sum(X, Y, Z) -&gt is_natural_sum(Y, X, Z)){
	<b style="color: blue">extract </b>expand(NATURALS_inductive): empty_in_naturals, closure_naturals;

	//First we have to <b style="color: blue">prove </b>that ZERO is a right identity
	<b style="color: blue">prove </b>identity_lemma: *X(X in NATURALS -&gt is_natural_sum(X, ZERO, X)){
		//Induction on X
		R_def = axiom_specify[&ltS: is_natural_sum(S, ZERO, S)&gt](NATURALS)|R|;
		ZERO_in_R = natural_sum_zero_identity(ZERO)(zero_is_natural);
		ZERO_in_R = R_def(ZERO)(zero_is_natural, ZERO_in_R);
		<b style="color: blue">prove </b>closure_R: *Y*Z(Y in R & is_successor(Y, Z) -&gt Z in R){
			<b style="color: blue">given </b>|Y, Z|;
			<b style="color: blue">implies </b>Y_in_R, successor_Z;
			<b style="color: blue">extract </b>R_def(Y)(Y_in_R): Y_in_NATURALS, sum_Y_ZERO;
			Z_in_NATURALS = closure_naturals(Y, Z)(Y_in_NATURALS, successor_Z);
			<b style="color: blue">extract </b>natural_sum_successor_recursion(Y, ZERO, Y)(sum_Y_ZERO)|OTHER_Z0, OTHER_Z1|: successor_OTHER_Z0, successor_OTHER_Z1, sum_Z_ZERO;
			Z0_equal_Z1 = successor_unique(Y, OTHER_Z0, OTHER_Z1)(successor_OTHER_Z0, successor_OTHER_Z1);
			Z_equal_Z0 = successor_unique(Y, Z, OTHER_Z0)(successor_Z, successor_OTHER_Z0);
			sum_Z_ZERO = equality_consistency[&ltS: is_natural_sum(OTHER_Z0, ZERO, S)&gt](OTHER_Z0, OTHER_Z1)(Z0_equal_Z1)(sum_Z_ZERO);
			sum_Z_ZERO = equality_consistency[&ltS: is_natural_sum(S, ZERO, S)&gt](Z, OTHER_Z0)(Z_equal_Z0)(sum_Z_ZERO);
			<b style="color: blue">return </b>R_def(Z)(Z_in_NATURALS, sum_Z_ZERO);
		}
		NATURALS_subset_R = NATURALS_induction(R)(ZERO_in_R, closure_R);
		<b style="color: blue">given </b>|X|;
		<b style="color: blue">implies </b>X_in_NATURALS;
		X_in_R = expand(NATURALS_subset_R)(X)(X_in_NATURALS);
		<b style="color: blue">extract </b>R_def(X)(X_in_R): X_in_NATURALS, result;
		<b style="color: blue">return </b>result;
	}

	<b style="color: blue">prove </b>commutative_lemma: *X*Y*Z*SZ(is_natural_sum(X, Y, Z) & is_successor(Z, SZ) -&gt ^SY(is_natural_sum(X, SY, SZ) & is_successor(Y, SY))){
		//Induction on X
		R_def = axiom_specify[&ltS: *Y*Z*SZ(is_natural_sum(S, Y, Z) & is_successor(Z, SZ) -&gt ^SY(is_natural_sum(S, SY, SZ) & is_successor(Y, SY)))&gt](NATURALS)|R|;
		<b style="color: blue">prove </b>ZERO_in_R: *Y*Z*SZ(is_natural_sum(ZERO, Y, Z) & is_successor(Z, SZ) -&gt ^SY(is_natural_sum(ZERO, SY, SZ) & is_successor(Y, SY))){
			<b style="color: blue">given </b>|Y, Z, SZ|;
			<b style="color: blue">implies </b>sum_Z, successor_SZ;
			<b style="color: blue">extract </b>expand(sum_Z): ZERO_in_NATURALS, Y_in_NATURALS, tuple_exists;
			sum_Y = natural_sum_zero_identity(Y)(Y_in_NATURALS);
			equal_Y_Z = natural_sum_unique(ZERO, Y, Y, Z)(sum_Y, sum_Z);
			successor_SY = successor(Y)|SY|;
			<b style="color: blue">choose </b>SY;
			SY_in_NATURALS = closure_naturals(Y, SY)(Y_in_NATURALS, successor_SY);
			other_successor_SY = equality_consistency[&ltS: is_successor(S, SY)&gt](Y, Z)(equal_Y_Z)(successor_SY);
			SY_equal_SZ = successor_unique(Z, SY, SZ)(other_successor_SY, successor_SZ);
			sum_SY = natural_sum_zero_identity(SY)(SY_in_NATURALS);
			sum_SZ = equality_consistency[&ltS: is_natural_sum(ZERO, SY, S)&gt](SY, SZ)(SY_equal_SZ)(sum_SY);
			<b style="color: blue">return </b>sum_SZ, successor_SY;
		}
		ZERO_in_R = R_def(ZERO)(zero_is_natural, ZERO_in_R);
		<b style="color: blue">prove </b>closure_R: *X*SX(X in R & is_successor(X, SX) -&gt SX in R){
			<b style="color: blue">given </b>|X, SX|;
			<b style="color: blue">implies </b>X_in_R, successor_SX;
			<b style="color: blue">extract </b>R_def(X)(X_in_R): X_in_NATURALS, X_condition;
			SX_in_NATURALS = closure_naturals(X, SX)(X_in_NATURALS, successor_SX);
			<b style="color: blue">prove </b>SX_in_R: *Y*Z*SZ(is_natural_sum(SX, Y, Z) & is_successor(Z, SZ) -&gt ^SY(is_natural_sum(SX, SY, SZ) & is_successor(Y, SY))){
				<b style="color: blue">given </b>|Y, Z, SZ|;
				<b style="color: blue">implies </b>sum_Z, successor_SZ;
				<b style="color: blue">extract </b>expand(sum_Z): SX_in_NATURALS, Y_in_NATURALS, exists_tuple;
				<b style="color: blue">extract </b>natural_sum(X, Y)(X_in_NATURALS, Y_in_NATURALS)|PZ|: PZ_in_NATURALS, sum_PZ;
				<b style="color: blue">extract </b>natural_sum_successor_recursion(X, Y, PZ)(sum_PZ)|OTHER_SX, OTHER_Z|: other_successor_SX, other_successor_Z, other_sum_Z;
				equal_SX = successor_unique(X, SX, OTHER_SX)(successor_SX, other_successor_SX);
				other_sum_Z = equality_consistency[&ltS: is_natural_sum(S, Y, OTHER_Z)&gt](SX, OTHER_SX)(equal_SX)(other_sum_Z);
				equal_Z = natural_sum_unique(SX, Y, Z, OTHER_Z)(sum_Z, other_sum_Z);
				successor_Z = equality_consistency[&ltS: is_successor(PZ, S)&gt](Z, OTHER_Z)(equal_Z)(other_successor_Z);
				<b style="color: blue">extract </b>X_condition(Y, PZ, Z)(sum_PZ, successor_Z)|SY|: sum_X_SY, successor_SY;
				<b style="color: blue">choose </b>SY;

				<b style="color: blue">extract </b>natural_sum_successor_recursion(X, SY, Z)(sum_X_SY)|OTHER_SX_2, OTHER_SZ|: successor_OTHER_SX_2, successor_OTHER_SZ, other_sum_SZ;
				equal_SX = successor_unique(X, SX, OTHER_SX_2)(successor_SX, successor_OTHER_SX_2);
				other_sum_SZ = equality_consistency[&ltS: is_natural_sum(S, SY, OTHER_SZ)&gt](SX, OTHER_SX_2)(equal_SX)(other_sum_SZ);
				equal_SZ = successor_unique(Z, SZ, OTHER_SZ)(successor_SZ, successor_OTHER_SZ);
				<b style="color: blue">return </b>equality_consistency[&ltS: is_natural_sum(SX, SY, S)&gt](SZ, OTHER_SZ)(equal_SZ)(other_sum_SZ), successor_SY;
			}
			<b style="color: blue">return </b>R_def(SX)(SX_in_NATURALS, SX_in_R);
		}
		NATURALS_subset_R = NATURALS_induction(R)(ZERO_in_R, closure_R);
		<b style="color: blue">given </b>|X, Y, Z, SZ|;
		<b style="color: blue">implies </b>sum_Z, successor_SZ;
		<b style="color: blue">extract </b>expand(sum_Z): X_in_NATURALS, Y_in_NATURALS, tuple_exists;
		X_in_R = expand(NATURALS_subset_R)(X)(X_in_NATURALS);
		<b style="color: blue">extract </b>R_def(X)(X_in_R): X_in_NATURALS, result;
		<b style="color: blue">return </b>result(Y, Z, SZ)(sum_Z, successor_SZ);
	}

	R_def = axiom_specify[&ltS: *Y*Z(is_natural_sum(S, Y, Z) -&gt is_natural_sum(Y, S, Z))&gt](NATURALS)|R|;

	<b style="color: blue">prove </b>ZERO_in_R: *Y*Z(is_natural_sum(ZERO, Y, Z) -&gt is_natural_sum(Y, ZERO, Z)){
		<b style="color: blue">given </b>|Y, Z|;
		<b style="color: blue">implies </b>sum_Z;
		<b style="color: blue">extract </b>expand(sum_Z): ZERO_in_NATURALS, Y_in_NATURALS, tuple_exists;
		sum_Y = natural_sum_zero_identity(Y)(Y_in_NATURALS);
		equal_Y_Z = natural_sum_unique(ZERO, Y, Y, Z)(sum_Y, sum_Z);
		sum_Y = identity_lemma(Y)(Y_in_NATURALS);
		<b style="color: blue">return </b>equality_consistency[&ltS: is_natural_sum(Y, ZERO, S)&gt](Y, Z)(equal_Y_Z)(sum_Y);
	}
	ZERO_in_R = R_def(ZERO)(zero_is_natural, ZERO_in_R);

	<b style="color: blue">prove </b>closure_R: *Y*Y1(Y in R & is_successor(Y, Y1) -&gt Y1 in R){
		<b style="color: blue">given </b>|Y, Y1|;
		<b style="color: blue">implies </b>Y_in_R, successor_Y1;
		<b style="color: blue">extract </b>R_def(Y)(Y_in_R): Y_in_NATURALS, Y_condition;
		Y1_in_NATURALS = closure_naturals(Y, Y1)(Y_in_NATURALS, successor_Y1);
		<b style="color: blue">prove </b>Y1_in_R: *R*S(is_natural_sum(Y1, R, S) -&gt is_natural_sum(R, Y1, S)){
			<b style="color: blue">given </b>|R, S|;
			<b style="color: blue">implies </b>sum_S;
			<b style="color: blue">extract </b>expand(sum_S): Y1_in_NATURALS, R_in_NATURALS, tuple_exists;
			<b style="color: blue">extract </b>natural_sum(Y, R)(Y_in_NATURALS, R_in_NATURALS)|PS|: PS_in_NATURALS, old_sum_PS;
			sum_PS = Y_condition(R, PS)(old_sum_PS);
			successor_OTHER_S = successor(PS)|OTHER_S|;
			<b style="color: blue">extract </b>commutative_lemma(R, Y, PS, OTHER_S)(sum_PS, successor_OTHER_S)|OTHER_Y1|: sum_OTHER_S, other_successor_Y1;
			equal_Y1 = successor_unique(Y, Y1, OTHER_Y1)(successor_Y1, other_successor_Y1);
			sum_OTHER_S = equality_consistency[&ltQ: is_natural_sum(R, Q, OTHER_S)&gt](Y1, OTHER_Y1)(equal_Y1)(sum_OTHER_S);
			<b style="color: blue">extract </b>natural_sum_successor_recursion(Y, R, PS)(old_sum_PS)|OTHER_Y1_2, OTHER_S_2|: successor_OTHER_Y1_2, successor_OTHER_S_2, sum_OTHER_S_2;
			equal_Y1_2 = successor_unique(Y, Y1, OTHER_Y1_2)(successor_Y1, successor_OTHER_Y1_2);
			equal_others_S = successor_unique(PS, OTHER_S, OTHER_S_2)(successor_OTHER_S, successor_OTHER_S_2);
			other_sum = equality_consistency[&ltQ: is_natural_sum(Q, R, OTHER_S_2)&gt](Y1, OTHER_Y1_2)(equal_Y1_2)(sum_OTHER_S_2);
			other_sum = equality_consistency[&ltQ: is_natural_sum(Y1, R, Q)&gt](OTHER_S, OTHER_S_2)(equal_others_S)(other_sum);
			equal_S = natural_sum_unique(Y1, R, S, OTHER_S)(sum_S, other_sum);
			<b style="color: blue">return </b>equality_consistency[&ltQ: is_natural_sum(R, Y1, Q)&gt](S, OTHER_S)(equal_S)(sum_OTHER_S);
		}
		<b style="color: blue">return </b>R_def(Y1)(Y1_in_NATURALS, Y1_in_R);
	}

	NATURALS_subset_R = NATURALS_induction(R)(ZERO_in_R, closure_R);
	<b style="color: blue">given </b>|X, Y, Z|;
	<b style="color: blue">implies </b>sum_Z;
	<b style="color: blue">extract </b>expand(sum_Z): X_in_NATURALS, Y_in_NATURALS, tuple_exists;
	X_in_R = expand(NATURALS_subset_R)(X)(X_in_NATURALS);
	<b style="color: blue">extract </b>R_def(X)(X_in_R): X_in_NATURALS, result;
	<b style="color: blue">return </b>result(Y, Z)(sum_Z);
}

//Prove that addition is associative
<b style="color: blue">prove </b>natural_sum_associative: *X*Y*Z*S*SXY*SYZ(is_natural_sum(X, Y, SXY) & is_natural_sum(SXY, Z, S) & is_natural_sum(Y, Z, SYZ) -&gt is_natural_sum(X, SYZ, S)){
	<b style="color: blue">extract </b>expand(NATURALS_inductive): empty_in_NATURALS, closure_naturals;
	//By induction
	R_def = axiom_specify[&ltQ: *Y*Z*S*SXY*SYZ(is_natural_sum(Q, Y, SXY) & is_natural_sum(SXY, Z, S) & is_natural_sum(Y, Z, SYZ) -&gt is_natural_sum(Q, SYZ, S))&gt](NATURALS)|R|;
	<b style="color: blue">prove </b>ZERO_in_R: *Y*Z*S*SXY*SYZ(is_natural_sum(ZERO, Y, SXY) & is_natural_sum(SXY, Z, S) & is_natural_sum(Y, Z, SYZ) -&gt is_natural_sum(ZERO, SYZ, S)){
		<b style="color: blue">given </b>|Y, Z, S, SXY, SYZ|;
		<b style="color: blue">implies </b>sum_SXY, sum_S, sum_SYZ;
		<b style="color: blue">extract </b>expand(sum_SXY): ZERO_in_NATURALS, Y_in_NATURALS, tuple_exists;
		<b style="color: blue">extract </b>expand(sum_S): SXY_in_NATURALS, Z_in_NATURALS, tuple_exists;
		other_sum_SXY = natural_sum_zero_identity(Y)(Y_in_NATURALS);
		equal_Y_SXY = natural_sum_unique(ZERO, Y, Y, SXY)(other_sum_SXY, sum_SXY);
		sum_S = equality_consistency[&ltQ: is_natural_sum(Q, Z, S)&gt](Y, SXY)(equal_Y_SXY)(sum_S);
		equal_S_SYZ = natural_sum_unique(Y, Z, S, SYZ)(sum_S, sum_SYZ);
		
		<b style="color: blue">extract </b>natural_sum(Y, Z)(Y_in_NATURALS, Z_in_NATURALS)|OTHER_S|: OTHER_S_in_NATURALS, other_sum_S;
		equal_S = natural_sum_unique(Y, Z, S, OTHER_S)(sum_S, other_sum_S);
		S_in_NATURALS = equality_consistency[&ltQ: Q in NATURALS&gt](S, OTHER_S)(equal_S)(OTHER_S_in_NATURALS);

		sum_S = natural_sum_zero_identity(S)(S_in_NATURALS);
		<b style="color: blue">return </b>equality_consistency[&ltQ: is_natural_sum(ZERO, Q, S)&gt](S, SYZ)(equal_S_SYZ)(sum_S);
	}
	ZERO_in_R = R_def(ZERO)(zero_is_natural, ZERO_in_R);
	<b style="color: blue">prove </b>closure_R: *K*K1(K in R & is_successor(K, K1) -&gt K1 in R){
		<b style="color: blue">given </b>|K, K1|;
		<b style="color: blue">implies </b>K_in_R, successor_K1;
		<b style="color: blue">extract </b>R_def(K)(K_in_R): K_in_NATURALS, K_condition;
		K1_in_NATURALS = closure_naturals(K, K1)(K_in_NATURALS, successor_K1);
		<b style="color: blue">prove </b>K1_in_R: *Y*Z*S*SXY*SYZ(is_natural_sum(K1, Y, SXY) & is_natural_sum(SXY, Z, S) & is_natural_sum(Y, Z, SYZ) -&gt is_natural_sum(K1, SYZ, S)){
			<b style="color: blue">given </b>|Y, Z, S, SXY, SYZ|;
			<b style="color: blue">implies </b>sum_SXY, sum_S, sum_SYZ;
			<b style="color: blue">extract </b>expand(sum_SYZ): Y_in_NATURALS, Z_in_NATURALS, tuple_exists;
			<b style="color: blue">extract </b>natural_sum(K, Y)(K_in_NATURALS, Y_in_NATURALS)|P_SXY|: P_SXY_in_NATURALS, sum_P_SXY;
			<b style="color: blue">extract </b>natural_sum_successor_recursion(K, Y, P_SXY)(sum_P_SXY)|OTHER_K1, OTHER_SXY|: other_successor_K1, other_successor_SXY, other_sum_SXY;
			equal_K1 = successor_unique(K, K1, OTHER_K1)(successor_K1, other_successor_K1);
			other_sum_SXY = equality_consistency[&ltQ: is_natural_sum(Q, Y, OTHER_SXY)&gt](K1, OTHER_K1)(equal_K1)(other_sum_SXY);
			equal_SXY = natural_sum_unique(K1, Y, SXY, OTHER_SXY)(sum_SXY, other_sum_SXY);
			successor_SXY = equality_consistency[&ltQ: is_successor(P_SXY, Q)&gt](SXY, OTHER_SXY)(equal_SXY)(other_successor_SXY);

			<b style="color: blue">extract </b>natural_sum(P_SXY, Z)(P_SXY_in_NATURALS, Z_in_NATURALS)|P_S|: P_S_in_NATURALS, sum_P_S;
			<b style="color: blue">extract </b>natural_sum_successor_recursion(P_SXY, Z, P_S)(sum_P_S)|OTHER_SXY_2, OTHER_S|: other_successor_SXY, other_successor_S, other_sum_S;
			equal_SXY = successor_unique(P_SXY, SXY, OTHER_SXY_2)(successor_SXY, other_successor_SXY);
			other_sum_S = equality_consistency[&ltQ: is_natural_sum(Q, Z, OTHER_S)&gt](SXY, OTHER_SXY_2)(equal_SXY)(other_sum_S);
			equal_S = natural_sum_unique(SXY, Z, S, OTHER_S)(sum_S, other_sum_S);
			successor_S = equality_consistency[&ltQ: is_successor(P_S, Q)&gt](S, OTHER_S)(equal_S)(other_successor_S);

			sum_P_S = K_condition(Y, Z, P_S, P_SXY, SYZ)(sum_P_SXY, sum_P_S, sum_SYZ);

			<b style="color: blue">extract </b>natural_sum_successor_recursion(K, SYZ, P_S)(sum_P_S)|OTHER_K1_2, OTHER_S_2|: other_successor_K1, other_successor_S, other_sum_S;
			equal_K1 = successor_unique(K, K1, OTHER_K1_2)(successor_K1, other_successor_K1);
			other_sum_S = equality_consistency[&ltQ: is_natural_sum(Q, SYZ, OTHER_S_2)&gt](K1, OTHER_K1_2)(equal_K1)(other_sum_S);
			equal_S = successor_unique(P_S, S, OTHER_S_2)(successor_S, other_successor_S);
			<b style="color: blue">return </b>equality_consistency[&ltQ: is_natural_sum(K1, SYZ, Q)&gt](S, OTHER_S_2)(equal_S)(other_sum_S);
		}
		<b style="color: blue">return </b>R_def(K1)(K1_in_NATURALS, K1_in_R);
	}
	NATURALS_subset_R = NATURALS_induction(R)(ZERO_in_R, closure_R);
	<b style="color: blue">given </b>|X, Y, Z, S, SXY, SYZ|;
	<b style="color: blue">implies </b>sum_SXY, sum_S, sum_SYZ;
	<b style="color: blue">extract </b>expand(sum_SXY): X_in_NATURALS, Y_in_NATURALS, tuple_exists;
	X_in_R = expand(NATURALS_subset_R)(X)(X_in_NATURALS);
	<b style="color: blue">extract </b>R_def(X)(X_in_R): X_in_NATURALS, result;
	<b style="color: blue">return </b>result(Y, Z, S, SXY, SYZ)(sum_SXY, sum_S, sum_SYZ);
}

//Prove associativity in the other direction
//We can actually just use the previous proof and commutativity. Watch!
<b style="color: blue">prove </b>natural_sum_associative2: *X*Y*Z*S*SXY*SYZ(is_natural_sum(Y, Z, SYZ) & is_natural_sum(X, SYZ, S) & is_natural_sum(X, Y, SXY) -&gt is_natural_sum(SXY, Z, S)){
	<b style="color: blue">given </b>|X, Y, Z, S, SXY, SYZ|;
	<b style="color: blue">implies </b>sum_SYZ, sum_S, sum_SXY;
	sum_S = natural_sum_commutative(X, SYZ, S)(sum_S);
	sum_SYZ = natural_sum_commutative(Y, Z, SYZ)(sum_SYZ);
	sum_SXY = natural_sum_commutative(X, Y, SXY)(sum_SXY);
	sum_S = natural_sum_associative(Z, Y, X, S, SYZ, SXY)(sum_SYZ, sum_S, sum_SXY);
	<b style="color: blue">return </b>natural_sum_commutative(Z, SXY, S)(sum_S);
}

//Prove the cancellation property of addition
//This is exciting!
<b style="color: blue">prove </b>natural_sum_cancellation: *X*Y*Z*S(is_natural_sum(X, Y, S) & is_natural_sum(X, Z, S) -&gt equal_sets(Y, Z)){
	<b style="color: blue">extract </b>expand(NATURALS_inductive): empty_in_NATURALS, closure_naturals;
	//We use induction here :)
	R_def = axiom_specify[&ltQ: *Y*Z*S(is_natural_sum(Q, Y, S) & is_natural_sum(Q, Z, S) -&gt equal_sets(Y, Z))&gt](NATURALS)|R|;

	<b style="color: blue">prove </b>ZERO_in_R: *Y*Z*S(is_natural_sum(ZERO, Y, S) & is_natural_sum(ZERO, Z, S) -&gt equal_sets(Y, Z)){
		<b style="color: blue">given </b>|Y, Z, S|;
		<b style="color: blue">implies </b>sum0, sum1;
		<b style="color: blue">extract </b>expand(sum0): ZERO_in_NATURALS, Y_in_NATURALS, tuple_exists;
		<b style="color: blue">extract </b>expand(sum1): ZERO_in_NATURALS, Z_in_NATURALS, tuple_exists;
		sum_Y = natural_sum_zero_identity(Y)(Y_in_NATURALS);
		equal_YS = natural_sum_unique(ZERO, Y, Y, S)(sum_Y, sum0);
		sum_Z = natural_sum_zero_identity(Z)(Z_in_NATURALS);
		equal_ZS = natural_sum_unique(ZERO, Z, Z, S)(sum_Z, sum1);
		<b style="color: blue">return </b>equality_consistency[&ltQ: equal_sets(Y, Q)&gt](Z, S)(equal_ZS)(equal_YS);
	}

	ZERO_in_R = R_def(ZERO)(zero_is_natural, ZERO_in_R);

	<b style="color: blue">prove </b>closure_R: *S*S1(S in R & is_successor(S, S1) -&gt S1 in R){
		<b style="color: blue">given </b>|S, S1|;
		<b style="color: blue">implies </b>S_in_R, successor_S1;
		<b style="color: blue">extract </b>R_def(S)(S_in_R): S_in_NATURALS, S_condition;
		S1_in_NATURALS = closure_naturals(S, S1)(S_in_NATURALS, successor_S1);
		<b style="color: blue">prove </b>S1_condition: *Y*Z*SUM(is_natural_sum(S1, Y, SUM) & is_natural_sum(S1, Z, SUM) -&gt equal_sets(Y, Z)){
			<b style="color: blue">given </b>|Y, Z, SUM|;
			<b style="color: blue">implies </b>sum_S1_Y, sum_S1_Z;
			<b style="color: blue">extract </b>expand(sum_S1_Y): S1_in_NATURALS, Y_in_NATURALS, tuple_exists;
			<b style="color: blue">extract </b>expand(sum_S1_Z): S1_in_NATURALS, Z_in_NATURALS, tuple_exists;
			<b style="color: blue">extract </b>natural_sum(S, Y)(S_in_NATURALS, Y_in_NATURALS)|P_SUM_Y|: P_SUM_Y_in_NATURALS, sum_P_Y;
			<b style="color: blue">extract </b>natural_sum(S, Z)(S_in_NATURALS, Z_in_NATURALS)|P_SUM_Z|: P_SUM_Z_in_NATURALS, sum_P_Z;

			<b style="color: blue">extract </b>natural_sum_successor_recursion(S, Y, P_SUM_Y)(sum_P_Y)|OTHER_S1, SUM_Y|: other_successor_S1, predecessor_P_SUM_Y, other_sum_S1_Y;
			equal_S1 = successor_unique(S, S1, OTHER_S1)(successor_S1, other_successor_S1);
			other_sum_S1_Y = equality_consistency[&ltQ: is_natural_sum(Q, Y, SUM_Y)&gt](S1, OTHER_S1)(equal_S1)(other_sum_S1_Y);
			equal_SUM_Y = natural_sum_unique(S1, Y, SUM, SUM_Y)(sum_S1_Y, other_sum_S1_Y);
			predecessor_P_SUM_Y = equality_consistency[&ltQ: is_successor(P_SUM_Y, Q)&gt](SUM, SUM_Y)(equal_SUM_Y)(predecessor_P_SUM_Y);

			<b style="color: blue">extract </b>natural_sum_successor_recursion(S, Z, P_SUM_Z)(sum_P_Z)|OTHER_S1_2, SUM_Z|: other_successor_S1, predecessor_P_SUM_Z, other_sum_S1_Z;
			equal_S1 = successor_unique(S, S1, OTHER_S1_2)(successor_S1, other_successor_S1);
			other_sum_S1_Z = equality_consistency[&ltQ: is_natural_sum(Q, Z, SUM_Z)&gt](S1, OTHER_S1_2)(equal_S1)(other_sum_S1_Z);
			equal_SUM_Z = natural_sum_unique(S1, Z, SUM, SUM_Z)(sum_S1_Z, other_sum_S1_Z);
			predecessor_P_SUM_Z = equality_consistency[&ltQ: is_successor(P_SUM_Z, Q)&gt](SUM, SUM_Z)(equal_SUM_Z)(predecessor_P_SUM_Z);

			equal_P_SUM = predecessor_unique(P_SUM_Y, P_SUM_Z, SUM)(predecessor_P_SUM_Y, predecessor_P_SUM_Z);
			sum_P_Z = equality_consistency[&ltQ: is_natural_sum(S, Z, Q)&gt](P_SUM_Y, P_SUM_Z)(equal_P_SUM)(sum_P_Z);
			<b style="color: blue">return </b>S_condition(Y, Z, P_SUM_Y)(sum_P_Y, sum_P_Z);
		}
		<b style="color: blue">return </b>R_def(S1)(S1_in_NATURALS, S1_condition);
	}

	NATURALS_subset_R = NATURALS_induction(R)(ZERO_in_R, closure_R);
	<b style="color: blue">given </b>|X, Y, Z, S|;
	<b style="color: blue">implies </b>sum0, sum1;
	<b style="color: blue">extract </b>expand(sum0): X_in_NATURALS, Y_in_NATURALS, tuple_exists;
	X_in_R = expand(NATURALS_subset_R)(X)(X_in_NATURALS);
	<b style="color: blue">extract </b>R_def(X)(X_in_R): X_in_NATURALS, result;
	<b style="color: blue">return </b>result(Y, Z, S)(sum0, sum1);
}

//Prove that 1+n = S(n)
<b style="color: blue">prove </b>natural_sum_successor: *N*M(is_natural_sum(N, ONE, M) -&gt is_successor(N, M)){
	<b style="color: blue">extract </b>expand(NATURALS_inductive): empty_in_NATURALS, closure_naturals;
	R_def = axiom_specify[&ltQ: *M(is_natural_sum(Q, ONE, M) -&gt is_successor(Q, M))&gt](NATURALS)|R|;

	<b style="color: blue">prove </b>ZERO_in_R: *M(is_natural_sum(ZERO, ONE, M) -&gt is_successor(ZERO, M)){
		<b style="color: blue">given </b>|M|;
		<b style="color: blue">implies </b>sum_M;
		other_sum_M = natural_sum_zero_identity(ONE)(one_is_natural);
		equal_M_ONE = natural_sum_unique(ZERO, ONE, M, ONE)(sum_M, other_sum_M);
		<b style="color: blue">return </b>equality_consistency[&ltQ: is_successor(ZERO, Q)&gt](M, ONE)(equal_M_ONE)(one_definition);
	}

	ZERO_in_R = R_def(ZERO)(zero_is_natural, ZERO_in_R);

	<b style="color: blue">prove </b>closure_R: *K*N(K in R & is_successor(K, N) -&gt N in R){
		<b style="color: blue">given </b>|K, N|;
		<b style="color: blue">implies </b>K_in_R, successor_N;
		<b style="color: blue">extract </b>R_def(K)(K_in_R): K_in_NATURALS, K_cond;
		N_in_NATURALS = closure_naturals(K, N)(K_in_NATURALS, successor_N);
		<b style="color: blue">extract </b>natural_sum(K, ONE)(K_in_NATURALS, one_is_natural)|OTHER_N|: OTHER_N_in_NATURALS, sum_OTHER_N;
		successor_other_N = K_cond(OTHER_N)(sum_OTHER_N);
		equal_N = successor_unique(K, N, OTHER_N)(successor_N, successor_other_N);
		sum_N = equality_consistency[&ltQ: is_natural_sum(K, ONE, Q)&gt](N, OTHER_N)(equal_N)(sum_OTHER_N);
		<b style="color: blue">extract </b>natural_sum_successor_recursion(K, ONE, N)(sum_N)|OTHER_N2, M|: successor_other_N2, successor_M, sum_M;
		equal_N = successor_unique(K, N, OTHER_N2)(successor_N, successor_other_N2);
		sum_M = equality_consistency[&ltQ: is_natural_sum(Q, ONE, M)&gt](N, OTHER_N2)(equal_N)(sum_M);
		<b style="color: blue">prove </b>N_cond: *M_OTHER(is_natural_sum(N, ONE, M_OTHER) -&gt is_successor(N, M_OTHER)){
			<b style="color: blue">given </b>|M_OTHER|;
			<b style="color: blue">implies </b>other_sum_M;
			equal_M = natural_sum_unique(N, ONE, M, M_OTHER)(sum_M, other_sum_M);
			<b style="color: blue">return </b>equality_consistency[&ltQ: is_successor(N, Q)&gt](M, M_OTHER)(equal_M)(successor_M);
		}
		<b style="color: blue">return </b>R_def(N)(N_in_NATURALS, N_cond);
	}
	NATURALS_subset_R = NATURALS_induction(R)(ZERO_in_R, closure_R);

	<b style="color: blue">given </b>|N, M|;
	<b style="color: blue">implies </b>sum_M;
	<b style="color: blue">extract </b>expand(sum_M): N_in_NATURALS, ONE_in_NATURALS, tuple_exists;
	N_in_R = expand(NATURALS_subset_R)(N)(N_in_NATURALS);
	<b style="color: blue">extract </b>R_def(N)(N_in_R): N_in_NATURALS, result;

	<b style="color: blue">return </b>result(M)(sum_M);
}

//Proving that if a &lt= b then there exists some n &lt= b such that a + n = b
<b style="color: blue">prove </b>natural_sum_less_than: *A*B(A in NATURALS & B in NATURALS & NATURAL_less_than(A, B) &lt-&gt ^N(is_natural_sum(A, N, B))){
	<b style="color: blue">extract </b>expand(NATURALS_inductive): empty_in_NATURALS, closure_naturals;


}
</code></div></body></html>