<!DOCTYPE html><html><head><title>file</title></head><body><div class="header">CORE Source</div><div class="CORE_source"><code style="white-space: pre-wrap;">//A few logical axioms first
<b style="color: blue">axiom </b>axiom_absurdity[P]: false -&gt P;
<b style="color: blue">axiom </b>axiom_true: true;
<b style="color: blue">axiom </b>axiom_excluded_middle[P]: P | ~P;

//ZF in CORE (biconditional revision)

<b style="color: blue">define </b>equal_sets(A, B): *X(X in A &lt-&gt X in B);
<b style="color: blue">define </b>is_subset(A, B): *X(X in A -&gt X in B);
<b style="color: blue">define </b>not_empty(A): ^X(X in A);
<b style="color: blue">define </b>is_empty(A): *X(~X in A);
<b style="color: blue">define </b>disjoint_sets(A, B): *X(X in A -&gt ~X in B);

<b style="color: blue">axiom </b>equality_consistency[P(1)]: *X*Y(equal_sets(X, Y) -&gt (P(X) &lt-&gt P(Y)));

<b style="color: blue">prove </b>equal_sets_reflexive: *A(equal_sets(A, A)){
	<b style="color: blue">given </b>|A|;
	<b style="color: blue">prove </b>equal_sets_def: *X(X in A &lt-&gt X in A){
		<b style="color: blue">given </b>|X|;
		<b style="color: blue">prove </b>lemma: X in A -&gt X in A{
			<b style="color: blue">implies </b>X_in_A;
			<b style="color: blue">return </b>X_in_A;
		}
		<b style="color: blue">return </b>iff(lemma, lemma);
	}
	<b style="color: blue">return </b>#equal_sets(A, A)(equal_sets_def);
}

<b style="color: blue">prove </b>equal_sets_symmetric: *A*B(equal_sets(A, B) -&gt equal_sets(B, A)){
	<b style="color: blue">given </b>|A, B|;
	<b style="color: blue">implies </b>equal_AB;
	<b style="color: blue">prove </b>def: *X(X in B &lt-&gt X in A){
		<b style="color: blue">given </b>|X|;
		<b style="color: blue">return </b>expand(equal_AB)(X);
	}
	<b style="color: blue">return </b>#equal_sets(B, A)(def);
}

<b style="color: blue">prove </b>equal_sets_transitive: *A*B*C(equal_sets(A, B) & equal_sets(B, C) -&gt equal_sets(A, C)){
	<b style="color: blue">given </b>|A, B, C|;
	<b style="color: blue">implies </b>equals_both;
	<b style="color: blue">extract </b>equals_both: equal_AB, equal_BC;
	<b style="color: blue">return </b>equality_consistency[&ltX: equal_sets(X, C)&gt](B, A)(equal_sets_symmetric(A, B)(equal_AB))(equal_BC);
}

//We <b style="color: blue">prove </b>the "axiom" using equality consistency, which is just a more useful form of this <b style="color: blue">axiom </b>for my purposes
<b style="color: blue">prove </b>axiom_extensionality: *A*B(equal_sets(A, B) -&gt *W(A in W &lt-&gt B in W)){
	<b style="color: blue">given </b>|A, B|;
	<b style="color: blue">implies </b>equal_AB;
	<b style="color: blue">given </b>|W|;
	<b style="color: blue">return </b>equality_consistency[&ltX: X in W&gt](A, B)(equal_AB);
}

<b style="color: blue">axiom </b>axiom_regularity: *A(not_empty(A) -&gt ^B(B in A & *C(~C in B | ~C in A)));

<b style="color: blue">axiom </b>axiom_specify[P(1)]: *A^B*X(X in B &lt-&gt X in A & P(X));

<b style="color: blue">axiom </b>axiom_pairing: *A*B^C(A in C & B in C);

<b style="color: blue">axiom </b>axiom_union: *F^A*Y*X((Y in F & X in Y) -&gt X in A);

<b style="color: blue">axiom </b>axiom_replacement[P(3)]: *A(*X(X in A -&gt ^Y(P(X, Y, A) & *Z(P(X, Z, A) -&gt equal_sets(Y, Z)))) -&gt ^B*Y((Y in B -&gt ^X(X in A & P(X, Y, A))) & (^X(X in A & P(X, Y, A)) -&gt Y in B)));

<b style="color: blue">define </b>is_pair(A, B, C): *X(X in C &lt-&gt equal_sets(X, A) | equal_sets(X, B));

<b style="color: blue">prove </b>definition_uniqueness_lemma[P(1)]: *A*B(*X(X in A &lt-&gt P(X)) & *X(X in B &lt-&gt P(X)) -&gt equal_sets(A, B)){
	<b style="color: blue">given </b>|A, B|;
	<b style="color: blue">implies </b>equality_condition;
	<b style="color: blue">extract </b>equality_condition: membership_A, membership_B;
	<b style="color: blue">prove </b>equal_def: *X(X in A &lt-&gt X in B){
		<b style="color: blue">given </b>|X|;
		<b style="color: blue">prove </b>lemma0: X in A -&gt X in B{
			<b style="color: blue">implies </b>X_in_A;
			<b style="color: blue">return </b>membership_B(X)(membership_A(X)(X_in_A));
		}
		<b style="color: blue">prove </b>lemma1: X in B -&gt X in A{
			<b style="color: blue">implies </b>X_in_B;
			<b style="color: blue">return </b>membership_A(X)(membership_B(X)(X_in_B));
		}
		<b style="color: blue">return </b>iff(lemma0, lemma1);
	}
	<b style="color: blue">return </b>#equal_sets(A, B)(equal_def);
}

<b style="color: blue">prove </b>pair: *A*B^C(is_pair(A, B, C)){
	<b style="color: blue">given </b>|A, B|;
	<b style="color: blue">extract </b>axiom_pairing(A, B)|D|: A_in_D, B_in_D;
	C_specified = axiom_specify[&ltX: equal_sets(X, A) | equal_sets(X, B)&gt](D)|C|;
	<b style="color: blue">choose </b>C;
	<b style="color: blue">prove </b>pair_def: *X(X in C &lt-&gt equal_sets(X, A) | equal_sets(X, B)){
		<b style="color: blue">given </b>|X|;
		<b style="color: blue">prove </b>lemma0: X in C -&gt equal_sets(X, A) | equal_sets(X, B){
			<b style="color: blue">implies </b>X_in_C;
			<b style="color: blue">extract </b>C_specified(X)(X_in_C): X_in_D, result;
			<b style="color: blue">return </b>result;
		}
		<b style="color: blue">prove </b>lemma1: equal_sets(X, A) | equal_sets(X, B) -&gt X in C{
			<b style="color: blue">implies </b>equals_or;
			X_in_D = branch(equals_or, equal_XA, equal_XB){
				<b style="color: blue">return </b>equality_consistency[&ltZ: Z in D&gt](X, A)(equal_XA)(A_in_D);
			} or {
				<b style="color: blue">return </b>equality_consistency[&ltZ: Z in D&gt](X, B)(equal_XB)(B_in_D);
			};
			<b style="color: blue">return </b>C_specified(X)(X_in_D, equals_or);
		}
		<b style="color: blue">return </b>iff(lemma0, lemma1);
	}
	<b style="color: blue">return </b>#is_pair(A, B, C)(pair_def);
}

<b style="color: blue">prove </b>pair_unique: *A*B*C*D(is_pair(A, B, C) & is_pair(A, B, D) -&gt equal_sets(C, D)){
	<b style="color: blue">given </b>|A, B, C, D|;
	<b style="color: blue">implies </b>pairs_premise;
	<b style="color: blue">extract </b>pairs_premise: pair_C, pair_D;
	<b style="color: blue">return </b>definition_uniqueness_lemma[&ltX: equal_sets(X, A) | equal_sets(X, B)&gt](C, D)(expand(pair_C), expand(pair_D));
}

<b style="color: blue">define </b>is_union(A, B): *X(X in B &lt-&gt ^Y(Y in A & X in Y));

<b style="color: blue">prove </b>union: *A^B(is_union(A, B)){
	<b style="color: blue">given </b>|A|;
	implies_in_NEW = axiom_union(A)|NEW|;
	specified = axiom_specify[&ltX: ^Y(Y in A & X in Y)&gt](NEW)|B|;
	<b style="color: blue">choose </b>B;
	<b style="color: blue">prove </b>union_def: *X(X in B &lt-&gt ^Y(Y in A & X in Y)){
		<b style="color: blue">given </b>|X|;
		<b style="color: blue">prove </b>lemma0: X in B -&gt ^Y(Y in A & X in Y){
			<b style="color: blue">implies </b>X_in_B;
			<b style="color: blue">extract </b>specified(X)(X_in_B): X_in_NEW, result;
			<b style="color: blue">return </b>result;
		}
		<b style="color: blue">prove </b>lemma1: ^Y(Y in A & X in Y) -&gt X in B{
			<b style="color: blue">implies </b>exists_condition;
			condition_Y = exists_condition|Y|;
			X_in_NEW = implies_in_NEW(Y, X)(condition_Y);
			<b style="color: blue">return </b>specified(X)(X_in_NEW, exists_condition);
		}
		<b style="color: blue">return </b>iff(lemma0, lemma1);
	}
	<b style="color: blue">return </b>#is_union(A, B)(union_def);
}

<b style="color: blue">prove </b>union_unique: *A*B*C(is_union(A, B) & is_union(A, C) -&gt equal_sets(B, C)){
	<b style="color: blue">given </b>|A, B, C|;
	<b style="color: blue">implies </b>union_both;
	<b style="color: blue">extract </b>union_both: union_B, union_C;
	<b style="color: blue">return </b>definition_uniqueness_lemma[&ltX: ^Y(Y in A & X in Y)&gt](B, C)(expand(union_B), expand(union_C));
}

<b style="color: blue">define </b>is_successor(A, B): *X(X in B &lt-&gt X in A | equal_sets(X, A));

<b style="color: blue">prove </b>successor: *A^B(is_successor(A, B)){
	<b style="color: blue">given </b>|A|;
	pair_AA = pair(A, A)|C|;
	pair_AC = pair(A, C)|D|;
	union_B = union(D)|B|;
	<b style="color: blue">choose </b>B;
	<b style="color: blue">prove </b>successor_def: *X(X in B &lt-&gt X in A | equal_sets(X, A)){
		<b style="color: blue">given </b>|X|;
		<b style="color: blue">prove </b>lemma0: X in B -&gt X in A | equal_sets(X, A){
			<b style="color: blue">implies </b>X_in_B;
			<b style="color: blue">extract </b>expand(union_B)(X)(X_in_B)|Y|: Y_in_D, X_in_Y;
			equal_A_or_C = expand(pair_AC)(Y)(Y_in_D);
			<b style="color: blue">return </b>branch(equal_A_or_C, equal_A, equal_C){
				X_in_A = equality_consistency[&ltS: X in S&gt](Y, A)(equal_A)(X_in_Y);
				<b style="color: blue">return </b>or(X_in_A, &lt:equal_sets(X, A)&gt);
			} or {
				X_in_C = equality_consistency[&ltS: X in S&gt](Y, C)(equal_C)(X_in_Y);
				equal_A_or = expand(pair_AA)(X)(X_in_C);
				equal_A = branch(equal_A_or, equal_A, equal_A){<b style="color: blue">return </b>equal_A;} or {<b style="color: blue">return </b>equal_A;};
				<b style="color: blue">return </b>or(&lt:X in A&gt, equal_A);
			};
		}
		<b style="color: blue">prove </b>lemma1: X in A | equal_sets(X, A) -&gt X in B{
			<b style="color: blue">implies </b>premise;
			<b style="color: blue">return </b>branch(premise, X_in_A, equal_XA){
				<b style="color: blue">prove </b>union_def: ^Y(Y in D & X in Y){
					<b style="color: blue">choose </b>A;
					<b style="color: blue">return </b>expand(pair_AC)(A)(or(equal_sets_reflexive(A), &lt:equal_sets(A, C)&gt)), X_in_A;
				}
				<b style="color: blue">return </b>expand(union_B)(X)(union_def);
			} or {
				X_in_C = expand(pair_AA)(X)(or(equal_XA, equal_XA));
				<b style="color: blue">prove </b>union_def: ^Y(Y in D & X in Y){
					<b style="color: blue">choose </b>C;
					<b style="color: blue">return </b>expand(pair_AC)(C)(or(&lt:equal_sets(C, A)&gt, equal_sets_reflexive(C))), X_in_C;
				}
				<b style="color: blue">return </b>expand(union_B)(X)(union_def);
			};
		}
		<b style="color: blue">return </b>iff(lemma0, lemma1);
	}
	<b style="color: blue">return </b>#is_successor(A, B)(successor_def);
}

<b style="color: blue">prove </b>successor_unique: *A*B*C(is_successor(A, B) & is_successor(A, C) -&gt equal_sets(B, C)){
	<b style="color: blue">given </b>|A, B, C|;
	<b style="color: blue">implies </b>successor_both;
	<b style="color: blue">extract </b>successor_both: successor_B, successor_C;
	<b style="color: blue">return </b>definition_uniqueness_lemma[&ltX: X in A | equal_sets(X, A)&gt](B, C)(expand(successor_B), expand(successor_C));
}

//One of the rare moments when we use the <b style="color: blue">axiom </b>of regularity
<b style="color: blue">prove </b>no_pair_recursive_membership: *A*B(~A in B | ~B in A){
	<b style="color: blue">given </b>|A, B|;
	PAIR_AB_def = expand(pair(A, B)|PAIR_AB|);
	<b style="color: blue">prove </b>PAIR_AB_not_empty: ^A(A in PAIR_AB){
		<b style="color: blue">choose </b>A;
		<b style="color: blue">return </b>PAIR_AB_def(A)(or(equal_sets_reflexive(A), &lt:equal_sets(A, B)&gt));
	}
	PAIR_AB_not_empty = #not_empty(PAIR_AB)(PAIR_AB_not_empty);
	<b style="color: blue">extract </b>axiom_regularity(PAIR_AB)(PAIR_AB_not_empty)|D|: D_in_PAIR_AB, disjoint;
	<b style="color: blue">return </b>branch(PAIR_AB_def(D)(D_in_PAIR_AB), equal_D_A, equal_D_B){
		<b style="color: blue">return </b>branch(disjoint(B), not_B_in_D, not_B_in_PAIR_AB){
			not_B_in_A = equality_consistency[&ltQ: ~B in Q&gt](D, A)(equal_D_A)(not_B_in_D);
			<b style="color: blue">return </b>or(&lt:~A in B&gt, not_B_in_A);
		} or {
			B_in_PAIR_AB = PAIR_AB_def(B)(or(&lt:equal_sets(B, A)&gt, equal_sets_reflexive(B)));
			absurdity = not_B_in_PAIR_AB(B_in_PAIR_AB);
			<b style="color: blue">return </b>axiom_absurdity[goal](absurdity);
		};
	} or {
		<b style="color: blue">return </b>branch(disjoint(A), not_A_in_D, not_A_in_PAIR_AB){
			not_A_in_B = equality_consistency[&ltQ: ~A in Q&gt](D, B)(equal_D_B)(not_A_in_D);
			<b style="color: blue">return </b>or(not_A_in_B, &lt:~B in A&gt);
		} or {
			A_in_PAIR_AB = PAIR_AB_def(A)(or(equal_sets_reflexive(A), &lt:equal_sets(A, B)&gt));
			absurdity = not_A_in_PAIR_AB(A_in_PAIR_AB);
			<b style="color: blue">return </b>axiom_absurdity[goal](absurdity);
		};
	};
}

<b style="color: blue">define </b>is_inductive_set(X): ^E(E in X & is_empty(E)) & *Y*Z(Y in X & is_successor(Y, Z) -&gt Z in X);

<b style="color: blue">axiom </b>axiom_infinity: ^X(is_inductive_set(X));

<b style="color: blue">axiom </b>axiom_power_set: *X^Y*Z(is_subset(Z, X) -&gt Z in Y);

//These are all of the ZF axioms

//Finally, I want to show that the inverse of the <b style="color: blue">axiom </b>of extensionality can also be proven
<b style="color: blue">prove </b>axiom_extensionality_inverse: *A*B(*W(A in W &lt-&gt B in W) -&gt equal_sets(A, B)){
	<b style="color: blue">given </b>|A, B|;
	<b style="color: blue">implies </b>premise;
	pair_U = expand(pair(B, B)|U|);
	B_in_U = pair_U(B)(or(equal_sets_reflexive(B), equal_sets_reflexive(B)));
	A_in_U = premise(U)(B_in_U);
	<b style="color: blue">return </b>branch(pair_U(A)(A_in_U), equal_A_B, equal_A_B){
		<b style="color: blue">return </b>equal_A_B;
	} or {
		<b style="color: blue">return </b>equal_A_B;
	};
}

</code></div></body></html>