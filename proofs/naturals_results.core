object ONE;
object TWO;
object THREE;
object FOUR;

axiom predecessor: *M(M in NATURALS & ~M = ZERO -> ^N(N in NATURALS & successor(M, N)));
axiom predecessor_natural: *N*M(M in NATURALS & successor(M, N) -> N in NATURALS);
axiom recursion: *F*D*S(function(F) & domain(D, F) & codomain(D, F) & S in D -> ^G(function(G) & domain(NATURALS, G) & codomain(D, G) & *X(related(ZERO, X, G) <-> X = S) & *N*M*Y(successor(M, N) & related(M, Y, G) -> ^X(related(N, X, G) & related(X, Y, F)))));
dependent define sum(A, B, C);
axiom sum: *A*B(A in NATURALS & B in NATURALS -> ^C(sum(C, A, B)));
axiom sum_unique: *A*B*C*D(sum(C, A, B) & sum(D, A, B) -> C = D);
axiom sum_zero: *A(A in NATURALS -> sum(A, A, ZERO));
axiom sum_recursion: *A*B*C*D*E(successor(C, B) & sum(D, A, B) & sum(E, A, C) -> successor(E, D));
axiom sum_natural: *A*B*C(sum(A, B, C) -> A in NATURALS);
axiom sum_zero2: *A(A in NATURALS -> sum(A, ZERO, A));
axiom sum_recursion2: *A*B*C*D*E(successor(B, A) & sum(D, A, C) & sum(E, B, C) -> successor(E, D));
axiom sum_commutes: *A*B*C(sum(A, B, C) -> sum(A, C, B));
axiom sum_operand_natural: *A*B*C(sum(C, A, B) -> A in NATURALS & B in NATURALS);
axiom sum_zero_identity: *A*B(sum(B, A, ZERO) | sum(B, ZERO, A) -> A = B);
axiom sum_associates: *A*B*C*D*E*F(sum(D, A, B) & sum(F, D, C) & sum(E, B, C) -> sum(F, A, E));
dependent relation A < B: A in NATURALS & B in NATURALS & *C(~sum(A, B, C));
axiom lt_successor: *A*B*C(A < B & successor(C, B) -> A < C);
axiom zero_minimal: *N(N in NATURALS -> N = ZERO | ZERO < N);
dependent relation A leq B: A in NATURALS & B in NATURALS & ^C(sum(B, A, C));
axiom leq_reflexive: *A(A in NATURALS -> A leq A);
axiom lt_alternative: *A*B(A in NATURALS & B in NATURALS -> A < B | B leq A);
axiom lt_leq_exclusive: *A*B(~(A < B & B leq A));
axiom leq_cancellation: *A*B*C*D(successor(A, C) & successor(B, D) & A leq B -> C leq D);
axiom lt_successor_both: *A*B*C*D(successor(B, A) & successor(D, C) & A < C -> B < D);
axiom leq_to_lt_or_eq: *A*B(A leq B -> A = B | A < B);
axiom lt_trichotomy: *A*B(A in NATURALS & B in NATURALS -> A < B | B < A | A = B);
axiom lt_predecessor_both: *A*B*C*D(successor(B, A) & successor(D, C) & B < D -> A < C);
axiom lt_successor_cancel: *A*B*C*D(successor(B, A) & successor(D, C) -> (A < C <-> B < D));
axiom zero_not_greater: *A(~A < ZERO);
axiom greater_than_zero: *A*B(A < B -> ZERO < B);
axiom lt_transitive: *A*B*C(A < B & B < C -> A < C);
axiom lt_sum_cancel: *A*B*C*SA*SB(sum(SA, A, C) & sum(SB, B, C) -> (A < B <-> SA < SB));
axiom sum_cancel: *A*B*C*S(sum(S, A, C) & sum(S, B, C) -> A = B);
axiom sum_combine: *A*B*C*D*E*F(sum(A, D, E) & sum(B, D, F) & sum(F, E, C) -> sum(B, A, C));
dependent define product(A, B, C);
axiom product: *A*B(A in NATURALS & B in NATURALS -> ^C(product(C, A, B)));
axiom product_unique: *A*B*C*D(product(C, A, B) & product(D, A, B) -> C = D);
axiom product_operand_natural: *A*B*C(product(C, A, B) -> A in NATURALS & B in NATURALS);
axiom product_zero: *A(A in NATURALS -> product(ZERO, A, ZERO));
axiom product_recursion: *A*B*C*D*E(successor(C, B) & product(D, A, B) & product(E, A, C) -> sum(E, D, A));
axiom product_natural: *A*B*C(product(A, B, C) -> A in NATURALS);
axiom product_zero2: *A(A in NATURALS -> product(ZERO, ZERO, A));
axiom product_recursion2: *A*B*C*D*E(successor(B, A) & product(D, A, C) & product(E, B, C) -> sum(E, D, C));
axiom product_commutes: *A*B*C(product(A, B, C) -> product(A, C, B));
axiom product_distribues: *A*B*C*D*E*F*G(product(D, A, B) & product(E, A, C) & sum(F, B, C) & product(G, A, F) -> sum(G, D, E));
axiom product_associates: *A*B*C*D*E*F(product(D, A, B) & product(F, D, C) & product(E, B, C) -> product(F, A, E));
