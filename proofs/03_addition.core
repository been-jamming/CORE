define is_natural_numbers(N): *X(X in N <-> *I(is_inductive_set(I) -> X in I));

prove natural_numbers_exist: ^N(is_natural_numbers(N)){
	is_inductive = axiom_infinity|INDUCTIVE_SET|;
	specified = axiom_specify[<X: *I(is_inductive_set(I) -> X in I)>](INDUCTIVE_SET)|N|;
	choose N;
	prove natural_numbers_def: *X(X in N <-> *I(is_inductive_set(I) -> X in I)){
		given |X|;
		prove lemma0: X in N -> *I(is_inductive_set(I) -> X in I){
			implies X_in_N;
			X_in_INDUCTIVE_SET, result = specified(X)(X_in_N);
			return result;
		}
		prove lemma1: *I(is_inductive_set(I) -> X in I) -> X in N{
			implies in_all_inductive;
			X_in_INDUCTIVE_SET = in_all_inductive(INDUCTIVE_SET)(is_inductive);
			return specified(X)(X_in_INDUCTIVE_SET, in_all_inductive);
		}
		return iff(lemma0, lemma1);
	}
	return #is_natural_numbers(N)(natural_numbers_def);
}

prove natural_numbers_unique: *N*M(is_natural_numbers(N) & is_natural_numbers(M) -> equal_sets(N, M)){
	given |N, M|;
	implies natural_numbers_N, natural_numbers_M;
	return definition_uniqueness_lemma[<X: *I(is_inductive_set(I) -> X in I)>](N, M)(expand(natural_numbers_N), expand(natural_numbers_M));
}

naturals_definition = expand(natural_numbers_exist|NATURALS|);

prove NATURALS_inductive: is_inductive_set(NATURALS){
	prove lemma0: ^E(E in NATURALS & is_empty(E)){
		choose EMPTY_SET;
		empty = #is_empty(EMPTY_SET)(empty_set_condition);
		prove lemma: *I(is_inductive_set(I) -> EMPTY_SET in I){
			given |I|;
			implies is_inductive;
			empty_condition, closure = expand(is_inductive);
			empty_in, is_empty_other = empty_condition|EMPTY_OTHER|;
			empty_equal = empty_set_unique(EMPTY_OTHER, EMPTY_SET)(is_empty_other, empty);
			return equality_consistency[<X: X in I>](EMPTY_OTHER, EMPTY_SET)(empty_equal)(empty_in);
		}
		return naturals_definition(EMPTY_SET)(lemma), empty;
	}
	prove lemma1: *Y*Z(Y in NATURALS & is_successor(Y, Z) -> Z in NATURALS){
		given |Y, Z|;
		implies Y_in_NATURALS, Z_successor;
		prove lemma: *I(is_inductive_set(I) -> Z in I){
			given |I|;
			implies is_inductive;
			empty_condition, closure = expand(is_inductive);
			Y_in_I = naturals_definition(Y)(Y_in_NATURALS)(I)(is_inductive);
			return closure(Y, Z)(Y_in_I, Z_successor);
		}
		return naturals_definition(Z)(lemma);
	}
	return #is_inductive_set(NATURALS)(lemma0, lemma1);
}

prove NATURALS_contain_EMPTY_SET: EMPTY_SET in NATURALS{
	empty_in_NATURALS, NATURALS_closure = expand(NATURALS_inductive);
	EMPTY_OTHER_in_NATURALS, EMPTY_OTHER_def = empty_in_NATURALS|EMPTY_OTHER|;
	empty_EMPTY = #is_empty(EMPTY_SET)(empty_set_condition);
	EMPTY_equal = empty_set_unique(EMPTY_OTHER, EMPTY_SET)(EMPTY_OTHER_def, empty_EMPTY);
	return equality_consistency[<S: S in NATURALS>](EMPTY_OTHER, EMPTY_SET)(EMPTY_equal)(EMPTY_OTHER_in_NATURALS);
}

zero_definition = copy_set(EMPTY_SET)|ZERO|;
zero_is_natural = equality_consistency[<S: S in NATURALS>](EMPTY_SET, ZERO)(zero_definition)(NATURALS_contain_EMPTY_SET);
one_definition = successor(ZERO)|ONE|;
prove one_is_natural: ONE in NATURALS{
	empty_in_naturals, closure_naturals = expand(NATURALS_inductive);
	return closure_naturals(ZERO, ONE)(zero_is_natural, one_definition);
}
two_definition = successor(ONE)|TWO|;
prove two_is_natural: TWO in NATURALS{
	empty_in_naturals, closure_naturals = expand(NATURALS_inductive);
	return closure_naturals(ONE, TWO)(one_is_natural, two_definition);
}
three_definition = successor(TWO)|THREE|;
prove three_is_natural: THREE in NATURALS{
	empty_in_naturals, closure_naturals = expand(NATURALS_inductive);
	return closure_naturals(TWO, THREE)(two_is_natural, three_definition);
}
four_definition = successor(THREE)|FOUR|;
prove four_is_natural: FOUR in NATURALS{
	empty_in_naturals, closure_naturals = expand(NATURALS_inductive);
	return closure_naturals(THREE, FOUR)(three_is_natural, four_definition);
}

prove NATURALS_induction: *S(ZERO in S & *Y*Z(Y in S & is_successor(Y, Z) -> Z in S) -> is_subset(NATURALS, S)){
	given |S|;
	implies ZERO_in_S, closure;
	prove lemma: ^E(E in S & is_empty(E)){
		choose EMPTY_SET;
		EMPTY_SET_in_S = equality_consistency[<X: X in S>](EMPTY_SET, ZERO)(zero_definition)(ZERO_in_S);
		return EMPTY_SET_in_S, #is_empty(EMPTY_SET)(empty_set_condition);
	}
	inductive_S = #is_inductive_set(S)(lemma, closure);
	prove subset_def: *X(X in NATURALS -> X in S){
		given |X|;
		implies X_in_NATURALS;
		return naturals_definition(X)(X_in_NATURALS)(S)(inductive_S);
	}
	return #is_subset(NATURALS, S)(subset_def);
}

prove NATURALS_nonzero_successor: *N(N in NATURALS -> equal_sets(N, ZERO) | ^M(M in NATURALS & is_successor(M, N))){
	S_def = axiom_specify[<N: equal_sets(N, ZERO) | ^M(M in NATURALS & is_successor(M, N))>](NATURALS)|S|;
	ZERO_in_S = S_def(ZERO)(zero_is_natural, or(equal_sets_reflexive(ZERO), <:^M(M in NATURALS & is_successor(M, ZERO))>));
	contains_empty, NATURALS_closure = expand(NATURALS_inductive);
	prove closure: *Y*Z(Y in S & is_successor(Y, Z) -> Z in S){
		given |Y, Z|;
		implies Y_in_S, successor_Y;
		Y_in_NATURALS, condition = S_def(Y)(Y_in_S);
		Z_in_NATURALS = NATURALS_closure(Y, Z)(Y_in_NATURALS, successor_Y);
		prove lemma: ^M(M in NATURALS & is_successor(M, Z)){
			choose Y;
			return Y_in_NATURALS, successor_Y;
		}
		return S_def(Z)(Z_in_NATURALS, or(<:equal_sets(Z, ZERO)>, lemma));
	}
	NATURALS_subset_S = NATURALS_induction(S)(ZERO_in_S, closure);
	given |N|;
	implies N_in_NATURALS;
	N_in_S = expand(NATURALS_subset_S)(N)(N_in_NATURALS);
	N_in_NATURALS, result = S_def(N)(N_in_S);
	return result;
}

//We want to show that if a number has a successor, that the number is not zero (for later purposes)
prove NATURAL_successor_nonzero: *A*B(is_successor(A, B) -> ~equal_sets(B, ZERO)){
	given |A, B|;
	implies successor_B;
	not equal_B_ZERO;
	equal_B_EMPTY_SET = equality_consistency[<Q: equal_sets(B, Q)>](EMPTY_SET, ZERO)(zero_definition)(equal_B_ZERO);
	A_in_B = expand(successor_B)(A)(or(<:A in A>, equal_sets_reflexive(A)));
	A_in_EMPTY_SET = equality_consistency[<Q: A in Q>](B, EMPTY_SET)(equal_B_EMPTY_SET)(A_in_B);
	return empty_set_condition(A)(A_in_EMPTY_SET);
}

//We need to show that if the predecessor of a natural number exists, it is a natural number
prove NATURALS_predecessor_closure: *N*M(N in NATURALS & is_successor(M, N) -> M in NATURALS){
	empty_in_naturals, closure_naturals = expand(NATURALS_inductive);
	//We induct on N
	R_def = axiom_specify[<Q: *M(Q in NATURALS & is_successor(M, Q) -> M in NATURALS)>](NATURALS)|R|;
	prove ZERO_in_R: *M(ZERO in NATURALS & is_successor(M, ZERO) -> M in NATURALS){
		given |M|;
		implies ZERO_in_NATURALS, successor_ZERO;
		M_in_ZERO = expand(successor_ZERO)(M)(or(<: M in M>, equal_sets_reflexive(M)));
		M_in_EMPTY_SET = equality_consistency[<Q: M in Q>](EMPTY_SET, ZERO)(zero_definition)(M_in_ZERO);
		absurdity = empty_set_condition(M)(M_in_EMPTY_SET);
		return axiom_absurdity[goal](absurdity);
	}
	ZERO_in_R = R_def(ZERO)(zero_is_natural, ZERO_in_R);

	prove closure_R: *N*N1(N in R & is_successor(N, N1) -> N1 in R){
		given |N, N1|;
		implies N_in_R, successor_N1;
		N_in_NATURALS, N_cond = R_def(N)(N_in_R);
		N1_in_NATURALS = closure_naturals(N, N1)(N_in_NATURALS, successor_N1);
		prove N1_cond: *M(N1 in NATURALS & is_successor(M, N1) -> M in NATURALS){
			given |M|;
			implies N1_in_NATURALS, other_successor_N1;
			M_equal_N = predecessor_unique(M, N, N1)(other_successor_N1, successor_N1);
			return equality_consistency[<Q: Q in NATURALS>](M, N)(M_equal_N)(N_in_NATURALS);
		}
		return R_def(N1)(N1_in_NATURALS, N1_cond);
	}
	NATURALS_subset_R = NATURALS_induction(R)(ZERO_in_R, closure_R);
	given |N, M|;
	implies N_in_NATURALS, successor_N;
	N_in_R = expand(NATURALS_subset_R)(N)(N_in_NATURALS);
	N_in_NATURALS, result = R_def(N)(N_in_R);
	return result(M)(N_in_NATURALS, successor_N);
}

//Define an "addition function"
//It's quite a hefty definition, but it's just a stepping stone towards a better definition of addition
//It is based on the definition of addition in Peano arithmetic
define is_addition_function(F): is_function(F) & ^T(is_cross_product(NATURALS, NATURALS, T) & is_domain(F, T)) & is_codomain(F, NATURALS) & *X*Z(X in NATURALS & is_tuple(ZERO, X, Z) -> are_related(Z, X, F)) & *X*Y*T0*Z0(is_tuple(X, Y, T0) & are_related(T0, Z0, F) -> ^SX^T1^Z1(is_successor(X, SX) & is_tuple(SX, Y, T1) & are_related(T1, Z1, F) & is_successor(Z0, Z1)));

//Prove that addition exists!
//There are a lot of irrelevant results and definitions that need to be made for this proof
//So I encapsulated them inside of this very large proof
//The definition of an "addition function" characterizes the peano axioms of arithmetic
prove addition_function_exists: ^ADDITION_FUNCTION(is_addition_function(ADDITION_FUNCTION)){
	C_cross_product = cross_product(NATURALS, NATURALS)|C|;
	C_def = expand(C_cross_product);
	empty_in_naturals, closure_naturals = expand(NATURALS_inductive);
	
	//We define an "addition class" to be the inverse image of the addition function for some N.
	//However, we construct it in an alternative way, which allows us to define addition
	//Despite the recursive definition of an addition function.

	//When A is the addition class for a natural number N
	define is_addition_class(N, A): *B(B in A <-> ^C^D(is_tuple(C, D, B) & ((equal_sets(C, ZERO) & equal_sets(D, N)) | ^P^S^T(is_successor(P, C) & is_successor(D, S) & is_tuple(P, S, T) & T in A))));

	//The second lemma for this theorem is that the addition classes exist for all natural numbers
	prove addition_classes_exist: *N(N in NATURALS -> ^A(is_addition_class(N, A) & is_subset(A, C))){
		//We proceed by induction
		R_def = axiom_specify[<N: ^A(is_addition_class(N, A) & is_subset(A, C))>](NATURALS)|R|;
		//Base case
		prove ZERO_in_R: ^A(is_addition_class(ZERO, A) & is_subset(A, C)){
			A_def = axiom_specify[<S: is_tuple(ZERO, ZERO, S)>](C)|A|;
			choose A;
			prove addition_class_def: *B(B in A <-> ^C^D(is_tuple(C, D, B) & ((equal_sets(C, ZERO) & equal_sets(D, ZERO)) | ^P^S^T(is_successor(P, C) & is_successor(D, S) & is_tuple(P, S, T) & T in A)))){
				given |B|;
				prove lemma0: B in A -> ^C^D(is_tuple(C, D, B) & ((equal_sets(C, ZERO) & equal_sets(D, ZERO)) | ^P^S^T(is_successor(P, C) & is_successor(D, S) & is_tuple(P, S, T) & T in A))){
					implies B_in_A;
					B_in_C, B_tuple_ZERO_ZERO = A_def(B)(B_in_A);
					choose ZERO, ZERO;
					condition = or(and(equal_sets_reflexive(ZERO), equal_sets_reflexive(ZERO)), <:^P^S^T(is_successor(P, ZERO) & is_successor(ZERO, S) & is_tuple(P, S, T) & T in A)>);
					return B_tuple_ZERO_ZERO, condition;
				}
				prove lemma1: ^C^D(is_tuple(C, D, B) & ((equal_sets(C, ZERO) & equal_sets(D, ZERO)) | ^P^S^T(is_successor(P, C) & is_successor(D, S) & is_tuple(P, S, T) & T in A))) -> B in A{
					implies premise;
					tuple_B, either_condition = premise|C, D|;
					return branch(either_condition, equal_ZERO, predecessor){
						C_equal_ZERO, D_equal_ZERO = equal_ZERO;
						B_tuple_ZERO_D = equality_consistency[<S: is_tuple(S, D, B)>](C, ZERO)(C_equal_ZERO)(tuple_B);
						B_tuple_ZERO_ZERO = equality_consistency[<S: is_tuple(ZERO, S, B)>](D, ZERO)(D_equal_ZERO)(B_tuple_ZERO_D);
						prove cross_product_condition: ^E^F(E in NATURALS & F in NATURALS & is_tuple(E, F, B)){
							choose ZERO, ZERO;
							return zero_is_natural, zero_is_natural, B_tuple_ZERO_ZERO;
						}
						B_in_C = C_def(B)(cross_product_condition);
						return A_def(B)(B_in_C, B_tuple_ZERO_ZERO);
					} or {
						predecessor_P, successor_S, tuple_T, T_in_A = predecessor|P, S, T|;
						D_in_S = expand(successor_S)(D)(or(<:D in D>, equal_sets_reflexive(D)));
						T_in_C, tuple_ZERO_ZERO = A_def(T)(T_in_A);
						T_equal_T = equal_sets_reflexive(T);
						equal_P_ZERO, equal_S_ZERO = tuple_equal_condition(P, S, ZERO, ZERO, T, T)(tuple_T, tuple_ZERO_ZERO, T_equal_T);
						equal_S_EMPTY_SET = equal_sets_transitive(S, ZERO, EMPTY_SET)(equal_S_ZERO, equal_sets_symmetric(EMPTY_SET, ZERO)(zero_definition));
						D_in_EMPTY_SET = equality_consistency[<U: D in U>](S, EMPTY_SET)(equal_S_EMPTY_SET)(D_in_S);
						absurdity = empty_set_condition(D)(D_in_EMPTY_SET);
						return axiom_absurdity[goal](absurdity);
					};
				}
				return iff(lemma0, lemma1);
			}
			addition_class = #is_addition_class(ZERO, A)(addition_class_def);
			prove subset_def: *X(X in A -> X in C){
				given |X|;
				implies X_in_A;
				X_in_C, tuple_X = A_def(X)(X_in_A);
				return X_in_C;
			}
			A_subset_C = #is_subset(A, C)(subset_def);
			return addition_class, A_subset_C;
		}
		ZERO_in_R = R_def(ZERO)(zero_is_natural, ZERO_in_R);
		//Inductive step
		prove closure_R: *Y*Z(Y in R & is_successor(Y, Z) -> Z in R){
			given |Y, Y_1|;
			implies Y_in_R, successor_Y_1;
			Y_in_NATURALS, both = R_def(Y)(Y_in_R);
			Y_1_in_NATURALS = closure_naturals(Y, Y_1)(Y_in_NATURALS, successor_Y_1);
			addition_class, F_subset_C = both|F|;
			F_addition_class = expand(addition_class);
			G_def = axiom_specify[<Q: ^C^D(is_tuple(C, D, Q) & ((equal_sets(C, ZERO) & equal_sets(D, Y_1)) | ^C_NEG1^T(is_successor(C_NEG1, C) & is_tuple(C_NEG1, D, T) & T in F)))>](C)|G|;
			prove G_addition_class: *B(B in G <-> ^C^D(is_tuple(C, D, B) & ((equal_sets(C, ZERO) & equal_sets(D, Y_1)) | ^C_NEG1^D_1^T(is_successor(C_NEG1, C) & is_successor(D, D_1) & is_tuple(C_NEG1, D_1, T) & T in G)))){
				given |B|;
				prove lemma0: B in G -> ^C^D(is_tuple(C, D, B) & ((equal_sets(C, ZERO) & equal_sets(D, Y_1)) | ^C_NEG1^D_1^T(is_successor(C_NEG1, C) & is_successor(D, D_1) & is_tuple(C_NEG1, D_1, T) & T in G))){
					implies B_in_G;
					B_in_C, B_condition = G_def(B)(B_in_G);
					tuple_B, either_B = B_condition|C, D|;
					C_OTHER_in_NATURALS, D_OTHER_in_NATURALS, tuple_B_other = C_def(B)(B_in_C)|C_OTHER, D_OTHER|;
					C_equal, D_equal = tuple_equal_condition(C, D, C_OTHER, D_OTHER, B, B)(tuple_B, tuple_B_other, equal_sets_reflexive(B));
					C_in_NATURALS = equality_consistency[<Q: Q in NATURALS>](C, C_OTHER)(C_equal)(C_OTHER_in_NATURALS);
					D_in_NATURALS = equality_consistency[<Q: Q in NATURALS>](D, D_OTHER)(D_equal)(D_OTHER_in_NATURALS);
					choose C, D;
					return branch(either_B, equal_initial, predecessor_exists){
						return tuple_B, or(equal_initial, <:^C_NEG1^D_1^T(is_successor(C_NEG1, C) & is_successor(D, D_1) & is_tuple(C_NEG1, D_1, T) & T in G)>);
					} or {
						predecessor_C_NEG1, tuple_T0, T0_in_F = predecessor_exists|C_NEG1, T0|;
						tuple_T0_other, either_T0 = F_addition_class(T0)(T0_in_F)|C_NEG1_OTHER, D_OTHER|;
						equal_C_NEG1, equal_D = tuple_equal_condition(C_NEG1, D, C_NEG1_OTHER, D_OTHER, T0, T0)(tuple_T0, tuple_T0_other, equal_sets_reflexive(T0));
						//D_OTHER is a different object, so I overwrite this variable in this scope because I use it later
						D_OTHER_in_NATURALS = equality_consistency[<Q: Q in NATURALS>](D, D_OTHER)(equal_D)(D_in_NATURALS);
						return branch(either_T0, equal_initial, predecessor_exists){
							equal_C_NEG1_OTHER_ZERO, equal_D_OTHER_Y = equal_initial;
							equal_C_NEG1_ZERO = equal_sets_transitive(C_NEG1, C_NEG1_OTHER, ZERO)(equal_C_NEG1, equal_C_NEG1_OTHER_ZERO);
							equal_D_Y = equal_sets_transitive(D, D_OTHER, Y)(equal_D, equal_D_OTHER_Y);
							successor_D_1 = successor(D)|D_1|;
							successor_D_1_Y = equality_consistency[<Q: is_successor(Q, D_1)>](D, Y)(equal_D_Y)(successor_D_1);
							equal_D_1_Y_1 = successor_unique(Y, D_1, Y_1)(successor_D_1_Y, successor_Y_1);
							tuple_T = tuple(C_NEG1, D_1)|T|;
							C_NEG1_in_NATURALS = equality_consistency[<Q: Q in NATURALS>](C_NEG1, ZERO)(equal_C_NEG1_ZERO)(zero_is_natural);
							D_1_in_NATURALS = closure_naturals(Y, D_1)(Y_in_NATURALS, successor_D_1_Y);
							prove T_in_G: ^C^D(is_tuple(C, D, T) & ((equal_sets(C, ZERO) & equal_sets(D, Y_1)) | ^C_NEG1^T(is_successor(C_NEG1, C) & is_tuple(C_NEG1, D, T) & T in F))){
								choose C_NEG1, D_1;
								return tuple_T, or(and(equal_C_NEG1_ZERO, equal_D_1_Y_1), <:^C_NEG2^T(is_successor(C_NEG2, C_NEG1) & is_tuple(C_NEG2, D_1, T) & T in F)>);
							}
							prove T_in_C: ^C^D(C in NATURALS & D in NATURALS & is_tuple(C, D, T)){
								choose C_NEG1, D_1;
								return C_NEG1_in_NATURALS, D_1_in_NATURALS, tuple_T;
							}
							T_in_C = C_def(T)(T_in_C);
							T_in_G = G_def(T)(T_in_C, T_in_G);
							prove condition: ^C_NEG1^D_1^T(is_successor(C_NEG1, C) & is_successor(D, D_1) & is_tuple(C_NEG1, D_1, T) & T in G){
								choose C_NEG1, D_1, T;
								return predecessor_C_NEG1, successor_D_1, tuple_T, T_in_G;
							}
							return tuple_B, or(<:equal_sets(C, ZERO) & equal_sets(D, Y_1)>, condition);
						} or {
							predecessor_C_NEG2, successor_D_1, tuple_T1, T1_in_F = predecessor_exists|C_NEG2, D_1, T1|;
							predecessor_C_NEG2 = equality_consistency[<Q: is_successor(C_NEG2, Q)>](C_NEG1, C_NEG1_OTHER)(equal_C_NEG1)(predecessor_C_NEG2);
							tuple_T2 = tuple(C_NEG1, D_1)|T2|;
							D_1_in_NATURALS = closure_naturals(D_OTHER, D_1)(D_OTHER_in_NATURALS, successor_D_1);
							successor_D_1 = equality_consistency[<Q: is_successor(Q, D_1)>](D, D_OTHER)(equal_D)(successor_D_1);
							prove T2_in_C: ^C_NEG1^D_1(C_NEG1 in NATURALS & D_1 in NATURALS & is_tuple(C_NEG1, D_1, T2)){
								choose C_NEG1, D_1;
								C_NEG1_in_NATURALS = NATURALS_predecessor_closure(C, C_NEG1)(C_in_NATURALS, predecessor_C_NEG1);
								return C_NEG1_in_NATURALS, D_1_in_NATURALS, tuple_T2;
							}
							T2_in_C = C_def(T2)(T2_in_C);
							prove condition: ^C_NEG1^D_1(is_tuple(C_NEG1, D_1, T2) & ((equal_sets(C_NEG1, ZERO) & equal_sets(D_1, Y_1)) | ^C_NEG2^T1(is_successor(C_NEG2, C_NEG1) & is_tuple(C_NEG2, D_1, T1) & T1 in F))){
								choose C_NEG1, D_1;
								prove condition: ^C_NEG2^T1(is_successor(C_NEG2, C_NEG1) & is_tuple(C_NEG2, D_1, T1) & T1 in F){
									choose C_NEG2, T1;
									return predecessor_C_NEG2, tuple_T1, T1_in_F;
								}
								return tuple_T2, or(<:equal_sets(C_NEG1, ZERO) & equal_sets(D_1, Y_1)>, condition);
							}
							T2_in_G = G_def(T2)(T2_in_C, condition);
							prove condition: ^C_NEG1^D_1^T2(is_successor(C_NEG1, C) & is_successor(D, D_1) & is_tuple(C_NEG1, D_1, T2) & T2 in G){
								choose C_NEG1, D_1, T2;
								return predecessor_C_NEG1, successor_D_1, tuple_T2, T2_in_G;
							}
							return tuple_B, or(<:equal_sets(C, ZERO) & equal_sets(D, Y_1)>, condition);
						};
					};
				}
				prove lemma1: ^C^D(is_tuple(C, D, B) & ((equal_sets(C, ZERO) & equal_sets(D, Y_1)) | ^C_NEG1^D_1^T(is_successor(C_NEG1, C) & is_successor(D, D_1) & is_tuple(C_NEG1, D_1, T) & T in G))) -> B in G{
					implies premise;
					tuple_B, either_B = premise|C, D|;
					return branch(either_B, equal_both, G_condition){
						equal_C_ZERO, equal_D_Y_1 = equal_both;
						prove condition: ^C^D(is_tuple(C, D, B) & ((equal_sets(C, ZERO) & equal_sets(D, Y_1)) | ^C_NEG1^T(is_successor(C_NEG1, C) & is_tuple(C_NEG1, D, T) & T in F))){
							choose C, D;
							return tuple_B, or(equal_both, <:^C_NEG1^T(is_successor(C_NEG1, C) & is_tuple(C_NEG1, D, T) & T in F)>);
						}
						prove B_in_C: ^C^D(C in NATURALS & D in NATURALS & is_tuple(C, D, B)){
							choose C, D;
							C_in_NATURALS = equality_consistency[<Q: Q in NATURALS>](C, ZERO)(equal_C_ZERO)(zero_is_natural);
							D_in_NATURALS = equality_consistency[<Q: Q in NATURALS>](D, Y_1)(equal_D_Y_1)(Y_1_in_NATURALS);
							return C_in_NATURALS, D_in_NATURALS, tuple_B;
						}
						B_in_C = C_def(B)(B_in_C);
						return G_def(B)(B_in_C, condition);
					} or {
						predecessor_C_NEG1, successor_D_1, tuple_T, T_in_G = G_condition|C_NEG1, D_1, T|;
						T_in_C, T_condition = G_def(T)(T_in_G);
						tuple_T_other, either_T = T_condition|C_NEG1_OTHER, D_1_OTHER|;
						equal_C_NEG1, equal_D_1 = tuple_equal_condition(C_NEG1, D_1, C_NEG1_OTHER, D_1_OTHER, T, T)(tuple_T, tuple_T_other, equal_sets_reflexive(T));
						return branch(either_T, equal_initial, F_condition){
							equal_C_NEG1_ZERO, equal_D_1_Y_1 = equal_initial;
							equal_C_NEG1_ZERO = equality_consistency[<Q: equal_sets(Q, ZERO)>](C_NEG1, C_NEG1_OTHER)(equal_C_NEG1)(equal_C_NEG1_ZERO);
							equal_D_1_Y_1 = equality_consistency[<Q: equal_sets(Q, Y_1)>](D_1, D_1_OTHER)(equal_D_1)(equal_D_1_Y_1);
							successor_D_1_Y = equality_consistency[<Q: is_successor(Y, Q)>](D_1, Y_1)(equal_D_1_Y_1)(successor_Y_1);
							equal_D_Y = predecessor_unique(D, Y, D_1)(successor_D_1, successor_D_1_Y);
							tuple_T0 = tuple(C_NEG1, D)|T0|;
							prove T0_in_F: ^C_NEG1^D(is_tuple(C_NEG1, D, T0) & ((equal_sets(C_NEG1, ZERO) & equal_sets(D, Y)) | ^P^S^T(is_successor(P, C_NEG1) & is_successor(D, S) & is_tuple(P, S, T) & T in F))){
								choose C_NEG1, D;
								return tuple_T0, or(and(equal_C_NEG1_ZERO, equal_D_Y), <:^P^S^T(is_successor(P, C_NEG1) & is_successor(D, S) & is_tuple(P, S, T) & T in F)>);
							}
							T0_in_F = F_addition_class(T0)(T0_in_F);
							prove condition: ^C_NEG1^T0(is_successor(C_NEG1, C) & is_tuple(C_NEG1, D, T0) & T0 in F){
								choose C_NEG1, T0;
								return predecessor_C_NEG1, tuple_T0, T0_in_F;
							}
							prove condition: ^C^D(is_tuple(C, D, B) & ((equal_sets(C, ZERO) & equal_sets(D, Y_1)) | ^C_NEG1^T0(is_successor(C_NEG1, C) & is_tuple(C_NEG1, D, T0) & T0 in F))){
								choose C, D;
								return tuple_B, or(<:equal_sets(C, ZERO) & equal_sets(D, Y_1)>, condition);
							}
							prove B_in_C: ^C^D(C in NATURALS & D in NATURALS & is_tuple(C, D, B)){
								choose C, D;
								C_NEG1_in_NATURALS = equality_consistency[<Q: Q in NATURALS>](C_NEG1, ZERO)(equal_C_NEG1_ZERO)(zero_is_natural);
								C_in_NATURALS = closure_naturals(C_NEG1, C)(C_NEG1_in_NATURALS, predecessor_C_NEG1);
								D_in_NATURALS = equality_consistency[<Q: Q in NATURALS>](D, Y)(equal_D_Y)(Y_in_NATURALS);
								return C_in_NATURALS, D_in_NATURALS, tuple_B;
							}
							B_in_C = C_def(B)(B_in_C);
							return G_def(B)(B_in_C, condition);
						} or {
							predecessor_C_NEG2, tuple_T0, T0_in_F = F_condition|C_NEG2, T0|;
							predecessor_C_NEG2 = equality_consistency[<Q: is_successor(C_NEG2, Q)>](C_NEG1, C_NEG1_OTHER)(equal_C_NEG1)(predecessor_C_NEG2);
							tuple_T0 = equality_consistency[<Q: is_tuple(C_NEG2, Q, T0)>](D_1, D_1_OTHER)(equal_D_1)(tuple_T0);
							tuple_T1 = tuple(C_NEG1, D)|T1|;
							prove T1_in_F: ^C_NEG2^D_1^T0(is_successor(C_NEG2, C_NEG1) & is_successor(D, D_1) & is_tuple(C_NEG2, D_1, T0) & T0 in F){
								choose C_NEG2, D_1, T0;
								return predecessor_C_NEG2, successor_D_1, tuple_T0, T0_in_F;
							}
							prove T1_in_F: ^C_NEG1^D(is_tuple(C_NEG1, D, T1) & ((equal_sets(C_NEG1, ZERO) & equal_sets(D, Y)) | ^C_NEG2^D_1^T0(is_successor(C_NEG2, C_NEG1) & is_successor(D, D_1) & is_tuple(C_NEG2, D_1, T0) & T0 in F))){
								choose C_NEG1, D;
								return tuple_T1, or(<:equal_sets(C_NEG1, ZERO) & equal_sets(D, Y)>, T1_in_F);
							}
							T1_in_F = F_addition_class(T1)(T1_in_F);
							//Here is where we use the stronger condition
							T1_in_C = expand(F_subset_C)(T1)(T1_in_F);
							C_NEG1_OTHER_in_NATURALS, D_OTHER_in_NATURALS, tuple_T1_other = C_def(T1)(T1_in_C)|C_NEG1_OTHER, D_OTHER|;
							equal_C_NEG1, equal_D = tuple_equal_condition(C_NEG1, D, C_NEG1_OTHER, D_OTHER, T1, T1)(tuple_T1, tuple_T1_other, equal_sets_reflexive(T1));
							C_NEG1_in_NATURALS = equality_consistency[<Q: Q in NATURALS>](C_NEG1, C_NEG1_OTHER)(equal_C_NEG1)(C_NEG1_OTHER_in_NATURALS);
							D_in_NATURALS = equality_consistency[<Q: Q in NATURALS>](D, D_OTHER)(equal_D)(D_OTHER_in_NATURALS);
							C_in_NATURALS = closure_naturals(C_NEG1, C)(C_NEG1_in_NATURALS, predecessor_C_NEG1);
							prove condition: ^C_NEG1^T1(is_successor(C_NEG1, C) & is_tuple(C_NEG1, D, T1) & T1 in F){
								choose C_NEG1, T1;
								return predecessor_C_NEG1, tuple_T1, T1_in_F;
							}
							prove condition: ^C^D(is_tuple(C, D, B) & ((equal_sets(C, ZERO) & equal_sets(D, Y_1)) | ^C_NEG1^T1(is_successor(C_NEG1, C) & is_tuple(C_NEG1, D, T1) & T1 in F))){
								choose C, D;
								return tuple_B, or(<:equal_sets(C, ZERO) & equal_sets(D, Y_1)>, condition);
							}
							prove B_in_C: ^C^D(C in NATURALS & D in NATURALS & is_tuple(C, D, B)){
								choose C, D;
								return C_in_NATURALS, D_in_NATURALS, tuple_B;
							}
							B_in_C = C_def(B)(B_in_C);
							return G_def(B)(B_in_C, condition);
						};
					};
				}
				return iff(lemma0, lemma1);
			}
			G_addition_class = #is_addition_class(Y_1, G)(G_addition_class);
			prove subset_def: *X(X in G -> X in C){
				given |X|;
				implies X_in_G;
				X_in_C, G_condition = G_def(X)(X_in_G);
				return X_in_C;
			}
			G_subset_C = #is_subset(G, C)(subset_def);
			prove Y_1_in_R: ^G(is_addition_class(Y_1, G) & is_subset(G, C)){
				choose G;
				return G_addition_class, G_subset_C;
			}
			return R_def(Y_1)(Y_1_in_NATURALS, Y_1_in_R);
		}
		NATURALS_subset_R = expand(NATURALS_induction(R)(ZERO_in_R, closure_R));
		given |N|;
		implies N_in_NATURALS;
		N_in_R = NATURALS_subset_R(N)(N_in_NATURALS);
		N_in_NATURALS, addition_class_exists = R_def(N)(N_in_R);
		result = addition_class_exists|A|;
		choose A;
		return result;
	}

	//Phew! That was the most important result of the proof. Next we need to prove that these addition classes cover all pairs of natural numbers.

	//This lemma shows that (0, x) belongs to an addition class of N if and only if x = N
	prove addition_class_initial_unique: *A*T*F*N(is_addition_class(N, F) & is_tuple(ZERO, A, T) -> (T in F <-> equal_sets(A, N))){
		given |A, T, F, N|;
		implies addition_class_F, tuple_T;
		prove lemma0: T in F -> equal_sets(A, N){
			implies T_in_F;
			tuple_T_other, either = expand(addition_class_F)(T)(T_in_F)|OTHER_ZERO, OTHER_A|;
			equal_ZERO, equal_A = tuple_equal_condition(ZERO, A, OTHER_ZERO, OTHER_A, T, T)(tuple_T, tuple_T_other, equal_sets_reflexive(T));
			return branch(either, equal_both, predecessors){
				equal_ZERO, equal_OTHER_A_N = equal_both;
				return equal_sets_transitive(A, OTHER_A, N)(equal_A, equal_OTHER_A_N);
			} or {
				predecessor_C, successor_D, tuple_T0, T0_in_F = predecessors|C, D, T0|;
				not_zero = NATURAL_successor_nonzero(C, OTHER_ZERO)(predecessor_C);
				equal_OTHER_ZERO_ZERO = equal_sets_symmetric(ZERO, OTHER_ZERO)(equal_ZERO);
				absurdity = not_zero(equal_OTHER_ZERO_ZERO);
				return axiom_absurdity[goal](absurdity);
			};
		}
		prove lemma1: equal_sets(A, N) -> T in F{
			implies equal_A_N;
			prove condition: ^C^D(is_tuple(C, D, T) & ((equal_sets(C, ZERO) & equal_sets(D, N)) | ^P^S^T(is_successor(P, C) & is_successor(D, S) & is_tuple(P, S, T) & T in F))){
				choose ZERO, A;
				return tuple_T, or(and(equal_sets_reflexive(ZERO), equal_A_N), <:^P^S^T(is_successor(P, ZERO) & is_successor(A, S) & is_tuple(P, S, T) & T in F)>);
			}
			return expand(addition_class_F)(T)(condition);
		}
		return iff(lemma0, lemma1);
	}

	//Next we prove a crucial lemma to the next important result, again using induction
	//This result also shows the recursive peano axiom for addition
	prove addition_classes_cover_lemma: *A(A in NATURALS -> *B*T*F*N(N in NATURALS & is_addition_class(N, F) & is_tuple(A, B, T) & T in F -> ^S^T1^N1^F1(is_successor(A, S) & is_successor(N, N1) & is_addition_class(N1, F1) & is_tuple(S, B, T1) & T1 in F1))){
		//Again, we use induction!
		R_def = axiom_specify[<Q: *B*T*F*N(N in NATURALS & is_addition_class(N, F) & is_tuple(Q, B, T) & T in F -> ^S^T1^N1^F1(is_successor(Q, S) & is_successor(N, N1) & is_addition_class(N1, F1) & is_tuple(S, B, T1) & T1 in F1))>](NATURALS)|R|;
		//Base step
		prove ZERO_in_R: *B*T*F*N(N in NATURALS & is_addition_class(N, F) & is_tuple(ZERO, B, T) & T in F -> ^S^T1^N1^F1(is_successor(ZERO, S) & is_successor(N, N1) & is_addition_class(N1, F1) & is_tuple(S, B, T1) & T1 in F1)){
			given |B, T, F, N|;
			implies N_in_NATURALS, addition_class_F, tuple_T, T_in_F;
			equal_B_N = addition_class_initial_unique(B, T, F, N)(addition_class_F, tuple_T)(T_in_F);
			successor_N1 = successor(N)|N1|;
			N1_in_NATURALS = closure_naturals(N, N1)(N_in_NATURALS, successor_N1);
			tuple_T0 = tuple(ZERO, N1)|T0|;
			addition_class_F1, F1_subset_C = addition_classes_exist(N1)(N1_in_NATURALS)|F1|;
			T0_in_F1 = addition_class_initial_unique(N1, T0, F1, N1)(addition_class_F1, tuple_T0)(equal_sets_reflexive(N1));
			tuple_T1 = tuple(ONE, N)|T1|;
			prove T1_in_F1: ^ONE^N(is_tuple(ONE, N, T1) & ((equal_sets(ONE, ZERO) & equal_sets(N, N1)) | ^ZERO^N1^T0(is_successor(ZERO, ONE) & is_successor(N, N1) & is_tuple(ZERO, N1, T0) & T0 in F1))){
				choose ONE, N;
				prove condition: ^ZERO^N1^T0(is_successor(ZERO, ONE) & is_successor(N, N1) & is_tuple(ZERO, N1, T0) & T0 in F1){
					choose ZERO, N1, T0;
					return one_definition, successor_N1, tuple_T0, T0_in_F1;
				}
				return tuple_T1, or(<:equal_sets(ONE, ZERO) & equal_sets(N, N1)>, condition);
			}
			T1_in_F1 = expand(addition_class_F1)(T1)(T1_in_F1);
			tuple_T1 = equality_consistency[<Q: is_tuple(ONE, Q, T1)>](B, N)(equal_B_N)(tuple_T1);
			choose ONE, T1, N1, F1;
			return one_definition, successor_N1, addition_class_F1, tuple_T1, T1_in_F1;
		}
		ZERO_in_R = R_def(ZERO)(zero_is_natural, ZERO_in_R);
		//Inductive step
		prove closure_R: *Y*Z(Y in R & is_successor(Y, Z) -> Z in R){
			given |Y, Y1|;
			implies Y_in_R, successor_Y1;
			Y1_not_ZERO = NATURAL_successor_nonzero(Y, Y1)(successor_Y1);
			Y_in_NATURALS, Y_condition = R_def(Y)(Y_in_R);
			successor_Y2 = successor(Y1)|Y2|;
			Y2_not_ZERO = NATURAL_successor_nonzero(Y1, Y2)(successor_Y2);
			Y1_in_NATURALS = closure_naturals(Y, Y1)(Y_in_NATURALS, successor_Y1);
			prove Y1_in_R: *B*T*F*N(N in NATURALS & is_addition_class(N, F) & is_tuple(Y1, B, T) & T in F -> ^Y2^T1^N1^F1(is_successor(Y1, Y2) & is_successor(N, N1) & is_addition_class(N1, F1) & is_tuple(Y2, B, T1) & T1 in F1)){
				given |B, T, F, N|;
				implies N_in_NATURALS, addition_class_F, tuple_T, T_in_F;
				other_tuple_T, either_T = expand(addition_class_F)(T)(T_in_F)|OTHER_Y1, OTHER_B|;
				equal_Y1, equal_B = tuple_equal_condition(Y1, B, OTHER_Y1, OTHER_B, T, T)(tuple_T, other_tuple_T, equal_sets_reflexive(T));
				predecessor_exists_T = branch(either_T, equal_initial_T, predecessor_exists_T){
					equal_OTHER_Y1_ZERO, equal_OTHER_B_N = equal_initial_T;
					equal_Y1_ZERO = equality_consistency[<S: equal_sets(S, ZERO)>](Y1, OTHER_Y1)(equal_Y1)(equal_OTHER_Y1_ZERO);
					absurdity = Y1_not_ZERO(equal_Y1_ZERO);
					return axiom_absurdity[<:^Y^B1^T0(is_successor(Y, OTHER_Y1) & is_successor(OTHER_B, B1) & is_tuple(Y, B1, T0) & T0 in F)>](absurdity);
				} or {
					return predecessor_exists_T;
				};
				successor_OTHER_Y1, successor_B1, tuple_T0, T0_in_F = predecessor_exists_T|OTHER_Y, B1, T0|;
				successor_Y1_OTHER_Y = equality_consistency[<S: is_successor(OTHER_Y, S)>](Y1, OTHER_Y1)(equal_Y1)(successor_OTHER_Y1);
				equal_Y = predecessor_unique(Y, OTHER_Y, Y1)(successor_Y1, successor_Y1_OTHER_Y);
				tuple_T0 = equality_consistency[<S: is_tuple(S, B1, T0)>](Y, OTHER_Y)(equal_Y)(tuple_T0);
				existence_in_F1 = Y_condition(B1, T0, F, N)(N_in_NATURALS, addition_class_F, tuple_T0, T0_in_F);

				//I want to overwrite OTHER_Y1 because I no longer need the older "version" of this object
				//So I must overwrite the other statements which refer to this old object
				other_tuple_T = axiom_true;
				either_T = axiom_true;
				equal_Y1 = axiom_true;
				predecessor_exists_T = axiom_true;
				successor_OTHER_Y1 = axiom_true;

				successor_OTHER_Y1, successor_N1, addition_class_F1, tuple_T1_PRED, T1_PRED_in_F1 = existence_in_F1|OTHER_Y1, T1_PRED, N1, F1|;
				equal_Y1 = successor_unique(Y, Y1, OTHER_Y1)(successor_Y1, successor_OTHER_Y1);
				successor_B1 = equality_consistency[<S: is_successor(S, B1)>](B, OTHER_B)(equal_B)(successor_B1);
				tuple_T1_PRED = equality_consistency[<S: is_tuple(S, B1, T1_PRED)>](Y1, OTHER_Y1)(equal_Y1)(tuple_T1_PRED);
				successor_Y2 = successor(Y1)|Y2|;
				tuple_T1 = tuple(Y2, B)|T1|;
				choose Y2, T1, N1, F1;
				prove condition: ^P^S^T(is_successor(P, Y2) & is_successor(B, S) & is_tuple(P, S, T) & T in F1){
					choose Y1, B1, T1_PRED;
					return successor_Y2, successor_B1, tuple_T1_PRED, T1_PRED_in_F1;
				}
				prove T1_in_F1: ^Y2^B(is_tuple(Y2, B, T1) & ((equal_sets(Y2, ZERO) & equal_sets(B, N1)) | ^P^S^T(is_successor(P, Y2) & is_successor(B, S) & is_tuple(P, S, T) & T in F1))){
					choose Y2, B;
					return tuple_T1, or(<:equal_sets(Y2, ZERO) & equal_sets(B, N1)>, condition);
				}
				T1_in_F1 = expand(addition_class_F1)(T1)(T1_in_F1);
				return successor_Y2, successor_N1, addition_class_F1, tuple_T1, T1_in_F1;
			}
			return R_def(Y1)(Y1_in_NATURALS, Y1_in_R);
		}
		NATURALS_subset_R = NATURALS_induction(R)(ZERO_in_R, closure_R);
		given |A|;
		implies A_in_NATURALS;
		A_in_R = expand(NATURALS_subset_R)(A)(A_in_NATURALS);
		A_in_NATURALS, result = R_def(A)(A_in_R);

		return result;
	}

	//Now we prove that the addition classes "cover" the tuples of natural numbers
	prove addition_classes_cover: *A*B(A in NATURALS & B in NATURALS -> ^T^N^F(is_tuple(B, A, T) & N in NATURALS & is_addition_class(N, F) & T in F)){
		given |A, B|;
		implies A_in_NATURALS, B_in_NATURALS;
		R_def = axiom_specify[<S: ^T^N^F(is_tuple(S, A, T) & N in NATURALS & is_addition_class(N, F) & T in F)>](NATURALS)|R|;
		prove ZERO_in_R: ^T^N^F(is_tuple(ZERO, A, T) & N in NATURALS & is_addition_class(N, F) & T in F){
			tuple_T = tuple(ZERO, A)|T|;
			addition_class_F, F_subset_C = addition_classes_exist(A)(A_in_NATURALS)|F|;
			T_in_F = addition_class_initial_unique(A, T, F, A)(addition_class_F, tuple_T)(equal_sets_reflexive(A));
			choose T, A, F;
			return tuple_T, A_in_NATURALS, addition_class_F, T_in_F;
		}
		ZERO_in_R = R_def(ZERO)(zero_is_natural, ZERO_in_R);
		prove closure_R: *Y*Y1(Y in R & is_successor(Y, Y1) -> Y1 in R){
			given |Y, Y1|;
			implies Y_in_R, successor_Y1;
			Y_in_NATURALS, Y_condition = R_def(Y)(Y_in_R);
			tuple_T, N_in_NATURALS, addition_class_F, T_in_F = Y_condition|T, N, F|;
			next_exists = addition_classes_cover_lemma(Y)(Y_in_NATURALS)(A, T, F, N)(N_in_NATURALS, addition_class_F, tuple_T, T_in_F);
			successor_OTHER_Y1, successor_N1, addition_class_F1, tuple_T1, T1_in_F1 = next_exists|OTHER_Y1, T1, N1, F1|;
			equal_Y1 = successor_unique(Y, Y1, OTHER_Y1)(successor_Y1, successor_OTHER_Y1);
			tuple_T1 = equality_consistency[<S: is_tuple(S, A, T1)>](Y1, OTHER_Y1)(equal_Y1)(tuple_T1);
			N1_in_NATURALS = closure_naturals(N, N1)(N_in_NATURALS, successor_N1);
			Y1_in_NATURALS = closure_naturals(Y, Y1)(Y_in_NATURALS, successor_Y1);
			prove Y1_in_R: ^T1^N1^F1(is_tuple(Y1, A, T1) & N1 in NATURALS & is_addition_class(N1, F1) & T1 in F1){
				choose T1, N1, F1;
				return tuple_T1, N1_in_NATURALS, addition_class_F1, T1_in_F1;
			}
			return R_def(Y1)(Y1_in_NATURALS, Y1_in_R);
		}
		NATURALS_subset_R = NATURALS_induction(R)(ZERO_in_R, closure_R);
		B_in_R = expand(NATURALS_subset_R)(B)(B_in_NATURALS);
		B_in_NATURALS, result = R_def(B)(B_in_R);
		
		return result;
	}

	//Here we prove that (A, B) can belong to at most one addition class
	prove addition_classes_unique: *A*B*N*M*FN*FM(A in NATURALS & B in NATURALS & is_addition_class(N, FN) & is_addition_class(M, FM) & ^T(is_tuple(A, B, T) & T in FN & T in FM) -> equal_sets(N, M)){
		R_def = axiom_specify[<S: *B*N*M*FN*FM(S in NATURALS & B in NATURALS & is_addition_class(N, FN) & is_addition_class(M, FM) & ^T(is_tuple(S, B, T) & T in FN & T in FM) -> equal_sets(N, M))>](NATURALS)|R|;
		prove ZERO_in_R: *B*N*M*FN*FM(ZERO in NATURALS & B in NATURALS & is_addition_class(N, FN) & is_addition_class(M, FM) & ^T(is_tuple(ZERO, B, T) & T in FN & T in FM) -> equal_sets(N, M)){
			given |B, N, M, FN, FM|;
			implies ZERO_in_NATURALS, B_in_NATURALS, addition_class_FN, addition_class_FM, T_exists;
			tuple_T, T_in_FN, T_in_FM = T_exists|T|;
			equal_B_N = addition_class_initial_unique(B, T, FN, N)(addition_class_FN, tuple_T)(T_in_FN);
			equal_B_M = addition_class_initial_unique(B, T, FM, M)(addition_class_FM, tuple_T)(T_in_FM);
			return equality_consistency[<S: equal_sets(S, M)>](B, N)(equal_B_N)(equal_B_M);
		}
		ZERO_in_R = R_def(ZERO)(zero_is_natural, ZERO_in_R);
		prove closure_R: *Y*Y1(Y in R & is_successor(Y, Y1) -> Y1 in R){
			given |Y, Y1|;
			implies Y_in_R, successor_Y1;
			Y_in_NATURALS, Y_condition = R_def(Y)(Y_in_R);
			Y1_in_NATURALS = closure_naturals(Y, Y1)(Y_in_NATURALS, successor_Y1);
			prove Y1_in_R: *B*N*M*FN*FM(Y1 in NATURALS & B in NATURALS & is_addition_class(N, FN) & is_addition_class(M, FM) & ^T(is_tuple(Y1, B, T) & T in FN & T in FM) -> equal_sets(N, M)){
				given |B, N, M, FN, FM|;
				implies Y1_in_NATURALS, B_in_NATURALS, addition_class_FN, addition_class_FM, T_exists;
				tuple_T, T_in_FN, T_in_FM = T_exists|T|;
				
				//First for FN
				other_tuple_T, either_T = expand(addition_class_FN)(T)(T_in_FN)|OTHER_Y1, OTHER_B|;
				equal_Y1, equal_B = tuple_equal_condition(Y1, B, OTHER_Y1, OTHER_B, T, T)(tuple_T, other_tuple_T, equal_sets_reflexive(T));
				T_PRED_exists = branch(either_T, initial_T, T_PRED_exists){
					equal_OTHER_Y1_ZERO, equal_B_N = initial_T;
					equal_Y1_ZERO = equality_consistency[<S: equal_sets(S, ZERO)>](Y1, OTHER_Y1)(equal_Y1)(equal_OTHER_Y1_ZERO);
					not_equal_Y1_ZERO = NATURAL_successor_nonzero(Y, Y1)(successor_Y1);
					absurdity = not_equal_Y1_ZERO(equal_Y1_ZERO);
					return axiom_absurdity[<:^Y^B1^T1(is_successor(Y, OTHER_Y1) & is_successor(OTHER_B, B1) & is_tuple(Y, B1, T1) & T1 in FN)>](absurdity);
				} or {
					return T_PRED_exists;
				};
				other_successor_Y1, successor_B1, tuple_T1, T1_in_FN = T_PRED_exists|OTHER_Y, B1, T1|;
				other_successor_Y1 = equality_consistency[<S: is_successor(OTHER_Y, S)>](Y1, OTHER_Y1)(equal_Y1)(other_successor_Y1);
				equal_Y = predecessor_unique(Y, OTHER_Y, Y1)(successor_Y1, other_successor_Y1);
				tuple_T1 = equality_consistency[<S: is_tuple(S, B1, T1)>](Y, OTHER_Y)(equal_Y)(tuple_T1);
				successor_B1 = equality_consistency[<S: is_successor(S, B1)>](B, OTHER_B)(equal_B)(successor_B1);

				//Now the same for FM
				other_tuple_T, either_T = expand(addition_class_FM)(T)(T_in_FM)|M_OTHER_Y1, M_OTHER_B|;
				equal_Y1, equal_B = tuple_equal_condition(Y1, B, M_OTHER_Y1, M_OTHER_B, T, T)(tuple_T, other_tuple_T, equal_sets_reflexive(T));
				T_PRED_exists = branch(either_T, initial_T, T_PRED_exists){
					equal_M_OTHER_Y1_ZERO, equal_B_N = initial_T;
					equal_Y1_ZERO = equality_consistency[<S: equal_sets(S, ZERO)>](Y1, M_OTHER_Y1)(equal_Y1)(equal_M_OTHER_Y1_ZERO);
					not_equal_Y1_ZERO = NATURAL_successor_nonzero(Y, Y1)(successor_Y1);
					absurdity = not_equal_Y1_ZERO(equal_Y1_ZERO);
					return axiom_absurdity[<:^Y^B1^T1(is_successor(Y, M_OTHER_Y1) & is_successor(M_OTHER_B, B1) & is_tuple(Y, B1, T1) & T1 in FM)>](absurdity);
				} or {
					return T_PRED_exists;
				};
				other_successor_Y1, M_successor_B1, tuple_M_T1, M_T1_in_FM = T_PRED_exists|M_OTHER_Y, M_B1, M_T1|;
				other_successor_Y1 = equality_consistency[<S: is_successor(M_OTHER_Y, S)>](Y1, M_OTHER_Y1)(equal_Y1)(other_successor_Y1);
				equal_Y = predecessor_unique(Y, M_OTHER_Y, Y1)(successor_Y1, other_successor_Y1);
				tuple_M_T1 = equality_consistency[<S: is_tuple(S, M_B1, M_T1)>](Y, M_OTHER_Y)(equal_Y)(tuple_M_T1);
				M_successor_B1 = equality_consistency[<S: is_successor(S, M_B1)>](B, M_OTHER_B)(equal_B)(M_successor_B1);

				B1_in_NATURALS = closure_naturals(B, B1)(B_in_NATURALS, successor_B1);
				equal_B1 = successor_unique(B, B1, M_B1)(successor_B1, M_successor_B1);
				tuple_M_T1 = equality_consistency[<S: is_tuple(Y, S, M_T1)>](B1, M_B1)(equal_B1)(tuple_M_T1);
				equal_T1 = tuple_unique(Y, B1, T1, M_T1)(tuple_T1, tuple_M_T1);
				T1_in_FM = equality_consistency[<S: S in FM>](T1, M_T1)(equal_T1)(M_T1_in_FM);

				prove condition: ^T1(is_tuple(Y, B1, T1) & T1 in FN & T1 in FM){
					choose T1;
					return tuple_T1, T1_in_FN, T1_in_FM;
				}
				return Y_condition(B1, N, M, FN, FM)(Y_in_NATURALS, B1_in_NATURALS, addition_class_FN, addition_class_FM, condition);
			}
			return R_def(Y1)(Y1_in_NATURALS, Y1_in_R);
		}
		NATURALS_subset_R = NATURALS_induction(R)(ZERO_in_R, closure_R);
		given |A, B, N, M, FN, FM|;
		implies premises;
		A_in_NATURALS, rest_of_premises = premises;
		A_in_R = expand(NATURALS_subset_R)(A)(A_in_NATURALS);
		A_in_NATURALS, A_result = R_def(A)(A_in_R);
		return A_result(B, N, M, FN, FM)(premises);
	}

	//FINALLY! IT'S TIME TO CONSTRUCT THE ADDITION FUNCTION!
	//Here it is!
	addition_function_definition = relation_existence_lemma[<T, Y: ^F(is_addition_class(Y, F) & T in F)>](C, NATURALS)|ADDITION_FUNCTION|;
	choose ADDITION_FUNCTION;

	//We must first prove that this is indeed a function
	prove ADDITION_FUNCTION_is_function: *X*Y*Z(are_related(X, Y, ADDITION_FUNCTION) & are_related(X, Z, ADDITION_FUNCTION) -> equal_sets(Y, Z)){
		given |X, Y, Z|;
		implies related_XY, related_XZ;

		X_in_C, Y_in_NATURALS, F0_exists = addition_function_definition(X, Y)(related_XY);
		addition_class_F0, X_in_F0 = F0_exists|F0|;

		X_in_C, Z_in_NATURALS, F1_exists = addition_function_definition(X, Z)(related_XZ);
		addition_class_F1, X_in_F1 = F1_exists|F1|;

		X0_in_NATURALS, X1_in_NATURALS, tuple_X = C_def(X)(X_in_C)|X0, X1|;
		prove condition: ^X(is_tuple(X0, X1, X) & X in F0 & X in F1){
			choose X;
			return tuple_X, X_in_F0, X_in_F1;
		}

		return addition_classes_unique(X0, X1, Y, Z, F0, F1)(X0_in_NATURALS, X1_in_NATURALS, addition_class_F0, addition_class_F1, condition);
	}

	ADDITION_FUNCTION_is_function = #is_function(ADDITION_FUNCTION)(ADDITION_FUNCTION_is_function);

	prove domain_C: *X(X in C -> ^Y(are_related(X, Y, ADDITION_FUNCTION))){
		given |X|;
		implies X_in_C;
		X0_in_NATURALS, X1_in_NATURALS, tuple_X = C_def(X)(X_in_C)|X0, X1|;
		tuple_OTHER_X, Y_in_NATURALS, addition_class_F, OTHER_X_in_F = addition_classes_cover(X1, X0)(X1_in_NATURALS, X0_in_NATURALS)|OTHER_X, Y, F|;
		choose Y;
		equal_X = tuple_unique(X0, X1, X, OTHER_X)(tuple_X, tuple_OTHER_X);
		X_in_F = equality_consistency[<S: S in F>](X, OTHER_X)(equal_X)(OTHER_X_in_F);
		prove related_XY: ^F(is_addition_class(Y, F) & X in F){
			choose F;
			return addition_class_F, X_in_F;
		}
		return addition_function_definition(X, Y)(X_in_C, Y_in_NATURALS, related_XY);
	}

	domain_C = #is_domain(ADDITION_FUNCTION, C)(domain_C);

	prove domain_exists: ^T(is_cross_product(NATURALS, NATURALS, T) & is_domain(ADDITION_FUNCTION, T)){
		choose C;
		return C_cross_product, domain_C;
	}

	prove codomain_NATURALS: *X*Y(are_related(X, Y, ADDITION_FUNCTION) -> Y in NATURALS){
		given |X, Y|;
		implies related_XY;
		X_in_C, Y_in_NATURALS, addition_class_exists = addition_function_definition(X, Y)(related_XY);
		return Y_in_NATURALS;
	}

	codomain_NATURALS = #is_codomain(ADDITION_FUNCTION, NATURALS)(codomain_NATURALS);

	prove zero_identity: *X*Z(X in NATURALS & is_tuple(ZERO, X, Z) -> are_related(Z, X, ADDITION_FUNCTION)){
		given |X, Z|;
		implies X_in_NATURALS, tuple_Z;
		addition_class_F, F_subset_C = addition_classes_exist(X)(X_in_NATURALS)|F|;
		Z_in_F = addition_class_initial_unique(X, Z, F, X)(addition_class_F, tuple_Z)(equal_sets_reflexive(X));
		prove related_ZX: ^F(is_addition_class(X, F) & Z in F){
			choose F;
			return addition_class_F, Z_in_F;
		}
		Z_in_C = expand(F_subset_C)(Z)(Z_in_F);
		return addition_function_definition(Z, X)(Z_in_C, X_in_NATURALS, related_ZX);
	}

	prove successor_recursion: *X*Y*T0*Z0(is_tuple(X, Y, T0) & are_related(T0, Z0, ADDITION_FUNCTION) -> ^SX^T1^Z1(is_successor(X, SX) & is_tuple(SX, Y, T1) & are_related(T1, Z1, ADDITION_FUNCTION) & is_successor(Z0, Z1))){
		given |X, Y, T0, Z0|;
		implies tuple_T0, related_T0Z0;
		T0_in_C, Z0_in_NATURALS, addition_class_exists = addition_function_definition(T0, Z0)(related_T0Z0);
		addition_class_F0, T0_in_F0 = addition_class_exists|F0|;
		OTHER_X_in_NATURALS, OTHER_Y_in_NATURALS, other_tuple_T0 = C_def(T0)(T0_in_C)|OTHER_X, OTHER_Y|;
		equal_X, equal_Y = tuple_equal_condition(X, Y, OTHER_X, OTHER_Y, T0, T0)(tuple_T0, other_tuple_T0, equal_sets_reflexive(T0));
		X_in_NATURALS = equality_consistency[<S: S in NATURALS>](X, OTHER_X)(equal_X)(OTHER_X_in_NATURALS);
		Y_in_NATURALS = equality_consistency[<S: S in NATURALS>](Y, OTHER_Y)(equal_Y)(OTHER_Y_in_NATURALS);
		successor_SX, successor_Z1, addition_class_F1, tuple_T1, T1_in_F1 = addition_classes_cover_lemma(X)(X_in_NATURALS)(Y, T0, F0, Z0)(Z0_in_NATURALS, addition_class_F0, tuple_T0, T0_in_F0)|SX, T1, Z1, F1|;
		choose SX, T1, Z1;
		SX_in_NATURALS = closure_naturals(X, SX)(X_in_NATURALS, successor_SX);
		prove T1_in_C: ^SX^Y(SX in NATURALS & Y in NATURALS & is_tuple(SX, Y, T1)){
			choose SX, Y;
			return SX_in_NATURALS, Y_in_NATURALS, tuple_T1;
		}
		T1_in_C = C_def(T1)(T1_in_C);
		Z1_in_NATURALS = closure_naturals(Z0, Z1)(Z0_in_NATURALS, successor_Z1);
		prove addition_class_exists: ^F1(is_addition_class(Z1, F1) & T1 in F1){
			choose F1;
			return addition_class_F1, T1_in_F1;
		}
		related_T1Z1 = addition_function_definition(T1, Z1)(T1_in_C, Z1_in_NATURALS, addition_class_exists);
		return successor_SX, tuple_T1, related_T1Z1, successor_Z1;
	}

	//Holy shit!
	return #is_addition_function(ADDITION_FUNCTION)(ADDITION_FUNCTION_is_function, domain_exists, codomain_NATURALS, zero_identity, successor_recursion);
}

naturals_addition_function_definition = addition_function_exists|NATURALS_ADDITION_FUNCTION|;

define is_natural_sum(X, Y, Z): X in NATURALS & Y in NATURALS & ^T(is_tuple(X, Y, T) & are_related(T, Z, NATURALS_ADDITION_FUNCTION));

prove natural_sum_zero_identity: *X(X in NATURALS -> is_natural_sum(ZERO, X, X)){
	given |X|;
	implies X_in_NATURALS;
	is_function, domain_exists, codomain_NATURALS, zero_identity, successor_recursion = expand(naturals_addition_function_definition);
	cross_product_C, domain_C = domain_exists|C|;
	tuple_T = tuple(ZERO, X)|T|;
	prove T_in_C: ^ZERO^X(ZERO in NATURALS & X in NATURALS & is_tuple(ZERO, X, T)){
		choose ZERO, X;
		return zero_is_natural, X_in_NATURALS, tuple_T;
	}
	T_in_C = expand(cross_product_C)(T)(T_in_C);
	related_TX = zero_identity(X, T)(X_in_NATURALS, tuple_T);
	prove natural_sum: ^T(is_tuple(ZERO, X, T) & are_related(T, X, NATURALS_ADDITION_FUNCTION)){
		choose T;
		return tuple_T, related_TX;
	}
	return #is_natural_sum(ZERO, X, X)(zero_is_natural, X_in_NATURALS, natural_sum);
}

prove natural_sum_successor_recursion: *X*Y*Z(is_natural_sum(X, Y, Z) -> ^X1^Z1(is_successor(X, X1) & is_successor(Z, Z1) & is_natural_sum(X1, Y, Z1))){
	given |X, Y, Z|;
	implies Z_natural_sum;
	empty_in_naturals, closure_naturals = expand(NATURALS_inductive);
	X_in_NATURALS, Y_in_NATURALS, T_exists = expand(Z_natural_sum);
	tuple_T, related_TZ = T_exists|T|;
	is_function, domain_exists, codomain_NATURALS, zero_identity, successor_recursion = expand(naturals_addition_function_definition);
	successor_X1, tuple_T1, related_T1Z1, successor_Z1 = successor_recursion(X, Y, T, Z)(tuple_T, related_TZ)|X1, T1, Z1|;
	choose X1, Z1;
	prove natural_sum: ^T1(is_tuple(X1, Y, T1) & are_related(T1, Z1, NATURALS_ADDITION_FUNCTION)){
		choose T1;
		return tuple_T1, related_T1Z1;
	}
	X1_in_NATURALS = closure_naturals(X, X1)(X_in_NATURALS, successor_X1);
	natural_sum = #is_natural_sum(X1, Y, Z1)(X1_in_NATURALS, Y_in_NATURALS, natural_sum);
	return successor_X1, successor_Z1, natural_sum;
}

//We've bootstrapped the definition of addition so that we won't ever need the object "NATURALS_ADDITION_FUNCTION"
//We can use the "natural_sum" definition to calculate the sum of two natural numbers instead

//TIME TO PROVE THAT 2+2=4
prove TWO_plus_TWO_is_FOUR: is_natural_sum(TWO, TWO, FOUR){
	ZERO_plus_TWO = natural_sum_zero_identity(TWO)(two_is_natural);
	exists = natural_sum_successor_recursion(ZERO, TWO, TWO)(ZERO_plus_TWO);
	successor_OTHER_ONE, successor_OTHER_THREE, natural_sum = exists|OTHER_ONE, OTHER_THREE|;
	equal_ONE = successor_unique(ZERO, ONE, OTHER_ONE)(one_definition, successor_OTHER_ONE);
	equal_THREE = successor_unique(TWO, THREE, OTHER_THREE)(three_definition, successor_OTHER_THREE);
	natural_sum = equality_consistency[<S: is_natural_sum(OTHER_ONE, TWO, S)>](THREE, OTHER_THREE)(equal_THREE)(natural_sum);
	natural_sum = equality_consistency[<S: is_natural_sum(S, TWO, THREE)>](ONE, OTHER_ONE)(equal_ONE)(natural_sum);

	exists = natural_sum_successor_recursion(ONE, TWO, THREE)(natural_sum);
	successor_OTHER_TWO, successor_OTHER_FOUR, natural_sum = exists|OTHER_TWO, OTHER_FOUR|;
	equal_TWO = successor_unique(ONE, TWO, OTHER_TWO)(two_definition, successor_OTHER_TWO);
	equal_FOUR = successor_unique(THREE, FOUR, OTHER_FOUR)(four_definition, successor_OTHER_FOUR);
	natural_sum = equality_consistency[<S: is_natural_sum(OTHER_TWO, TWO, S)>](FOUR, OTHER_FOUR)(equal_FOUR)(natural_sum);
	return equality_consistency[<S: is_natural_sum(S, TWO, FOUR)>](TWO, OTHER_TWO)(equal_TWO)(natural_sum);
}

//Now we have to prove that the sum of two natural numbers actually exists
prove natural_sum: *X*Y(X in NATURALS & Y in NATURALS -> ^Z(Z in NATURALS & is_natural_sum(X, Y, Z))){
	given |X, Y|;
	implies X_in_NATURALS, Y_in_NATURALS;
	is_function, domain_exists, codomain_NATURALS, zero_identity, successor_recursion = expand(naturals_addition_function_definition);
	cross_product_C, domain_C = domain_exists|C|;
	tuple_T = tuple(X, Y)|T|;
	prove T_in_C: ^X^Y(X in NATURALS & Y in NATURALS & is_tuple(X, Y, T)){
		choose X, Y;
		return X_in_NATURALS, Y_in_NATURALS, tuple_T;
	}
	T_in_C = expand(cross_product_C)(T)(T_in_C);
	related_TZ = expand(domain_C)(T)(T_in_C)|Z|;
	choose Z;
	prove sum_Z: ^T(is_tuple(X, Y, T) & are_related(T, Z, NATURALS_ADDITION_FUNCTION)){
		choose T;
		return tuple_T, related_TZ;
	}
	Z_in_NATURALS = expand(codomain_NATURALS)(T, Z)(related_TZ);
	return Z_in_NATURALS, #is_natural_sum(X, Y, Z)(X_in_NATURALS, Y_in_NATURALS, sum_Z);
}

//We also have to prove that the sum of two natural numbers is unique
prove natural_sum_unique: *X*Y*Z0*Z1(is_natural_sum(X, Y, Z0) & is_natural_sum(X, Y, Z1) -> equal_sets(Z0, Z1)){
	given |X, Y, Z0, Z1|;
	implies natural_sum_Z0, natural_sum_Z1;
	is_function, domain_exists, codomain_NATURALS, zero_identity, successor_recursion = expand(naturals_addition_function_definition);
	X_in_NATURALS, Y_in_NATURALS, T0_exists = expand(natural_sum_Z0);
	X_in_NATURALS, Y_in_NATURALS, T1_exists = expand(natural_sum_Z1);
	tuple_T0, related_T0_Z0 = T0_exists|T0|;
	tuple_T1, related_T1_Z1 = T1_exists|T1|;
	equal_T = tuple_unique(X, Y, T0, T1)(tuple_T0, tuple_T1);
	related_T0_Z1 = equality_consistency[<S: are_related(S, Z1, NATURALS_ADDITION_FUNCTION)>](T0, T1)(equal_T)(related_T1_Z1);
	return expand(is_function)(T0, Z0, Z1)(related_T0_Z0, related_T0_Z1);
}

//Prove that if a natural sum exists then the sum must be a natural number
prove natural_sum_is_natural: *X*Y*Z(is_natural_sum(X, Y, Z) -> Z in NATURALS){
	given |X, Y, Z|;
	implies sum_Z;
	X_in_NATURALS, Y_in_NATURALS, tuple_exists = expand(sum_Z);
	OTHER_Z_in_NATURALS, other_sum_Z = natural_sum(X, Y)(X_in_NATURALS, Y_in_NATURALS)|OTHER_Z|;
	equal_Z = natural_sum_unique(X, Y, Z, OTHER_Z)(sum_Z, other_sum_Z);
	return equality_consistency[<Q: Q in NATURALS>](Z, OTHER_Z)(equal_Z)(OTHER_Z_in_NATURALS);
}

//Prove that addition commutes
//This is also a big theorem
prove natural_sum_commutative: *X*Y*Z(is_natural_sum(X, Y, Z) -> is_natural_sum(Y, X, Z)){
	empty_in_naturals, closure_naturals = expand(NATURALS_inductive);

	//First we have to prove that ZERO is a right identity
	prove identity_lemma: *X(X in NATURALS -> is_natural_sum(X, ZERO, X)){
		//Induction on X
		R_def = axiom_specify[<S: is_natural_sum(S, ZERO, S)>](NATURALS)|R|;
		ZERO_in_R = natural_sum_zero_identity(ZERO)(zero_is_natural);
		ZERO_in_R = R_def(ZERO)(zero_is_natural, ZERO_in_R);
		prove closure_R: *Y*Z(Y in R & is_successor(Y, Z) -> Z in R){
			given |Y, Z|;
			implies Y_in_R, successor_Z;
			Y_in_NATURALS, sum_Y_ZERO = R_def(Y)(Y_in_R);
			Z_in_NATURALS = closure_naturals(Y, Z)(Y_in_NATURALS, successor_Z);
			successor_OTHER_Z0, successor_OTHER_Z1, sum_Z_ZERO = natural_sum_successor_recursion(Y, ZERO, Y)(sum_Y_ZERO)|OTHER_Z0, OTHER_Z1|;
			Z0_equal_Z1 = successor_unique(Y, OTHER_Z0, OTHER_Z1)(successor_OTHER_Z0, successor_OTHER_Z1);
			Z_equal_Z0 = successor_unique(Y, Z, OTHER_Z0)(successor_Z, successor_OTHER_Z0);
			sum_Z_ZERO = equality_consistency[<S: is_natural_sum(OTHER_Z0, ZERO, S)>](OTHER_Z0, OTHER_Z1)(Z0_equal_Z1)(sum_Z_ZERO);
			sum_Z_ZERO = equality_consistency[<S: is_natural_sum(S, ZERO, S)>](Z, OTHER_Z0)(Z_equal_Z0)(sum_Z_ZERO);
			return R_def(Z)(Z_in_NATURALS, sum_Z_ZERO);
		}
		NATURALS_subset_R = NATURALS_induction(R)(ZERO_in_R, closure_R);
		given |X|;
		implies X_in_NATURALS;
		X_in_R = expand(NATURALS_subset_R)(X)(X_in_NATURALS);
		X_in_NATURALS, result = R_def(X)(X_in_R);
		return result;
	}

	prove commutative_lemma: *X*Y*Z*SZ(is_natural_sum(X, Y, Z) & is_successor(Z, SZ) -> ^SY(is_natural_sum(X, SY, SZ) & is_successor(Y, SY))){
		//Induction on X
		R_def = axiom_specify[<S: *Y*Z*SZ(is_natural_sum(S, Y, Z) & is_successor(Z, SZ) -> ^SY(is_natural_sum(S, SY, SZ) & is_successor(Y, SY)))>](NATURALS)|R|;
		prove ZERO_in_R: *Y*Z*SZ(is_natural_sum(ZERO, Y, Z) & is_successor(Z, SZ) -> ^SY(is_natural_sum(ZERO, SY, SZ) & is_successor(Y, SY))){
			given |Y, Z, SZ|;
			implies sum_Z, successor_SZ;
			ZERO_in_NATURALS, Y_in_NATURALS, tuple_exists = expand(sum_Z);
			sum_Y = natural_sum_zero_identity(Y)(Y_in_NATURALS);
			equal_Y_Z = natural_sum_unique(ZERO, Y, Y, Z)(sum_Y, sum_Z);
			successor_SY = successor(Y)|SY|;
			choose SY;
			SY_in_NATURALS = closure_naturals(Y, SY)(Y_in_NATURALS, successor_SY);
			other_successor_SY = equality_consistency[<S: is_successor(S, SY)>](Y, Z)(equal_Y_Z)(successor_SY);
			SY_equal_SZ = successor_unique(Z, SY, SZ)(other_successor_SY, successor_SZ);
			sum_SY = natural_sum_zero_identity(SY)(SY_in_NATURALS);
			sum_SZ = equality_consistency[<S: is_natural_sum(ZERO, SY, S)>](SY, SZ)(SY_equal_SZ)(sum_SY);
			return sum_SZ, successor_SY;
		}
		ZERO_in_R = R_def(ZERO)(zero_is_natural, ZERO_in_R);
		prove closure_R: *X*SX(X in R & is_successor(X, SX) -> SX in R){
			given |X, SX|;
			implies X_in_R, successor_SX;
			X_in_NATURALS, X_condition = R_def(X)(X_in_R);
			SX_in_NATURALS = closure_naturals(X, SX)(X_in_NATURALS, successor_SX);
			prove SX_in_R: *Y*Z*SZ(is_natural_sum(SX, Y, Z) & is_successor(Z, SZ) -> ^SY(is_natural_sum(SX, SY, SZ) & is_successor(Y, SY))){
				given |Y, Z, SZ|;
				implies sum_Z, successor_SZ;
				SX_in_NATURALS, Y_in_NATURALS, exists_tuple = expand(sum_Z);
				PZ_in_NATURALS, sum_PZ = natural_sum(X, Y)(X_in_NATURALS, Y_in_NATURALS)|PZ|;
				other_successor_SX, other_successor_Z, other_sum_Z = natural_sum_successor_recursion(X, Y, PZ)(sum_PZ)|OTHER_SX, OTHER_Z|;
				equal_SX = successor_unique(X, SX, OTHER_SX)(successor_SX, other_successor_SX);
				other_sum_Z = equality_consistency[<S: is_natural_sum(S, Y, OTHER_Z)>](SX, OTHER_SX)(equal_SX)(other_sum_Z);
				equal_Z = natural_sum_unique(SX, Y, Z, OTHER_Z)(sum_Z, other_sum_Z);
				successor_Z = equality_consistency[<S: is_successor(PZ, S)>](Z, OTHER_Z)(equal_Z)(other_successor_Z);
				sum_X_SY, successor_SY = X_condition(Y, PZ, Z)(sum_PZ, successor_Z)|SY|;
				choose SY;

				successor_OTHER_SX_2, successor_OTHER_SZ, other_sum_SZ = natural_sum_successor_recursion(X, SY, Z)(sum_X_SY)|OTHER_SX_2, OTHER_SZ|;
				equal_SX = successor_unique(X, SX, OTHER_SX_2)(successor_SX, successor_OTHER_SX_2);
				other_sum_SZ = equality_consistency[<S: is_natural_sum(S, SY, OTHER_SZ)>](SX, OTHER_SX_2)(equal_SX)(other_sum_SZ);
				equal_SZ = successor_unique(Z, SZ, OTHER_SZ)(successor_SZ, successor_OTHER_SZ);
				return equality_consistency[<S: is_natural_sum(SX, SY, S)>](SZ, OTHER_SZ)(equal_SZ)(other_sum_SZ), successor_SY;
			}
			return R_def(SX)(SX_in_NATURALS, SX_in_R);
		}
		NATURALS_subset_R = NATURALS_induction(R)(ZERO_in_R, closure_R);
		given |X, Y, Z, SZ|;
		implies sum_Z, successor_SZ;
		X_in_NATURALS, Y_in_NATURALS, tuple_exists = expand(sum_Z);
		X_in_R = expand(NATURALS_subset_R)(X)(X_in_NATURALS);
		X_in_NATURALS, result = R_def(X)(X_in_R);
		return result(Y, Z, SZ)(sum_Z, successor_SZ);
	}

	R_def = axiom_specify[<S: *Y*Z(is_natural_sum(S, Y, Z) -> is_natural_sum(Y, S, Z))>](NATURALS)|R|;

	prove ZERO_in_R: *Y*Z(is_natural_sum(ZERO, Y, Z) -> is_natural_sum(Y, ZERO, Z)){
		given |Y, Z|;
		implies sum_Z;
		ZERO_in_NATURALS, Y_in_NATURALS, tuple_exists = expand(sum_Z);
		sum_Y = natural_sum_zero_identity(Y)(Y_in_NATURALS);
		equal_Y_Z = natural_sum_unique(ZERO, Y, Y, Z)(sum_Y, sum_Z);
		sum_Y = identity_lemma(Y)(Y_in_NATURALS);
		return equality_consistency[<S: is_natural_sum(Y, ZERO, S)>](Y, Z)(equal_Y_Z)(sum_Y);
	}
	ZERO_in_R = R_def(ZERO)(zero_is_natural, ZERO_in_R);

	prove closure_R: *Y*Y1(Y in R & is_successor(Y, Y1) -> Y1 in R){
		given |Y, Y1|;
		implies Y_in_R, successor_Y1;
		Y_in_NATURALS, Y_condition = R_def(Y)(Y_in_R);
		Y1_in_NATURALS = closure_naturals(Y, Y1)(Y_in_NATURALS, successor_Y1);
		prove Y1_in_R: *R*S(is_natural_sum(Y1, R, S) -> is_natural_sum(R, Y1, S)){
			given |R, S|;
			implies sum_S;
			Y1_in_NATURALS, R_in_NATURALS, tuple_exists = expand(sum_S);
			PS_in_NATURALS, old_sum_PS = natural_sum(Y, R)(Y_in_NATURALS, R_in_NATURALS)|PS|;
			sum_PS = Y_condition(R, PS)(old_sum_PS);
			successor_OTHER_S = successor(PS)|OTHER_S|;
			sum_OTHER_S, other_successor_Y1 = commutative_lemma(R, Y, PS, OTHER_S)(sum_PS, successor_OTHER_S)|OTHER_Y1|;
			equal_Y1 = successor_unique(Y, Y1, OTHER_Y1)(successor_Y1, other_successor_Y1);
			sum_OTHER_S = equality_consistency[<Q: is_natural_sum(R, Q, OTHER_S)>](Y1, OTHER_Y1)(equal_Y1)(sum_OTHER_S);
			successor_OTHER_Y1_2, successor_OTHER_S_2, sum_OTHER_S_2 = natural_sum_successor_recursion(Y, R, PS)(old_sum_PS)|OTHER_Y1_2, OTHER_S_2|;
			equal_Y1_2 = successor_unique(Y, Y1, OTHER_Y1_2)(successor_Y1, successor_OTHER_Y1_2);
			equal_others_S = successor_unique(PS, OTHER_S, OTHER_S_2)(successor_OTHER_S, successor_OTHER_S_2);
			other_sum = equality_consistency[<Q: is_natural_sum(Q, R, OTHER_S_2)>](Y1, OTHER_Y1_2)(equal_Y1_2)(sum_OTHER_S_2);
			other_sum = equality_consistency[<Q: is_natural_sum(Y1, R, Q)>](OTHER_S, OTHER_S_2)(equal_others_S)(other_sum);
			equal_S = natural_sum_unique(Y1, R, S, OTHER_S)(sum_S, other_sum);
			return equality_consistency[<Q: is_natural_sum(R, Y1, Q)>](S, OTHER_S)(equal_S)(sum_OTHER_S);
		}
		return R_def(Y1)(Y1_in_NATURALS, Y1_in_R);
	}

	NATURALS_subset_R = NATURALS_induction(R)(ZERO_in_R, closure_R);
	given |X, Y, Z|;
	implies sum_Z;
	X_in_NATURALS, Y_in_NATURALS, tuple_exists = expand(sum_Z);
	X_in_R = expand(NATURALS_subset_R)(X)(X_in_NATURALS);
	X_in_NATURALS, result = R_def(X)(X_in_R);
	return result(Y, Z)(sum_Z);
}

//Prove that addition is associative
prove natural_sum_associative: *X*Y*Z*S*SXY*SYZ(is_natural_sum(X, Y, SXY) & is_natural_sum(SXY, Z, S) & is_natural_sum(Y, Z, SYZ) -> is_natural_sum(X, SYZ, S)){
	empty_in_NATURALS, closure_naturals = expand(NATURALS_inductive);
	//By induction
	R_def = axiom_specify[<Q: *Y*Z*S*SXY*SYZ(is_natural_sum(Q, Y, SXY) & is_natural_sum(SXY, Z, S) & is_natural_sum(Y, Z, SYZ) -> is_natural_sum(Q, SYZ, S))>](NATURALS)|R|;
	prove ZERO_in_R: *Y*Z*S*SXY*SYZ(is_natural_sum(ZERO, Y, SXY) & is_natural_sum(SXY, Z, S) & is_natural_sum(Y, Z, SYZ) -> is_natural_sum(ZERO, SYZ, S)){
		given |Y, Z, S, SXY, SYZ|;
		implies sum_SXY, sum_S, sum_SYZ;
		ZERO_in_NATURALS, Y_in_NATURALS, tuple_exists = expand(sum_SXY);
		SXY_in_NATURALS, Z_in_NATURALS, tuple_exists = expand(sum_S);
		other_sum_SXY = natural_sum_zero_identity(Y)(Y_in_NATURALS);
		equal_Y_SXY = natural_sum_unique(ZERO, Y, Y, SXY)(other_sum_SXY, sum_SXY);
		sum_S = equality_consistency[<Q: is_natural_sum(Q, Z, S)>](Y, SXY)(equal_Y_SXY)(sum_S);
		equal_S_SYZ = natural_sum_unique(Y, Z, S, SYZ)(sum_S, sum_SYZ);
		
		OTHER_S_in_NATURALS, other_sum_S = natural_sum(Y, Z)(Y_in_NATURALS, Z_in_NATURALS)|OTHER_S|;
		equal_S = natural_sum_unique(Y, Z, S, OTHER_S)(sum_S, other_sum_S);
		S_in_NATURALS = equality_consistency[<Q: Q in NATURALS>](S, OTHER_S)(equal_S)(OTHER_S_in_NATURALS);

		sum_S = natural_sum_zero_identity(S)(S_in_NATURALS);
		return equality_consistency[<Q: is_natural_sum(ZERO, Q, S)>](S, SYZ)(equal_S_SYZ)(sum_S);
	}
	ZERO_in_R = R_def(ZERO)(zero_is_natural, ZERO_in_R);
	prove closure_R: *K*K1(K in R & is_successor(K, K1) -> K1 in R){
		given |K, K1|;
		implies K_in_R, successor_K1;
		K_in_NATURALS, K_condition = R_def(K)(K_in_R);
		K1_in_NATURALS = closure_naturals(K, K1)(K_in_NATURALS, successor_K1);
		prove K1_in_R: *Y*Z*S*SXY*SYZ(is_natural_sum(K1, Y, SXY) & is_natural_sum(SXY, Z, S) & is_natural_sum(Y, Z, SYZ) -> is_natural_sum(K1, SYZ, S)){
			given |Y, Z, S, SXY, SYZ|;
			implies sum_SXY, sum_S, sum_SYZ;
			Y_in_NATURALS, Z_in_NATURALS, tuple_exists = expand(sum_SYZ);
			P_SXY_in_NATURALS, sum_P_SXY = natural_sum(K, Y)(K_in_NATURALS, Y_in_NATURALS)|P_SXY|;
			other_successor_K1, other_successor_SXY, other_sum_SXY = natural_sum_successor_recursion(K, Y, P_SXY)(sum_P_SXY)|OTHER_K1, OTHER_SXY|;
			equal_K1 = successor_unique(K, K1, OTHER_K1)(successor_K1, other_successor_K1);
			other_sum_SXY = equality_consistency[<Q: is_natural_sum(Q, Y, OTHER_SXY)>](K1, OTHER_K1)(equal_K1)(other_sum_SXY);
			equal_SXY = natural_sum_unique(K1, Y, SXY, OTHER_SXY)(sum_SXY, other_sum_SXY);
			successor_SXY = equality_consistency[<Q: is_successor(P_SXY, Q)>](SXY, OTHER_SXY)(equal_SXY)(other_successor_SXY);

			P_S_in_NATURALS, sum_P_S = natural_sum(P_SXY, Z)(P_SXY_in_NATURALS, Z_in_NATURALS)|P_S|;
			other_successor_SXY, other_successor_S, other_sum_S = natural_sum_successor_recursion(P_SXY, Z, P_S)(sum_P_S)|OTHER_SXY_2, OTHER_S|;
			equal_SXY = successor_unique(P_SXY, SXY, OTHER_SXY_2)(successor_SXY, other_successor_SXY);
			other_sum_S = equality_consistency[<Q: is_natural_sum(Q, Z, OTHER_S)>](SXY, OTHER_SXY_2)(equal_SXY)(other_sum_S);
			equal_S = natural_sum_unique(SXY, Z, S, OTHER_S)(sum_S, other_sum_S);
			successor_S = equality_consistency[<Q: is_successor(P_S, Q)>](S, OTHER_S)(equal_S)(other_successor_S);

			sum_P_S = K_condition(Y, Z, P_S, P_SXY, SYZ)(sum_P_SXY, sum_P_S, sum_SYZ);

			other_successor_K1, other_successor_S, other_sum_S = natural_sum_successor_recursion(K, SYZ, P_S)(sum_P_S)|OTHER_K1_2, OTHER_S_2|;
			equal_K1 = successor_unique(K, K1, OTHER_K1_2)(successor_K1, other_successor_K1);
			other_sum_S = equality_consistency[<Q: is_natural_sum(Q, SYZ, OTHER_S_2)>](K1, OTHER_K1_2)(equal_K1)(other_sum_S);
			equal_S = successor_unique(P_S, S, OTHER_S_2)(successor_S, other_successor_S);
			return equality_consistency[<Q: is_natural_sum(K1, SYZ, Q)>](S, OTHER_S_2)(equal_S)(other_sum_S);
		}
		return R_def(K1)(K1_in_NATURALS, K1_in_R);
	}
	NATURALS_subset_R = NATURALS_induction(R)(ZERO_in_R, closure_R);
	given |X, Y, Z, S, SXY, SYZ|;
	implies sum_SXY, sum_S, sum_SYZ;
	X_in_NATURALS, Y_in_NATURALS, tuple_exists = expand(sum_SXY);
	X_in_R = expand(NATURALS_subset_R)(X)(X_in_NATURALS);
	X_in_NATURALS, result = R_def(X)(X_in_R);
	return result(Y, Z, S, SXY, SYZ)(sum_SXY, sum_S, sum_SYZ);
}

//Prove associativity in the other direction
//We can actually just use the previous proof and commutativity. Watch!
prove natural_sum_associative2: *X*Y*Z*S*SXY*SYZ(is_natural_sum(Y, Z, SYZ) & is_natural_sum(X, SYZ, S) & is_natural_sum(X, Y, SXY) -> is_natural_sum(SXY, Z, S)){
	given |X, Y, Z, S, SXY, SYZ|;
	implies sum_SYZ, sum_S, sum_SXY;
	sum_S = natural_sum_commutative(X, SYZ, S)(sum_S);
	sum_SYZ = natural_sum_commutative(Y, Z, SYZ)(sum_SYZ);
	sum_SXY = natural_sum_commutative(X, Y, SXY)(sum_SXY);
	sum_S = natural_sum_associative(Z, Y, X, S, SYZ, SXY)(sum_SYZ, sum_S, sum_SXY);
	return natural_sum_commutative(Z, SXY, S)(sum_S);
}

//Prove the cancellation property of addition
//This is exciting!
prove natural_sum_cancellation: *X*Y*Z*S(is_natural_sum(X, Y, S) & is_natural_sum(X, Z, S) -> equal_sets(Y, Z)){
	empty_in_NATURALS, closure_naturals = expand(NATURALS_inductive);
	//We use induction here :)
	R_def = axiom_specify[<Q: *Y*Z*S(is_natural_sum(Q, Y, S) & is_natural_sum(Q, Z, S) -> equal_sets(Y, Z))>](NATURALS)|R|;

	prove ZERO_in_R: *Y*Z*S(is_natural_sum(ZERO, Y, S) & is_natural_sum(ZERO, Z, S) -> equal_sets(Y, Z)){
		given |Y, Z, S|;
		implies sum0, sum1;
		ZERO_in_NATURALS, Y_in_NATURALS, tuple_exists = expand(sum0);
		ZERO_in_NATURALS, Z_in_NATURALS, tuple_exists = expand(sum1);
		sum_Y = natural_sum_zero_identity(Y)(Y_in_NATURALS);
		equal_YS = natural_sum_unique(ZERO, Y, Y, S)(sum_Y, sum0);
		sum_Z = natural_sum_zero_identity(Z)(Z_in_NATURALS);
		equal_ZS = natural_sum_unique(ZERO, Z, Z, S)(sum_Z, sum1);
		return equality_consistency[<Q: equal_sets(Y, Q)>](Z, S)(equal_ZS)(equal_YS);
	}

	ZERO_in_R = R_def(ZERO)(zero_is_natural, ZERO_in_R);

	prove closure_R: *S*S1(S in R & is_successor(S, S1) -> S1 in R){
		given |S, S1|;
		implies S_in_R, successor_S1;
		S_in_NATURALS, S_condition = R_def(S)(S_in_R);
		S1_in_NATURALS = closure_naturals(S, S1)(S_in_NATURALS, successor_S1);
		prove S1_condition: *Y*Z*SUM(is_natural_sum(S1, Y, SUM) & is_natural_sum(S1, Z, SUM) -> equal_sets(Y, Z)){
			given |Y, Z, SUM|;
			implies sum_S1_Y, sum_S1_Z;
			S1_in_NATURALS, Y_in_NATURALS, tuple_exists = expand(sum_S1_Y);
			S1_in_NATURALS, Z_in_NATURALS, tuple_exists = expand(sum_S1_Z);
			P_SUM_Y_in_NATURALS, sum_P_Y = natural_sum(S, Y)(S_in_NATURALS, Y_in_NATURALS)|P_SUM_Y|;
			P_SUM_Z_in_NATURALS, sum_P_Z = natural_sum(S, Z)(S_in_NATURALS, Z_in_NATURALS)|P_SUM_Z|;

			other_successor_S1, predecessor_P_SUM_Y, other_sum_S1_Y = natural_sum_successor_recursion(S, Y, P_SUM_Y)(sum_P_Y)|OTHER_S1, SUM_Y|;
			equal_S1 = successor_unique(S, S1, OTHER_S1)(successor_S1, other_successor_S1);
			other_sum_S1_Y = equality_consistency[<Q: is_natural_sum(Q, Y, SUM_Y)>](S1, OTHER_S1)(equal_S1)(other_sum_S1_Y);
			equal_SUM_Y = natural_sum_unique(S1, Y, SUM, SUM_Y)(sum_S1_Y, other_sum_S1_Y);
			predecessor_P_SUM_Y = equality_consistency[<Q: is_successor(P_SUM_Y, Q)>](SUM, SUM_Y)(equal_SUM_Y)(predecessor_P_SUM_Y);

			other_successor_S1, predecessor_P_SUM_Z, other_sum_S1_Z = natural_sum_successor_recursion(S, Z, P_SUM_Z)(sum_P_Z)|OTHER_S1_2, SUM_Z|;
			equal_S1 = successor_unique(S, S1, OTHER_S1_2)(successor_S1, other_successor_S1);
			other_sum_S1_Z = equality_consistency[<Q: is_natural_sum(Q, Z, SUM_Z)>](S1, OTHER_S1_2)(equal_S1)(other_sum_S1_Z);
			equal_SUM_Z = natural_sum_unique(S1, Z, SUM, SUM_Z)(sum_S1_Z, other_sum_S1_Z);
			predecessor_P_SUM_Z = equality_consistency[<Q: is_successor(P_SUM_Z, Q)>](SUM, SUM_Z)(equal_SUM_Z)(predecessor_P_SUM_Z);

			equal_P_SUM = predecessor_unique(P_SUM_Y, P_SUM_Z, SUM)(predecessor_P_SUM_Y, predecessor_P_SUM_Z);
			sum_P_Z = equality_consistency[<Q: is_natural_sum(S, Z, Q)>](P_SUM_Y, P_SUM_Z)(equal_P_SUM)(sum_P_Z);
			return S_condition(Y, Z, P_SUM_Y)(sum_P_Y, sum_P_Z);
		}
		return R_def(S1)(S1_in_NATURALS, S1_condition);
	}

	NATURALS_subset_R = NATURALS_induction(R)(ZERO_in_R, closure_R);
	given |X, Y, Z, S|;
	implies sum0, sum1;
	X_in_NATURALS, Y_in_NATURALS, tuple_exists = expand(sum0);
	X_in_R = expand(NATURALS_subset_R)(X)(X_in_NATURALS);
	X_in_NATURALS, result = R_def(X)(X_in_R);
	return result(Y, Z, S)(sum0, sum1);
}

//Prove that 1+n = S(n)
prove natural_sum_successor: *N*M(is_natural_sum(N, ONE, M) -> is_successor(N, M)){
	empty_in_NATURALS, closure_naturals = expand(NATURALS_inductive);
	R_def = axiom_specify[<Q: *M(is_natural_sum(Q, ONE, M) -> is_successor(Q, M))>](NATURALS)|R|;

	prove ZERO_in_R: *M(is_natural_sum(ZERO, ONE, M) -> is_successor(ZERO, M)){
		given |M|;
		implies sum_M;
		other_sum_M = natural_sum_zero_identity(ONE)(one_is_natural);
		equal_M_ONE = natural_sum_unique(ZERO, ONE, M, ONE)(sum_M, other_sum_M);
		return equality_consistency[<Q: is_successor(ZERO, Q)>](M, ONE)(equal_M_ONE)(one_definition);
	}

	ZERO_in_R = R_def(ZERO)(zero_is_natural, ZERO_in_R);

	prove closure_R: *K*N(K in R & is_successor(K, N) -> N in R){
		given |K, N|;
		implies K_in_R, successor_N;
		K_in_NATURALS, K_cond = R_def(K)(K_in_R);
		N_in_NATURALS = closure_naturals(K, N)(K_in_NATURALS, successor_N);
		OTHER_N_in_NATURALS, sum_OTHER_N = natural_sum(K, ONE)(K_in_NATURALS, one_is_natural)|OTHER_N|;
		successor_other_N = K_cond(OTHER_N)(sum_OTHER_N);
		equal_N = successor_unique(K, N, OTHER_N)(successor_N, successor_other_N);
		sum_N = equality_consistency[<Q: is_natural_sum(K, ONE, Q)>](N, OTHER_N)(equal_N)(sum_OTHER_N);
		successor_other_N2, successor_M, sum_M = natural_sum_successor_recursion(K, ONE, N)(sum_N)|OTHER_N2, M|;
		equal_N = successor_unique(K, N, OTHER_N2)(successor_N, successor_other_N2);
		sum_M = equality_consistency[<Q: is_natural_sum(Q, ONE, M)>](N, OTHER_N2)(equal_N)(sum_M);
		prove N_cond: *M_OTHER(is_natural_sum(N, ONE, M_OTHER) -> is_successor(N, M_OTHER)){
			given |M_OTHER|;
			implies other_sum_M;
			equal_M = natural_sum_unique(N, ONE, M, M_OTHER)(sum_M, other_sum_M);
			return equality_consistency[<Q: is_successor(N, Q)>](M, M_OTHER)(equal_M)(successor_M);
		}
		return R_def(N)(N_in_NATURALS, N_cond);
	}
	NATURALS_subset_R = NATURALS_induction(R)(ZERO_in_R, closure_R);

	given |N, M|;
	implies sum_M;
	N_in_NATURALS, ONE_in_NATURALS, tuple_exists = expand(sum_M);
	N_in_R = expand(NATURALS_subset_R)(N)(N_in_NATURALS);
	N_in_NATURALS, result = R_def(N)(N_in_R);

	return result(M)(sum_M);
}

//Define when one natural number is (strictly) less than another
//Note that A < B in this case is just that A in B
//This is due to our construction of the naturals
define natural_less_than(A, B): A in B;

//A small lemma, for sure
prove natural_less_than_successor: *A*A1(is_successor(A, A1) -> natural_less_than(A, A1)){
	given |A, A1|;
	implies successor_A1;
	A_in_A1 = expand(successor_A1)(A)(or(<:A in A>, equal_sets_reflexive(A)));
	return #natural_less_than(A, A1)(A_in_A1);
}

//Prove that every set either equals zero or is greater than zero
prove natural_zero_minimal: *N(N in NATURALS -> equal_sets(ZERO, N) | natural_less_than(ZERO, N)){
	empty_in_naturals, closure_naturals = expand(NATURALS_inductive);
	R_def = axiom_specify[<Q: Q in NATURALS -> equal_sets(ZERO, Q) | natural_less_than(ZERO, Q)>](NATURALS)|R|;
	prove ZERO_in_R: ZERO in NATURALS -> equal_sets(ZERO, ZERO) | natural_less_than(ZERO, ZERO){
		implies ZERO_in_NATURALS;
		return or(equal_sets_reflexive(ZERO), <:natural_less_than(ZERO, ZERO)>);
	}
	ZERO_in_R = R_def(ZERO)(zero_is_natural, ZERO_in_R);
	prove closure_R: *N*N1(N in R & is_successor(N, N1) -> N1 in R){
		given |N, N1|;
		implies N_in_R, successor_N1;
		N_in_NATURALS, N_cond = R_def(N)(N_in_R);
		N1_in_NATURALS = closure_naturals(N, N1)(N_in_NATURALS, successor_N1);
		prove N1_cond: N1 in NATURALS -> equal_sets(ZERO, N1) | natural_less_than(ZERO, N1){
			implies N1_in_NATURALS;
			return branch(N_cond(N_in_NATURALS), equal_ZERO_N, ZERO_less_than_N){
				N_less_than_N1 = natural_less_than_successor(N, N1)(successor_N1);
				return or(<:equal_sets(ZERO, N1)>, equality_consistency[<Q: natural_less_than(Q, N1)>](ZERO, N)(equal_ZERO_N)(N_less_than_N1));
			} or {
				ZERO_in_N = expand(ZERO_less_than_N);
				ZERO_in_N1 = expand(successor_N1)(ZERO)(or(ZERO_in_N, <:equal_sets(ZERO, N)>));
				return or(<:equal_sets(ZERO, N1)>, #natural_less_than(ZERO, N1)(ZERO_in_N1));
			};
		}
		return R_def(N1)(N1_in_NATURALS, N1_cond);
	}
	NATURALS_subset_R = NATURALS_induction(R)(ZERO_in_R, closure_R);
	given |N|;
	implies N_in_NATURALS;
	N_in_R = expand(NATURALS_subset_R)(N)(N_in_NATURALS);
	N_in_NATURALS, result = R_def(N)(N_in_R);
	return result(N_in_NATURALS);
}

//Prove that the only sets less than a natural number are natural numbers
//By our definition of less than, this supports our interpretation of the naturals: it says that
//n = {0, 1, 2, ..., n - 1}
prove natural_less_than_natural: *N*M(M in NATURALS & natural_less_than(N, M) -> N in NATURALS){
	empty_in_NATURALS, closure_naturals = expand(NATURALS_inductive);
	R_def = axiom_specify[<Q: *N(Q in NATURALS & natural_less_than(N, Q) -> N in NATURALS)>](NATURALS)|R|;

	prove ZERO_in_R: *N(ZERO in NATURALS & natural_less_than(N, ZERO) -> N in NATURALS){
		given |N|;
		implies ZERO_in_NATURALS, N_less_than_ZERO;
		N_in_ZERO = expand(N_less_than_ZERO);
		N_in_EMPTY_SET = equality_consistency[<Q: N in Q>](EMPTY_SET, ZERO)(zero_definition)(N_in_ZERO);
		absurdity = empty_set_condition(N)(N_in_EMPTY_SET);
		return axiom_absurdity[goal](absurdity);
	}
	ZERO_in_R = R_def(ZERO)(zero_is_natural, ZERO_in_R);

	prove closure_R: *N*M(N in R & is_successor(N, M) -> M in R){
		given |N, M|;
		implies N_in_R, successor_M;
		N_in_NATURALS, N_cond = R_def(N)(N_in_R);
		M_in_NATURALS = closure_naturals(N, M)(N_in_NATURALS, successor_M);
		prove M_cond: *K(M in NATURALS & natural_less_than(K, M) -> K in NATURALS){
			given |K|;
			implies M_in_NATURALS, K_less_than_M;
			K_in_M = expand(K_less_than_M);
			return branch(expand(successor_M)(K)(K_in_M), K_in_N, K_equal_N){
				return N_cond(K)(N_in_NATURALS, #natural_less_than(K, N)(K_in_N));
			} or {
				return equality_consistency[<Q: Q in NATURALS>](K, N)(K_equal_N)(N_in_NATURALS);
			};
		}
		return R_def(M)(M_in_NATURALS, M_cond);
	}

	NATURALS_subset_R = NATURALS_induction(R)(ZERO_in_R, closure_R);
	given |N, M|;
	implies M_in_NATURALS, N_less_than_M;
	M_in_R = expand(NATURALS_subset_R)(M)(M_in_NATURALS);
	M_in_NATURALS, result = R_def(M)(M_in_R);
	return result(N)(M_in_NATURALS, N_less_than_M);
}

//Proving that less than is transitive is a little more difficult due to our definition of less than
//We need this lemma
prove natural_less_than_successor_weaken: *N*N1*M(N in NATURALS & is_successor(N, N1) & M in NATURALS -> (natural_less_than(N, M) <-> equal_sets(N1, M) | natural_less_than(N1, M))){
	empty_in_naturals, closure_naturals = expand(NATURALS_inductive);

	given |N, N1, M|;
	implies N_in_NATURALS, successor_N1, M_in_NATURALS;
	N_in_N1 = expand(successor_N1)(N)(or(<:N in N>, equal_sets_reflexive(N)));
	prove lemma0: natural_less_than(N, M) -> equal_sets(N1, M) | natural_less_than(N1, M){
		//induct on M
		R_def = axiom_specify[<Q: natural_less_than(N, Q) -> equal_sets(N1, Q) | natural_less_than(N1, Q)>](NATURALS)|R|;
		prove ZERO_in_R: natural_less_than(N, ZERO) -> equal_sets(N1, ZERO) | natural_less_than(N1, ZERO){
			implies N_less_than_ZERO;
			N_in_ZERO = expand(N_less_than_ZERO);
			N_in_EMPTY_SET = equality_consistency[<Q: N in Q>](EMPTY_SET, ZERO)(zero_definition)(N_in_ZERO);
			absurdity = empty_set_condition(N)(N_in_EMPTY_SET);
			return axiom_absurdity[goal](absurdity);
		}
		ZERO_in_R = R_def(ZERO)(zero_is_natural, ZERO_in_R);

		prove closure_R: *K*K1(K in R & is_successor(K, K1) -> K1 in R){
			given |K, K1|;
			implies K_in_R, successor_K1;
			K_in_NATURALS, K_cond = R_def(K)(K_in_R);
			K1_in_NATURALS = closure_naturals(K, K1)(K_in_NATURALS, successor_K1);
			prove K1_in_R: natural_less_than(N, K1) -> equal_sets(N1, K1) | natural_less_than(N1, K1){
				implies N_less_than_K1;
				N_in_K1 = expand(N_less_than_K1);
				N_in_K_or_N_equal_K = expand(successor_K1)(N)(N_in_K1);
				return branch(N_in_K_or_N_equal_K, N_in_K, N_equal_K){
					N_less_than_K = #natural_less_than(N, K)(N_in_K);
					N1_equal_K_or_N1_less_than_K = K_cond(N_less_than_K);
					return branch(N1_equal_K_or_N1_less_than_K, N1_equal_K, N1_less_than_K){
						N1_in_K1 = expand(successor_K1)(N1)(or(<:N1 in K>, N1_equal_K));
						N1_less_than_K1 = #natural_less_than(N1, K1)(N1_in_K1);
						return or(<:equal_sets(N1, K1)>, N1_less_than_K1);
					} or {
						N1_in_K = expand(N1_less_than_K);
						N1_in_K1 = expand(successor_K1)(N1)(or(N1_in_K, <:equal_sets(N1, K)>));
						N1_less_than_K1 = #natural_less_than(N1, K1)(N1_in_K1);
						return or(<:equal_sets(N1, K1)>, N1_less_than_K1);
					};
				} or {
					other_successor_K1 = equality_consistency[<Q: is_successor(Q, K1)>](N, K)(N_equal_K)(successor_K1);
					N1_equal_K1 = successor_unique(N, N1, K1)(successor_N1, other_successor_K1);
					return or(N1_equal_K1, <:natural_less_than(N1, K1)>);
				};
			}
			return R_def(K1)(K1_in_NATURALS, K1_in_R);
		}

		NATURALS_subset_R = NATURALS_induction(R)(ZERO_in_R, closure_R);
		M_in_R = expand(NATURALS_subset_R)(M)(M_in_NATURALS);
		M_in_NATURALS, result = R_def(M)(M_in_R);
		return result;
	}

	prove M_lemma: *M(M in NATURALS & natural_less_than(N1, M) -> natural_less_than(N, M)){
		//Induct on M
		R_def = axiom_specify[<Q: Q in NATURALS & natural_less_than(N1, Q) -> natural_less_than(N, Q)>](NATURALS)|R|;
		prove ZERO_in_R: ZERO in NATURALS & natural_less_than(N1, ZERO) -> natural_less_than(N, ZERO){
			implies ZERO_in_NATURALS, N1_less_than_ZERO;
			N1_in_ZERO = expand(N1_less_than_ZERO);
			N1_in_EMPTY_SET = equality_consistency[<Q: N1 in Q>](EMPTY_SET, ZERO)(zero_definition)(N1_in_ZERO);
			absurdity = empty_set_condition(N1)(N1_in_EMPTY_SET);
			return axiom_absurdity[goal](absurdity);
		}
		ZERO_in_R = R_def(ZERO)(zero_is_natural, ZERO_in_R);

		prove closure_R: *M*M1(M in R & is_successor(M, M1) -> M1 in R){
			given |M, M1|;
			implies M_in_R, successor_M1;
			M_in_NATURALS, M_cond = R_def(M)(M_in_R);
			M1_in_NATURALS = closure_naturals(M, M1)(M_in_NATURALS, successor_M1);
			prove M1_cond: M1 in NATURALS & natural_less_than(N1, M1) -> natural_less_than(N, M1){
				implies M1_in_NATURALS, N1_less_than_M1;
				N1_in_M1 = expand(N1_less_than_M1);
				N_in_M = branch(expand(successor_M1)(N1)(N1_in_M1), N1_in_M, N1_equal_M){
					N1_less_than_M = #natural_less_than(N1, M)(N1_in_M);
					N_less_than_M = M_cond(M_in_NATURALS, N1_less_than_M);
					return expand(N_less_than_M);
				} or {
					return equality_consistency[<Q: N in Q>](N1, M)(N1_equal_M)(N_in_N1);
				};
				N_in_M1 = expand(successor_M1)(N)(or(N_in_M, <:equal_sets(N, M)>));
				return #natural_less_than(N, M1)(N_in_M1);
			}
			return R_def(M1)(M1_in_NATURALS, M1_cond);
		}

		NATURALS_subset_R = NATURALS_induction(R)(ZERO_in_R, closure_R);
		given |M|;
		implies M_in_NATURALS, N1_less_than_M;
		M_in_R = expand(NATURALS_subset_R)(M)(M_in_NATURALS);
		M_in_NATURALS, result = R_def(M)(M_in_R);

		return result(M_in_NATURALS, N1_less_than_M);
	}

	prove lemma1: equal_sets(N1, M) | natural_less_than(N1, M) -> natural_less_than(N, M){
		implies either_premise;
		return branch(either_premise, N1_equal_M, N1_less_than_M){
			N_in_M = equality_consistency[<Q: N in Q>](N1, M)(N1_equal_M)(N_in_N1);
			return #natural_less_than(N, M)(N_in_M);
		} or {
			return M_lemma(M)(M_in_NATURALS, N1_less_than_M);
		};
	}

	return iff(lemma0, lemma1);
}

//Proving that less than is transitive is a little more difficult due to our definition of less than
prove natural_less_than_transitive: *A*B*C(A in NATURALS & B in NATURALS & C in NATURALS & natural_less_than(A, B) & natural_less_than(B, C) -> natural_less_than(A, C)){
	empty_in_naturals, closure_naturals = expand(NATURALS_inductive);
	//We induct on A
	R_def = axiom_specify[<Q: *B*C(Q in NATURALS & B in NATURALS & C in NATURALS & natural_less_than(Q, B) & natural_less_than(B, C) -> natural_less_than(Q, C))>](NATURALS)|R|;
	prove ZERO_in_R: *B*C(ZERO in NATURALS & B in NATURALS & C in NATURALS & natural_less_than(ZERO, B) & natural_less_than(B, C) -> natural_less_than(ZERO, C)){
		given |B, C|;
		implies ZERO_in_NATURALS, B_in_NATURALS, C_in_NATURALS, ZERO_less_than_B, B_less_than_C;
		B_in_C = expand(B_less_than_C);
		prove not_empty_C: ^B(B in C){
			choose B;
			return B_in_C;
		}
		prove not_zero_C: ~equal_sets(ZERO, C){
			not equal_ZERO_C;
			B_in_ZERO = expand(equal_ZERO_C)(B)(B_in_C);
			B_in_EMPTY_SET = equality_consistency[<Q: B in Q>](EMPTY_SET, ZERO)(zero_definition)(B_in_ZERO);
			return empty_set_condition(B)(B_in_EMPTY_SET);
		}
		return branch(natural_zero_minimal(C)(C_in_NATURALS), zero_C, result){
			return axiom_absurdity[goal](not_zero_C(zero_C));
		} or {
			return result;
		};
	}
	ZERO_in_R = R_def(ZERO)(zero_is_natural, ZERO_in_R);
	
	prove closure_R: *N*N1(N in R & is_successor(N, N1) -> N1 in R){
		given |N, N1|;
		implies N_in_R, successor_N1;
		N_in_NATURALS, N_cond = R_def(N)(N_in_R);
		N1_in_NATURALS = closure_naturals(N, N1)(N_in_NATURALS, successor_N1);
		N_in_N1 = expand(successor_N1)(N)(or(<:N in N>, equal_sets_reflexive(N)));
		N_less_than_N1 = #natural_less_than(N, N1)(N_in_N1);
		prove N1_cond: *B*C(N1 in NATURALS & B in NATURALS & C in NATURALS & natural_less_than(N1, B) & natural_less_than(B, C) -> natural_less_than(N1, C)){
			given |B, C|;
			implies N1_in_NATURALS, B_in_NATURALS, C_in_NATURALS, N1_less_than_B, B_less_than_C;
			N_less_than_B = N_cond(N1, B)(N_in_NATURALS, N1_in_NATURALS, B_in_NATURALS, N_less_than_N1, N1_less_than_B);
			N_less_than_C = N_cond(B, C)(N_in_NATURALS, B_in_NATURALS, C_in_NATURALS, N_less_than_B, B_less_than_C);
			prove N1_not_equal_C: ~equal_sets(N1, C){
				not N1_equal_C;
				N1_in_B = expand(N1_less_than_B);
				B_in_C = expand(B_less_than_C);
				B_in_N1 = equality_consistency[<Q: B in Q>](N1, C)(N1_equal_C)(B_in_C);
				return branch(no_pair_recursive_membership(N1, B), not_N1_in_B, not_B_in_N1){
					return not_N1_in_B(N1_in_B);
				} or {
					return not_B_in_N1(B_in_N1);
				};
			}
			equal_or_less_than = natural_less_than_successor_weaken(N, N1, C)(N_in_NATURALS, successor_N1, C_in_NATURALS)(N_less_than_C);
			return branch(equal_or_less_than, equal, less_than){
				absurdity = N1_not_equal_C(equal);
				return axiom_absurdity[goal](absurdity);
			} or {
				return less_than;
			};
		}
		return R_def(N1)(N1_in_NATURALS, N1_cond);
	}

	NATURALS_subset_R = NATURALS_induction(R)(ZERO_in_R, closure_R);
	given |A, B, C|;
	implies A_in_NATURALS, rest_of_premises;
	A_in_R = expand(NATURALS_subset_R)(A)(A_in_NATURALS);
	A_in_NATURALS, result = R_def(A)(A_in_R);
	return result(B, C)(A_in_NATURALS, rest_of_premises);
}

//Define when a function F is recursively defined on the naturals such that G: T -> T, A in T, F: NATURALS -> T, F(0) = A, and F(N + 1) = G(F(N))
define is_recursively_defined_naturals(T, A, G, F): is_function(F) & is_domain(F, NATURALS) & is_codomain(F, T) & are_related(ZERO, A, F) & *N*N1*U*V(N in NATURALS & is_successor(N, N1) & are_related(N, U, F) & are_related(N1, V, F) -> are_related(U, V, G));

//We want to prove that functions can be recursively constructed
//I think I will replace the current construction of addition with a new proof
//Since this proof is more general.
//This result will also be used to define multiplication! It could be used, for instance, to define the fibonacci numbers.
//It's pretty important.
prove naturals_recursion_theorem: *T*A*G(A in T & is_function(G) & is_domain(G, T) & is_codomain(G, T) -> ^F(is_recursively_defined_naturals(T, A, G, F))){
	empty_in_naturals, closure_naturals = expand(NATURALS_inductive);

	given |T, A, G|;
	implies A_in_T, function_G, G_domain_T, G_codomain_T;
	//Define a recursive part to be a subset of what will be F
	//An element of P is either (0, A) or a successor of something else in P
	define is_recursive_part(P): *T(T in P -> ^X^Y(is_tuple(X, Y, T) & ((equal_sets(ZERO, X) & equal_sets(A, Y)) | ^PX^PY(is_successor(PX, X) & are_related(PY, Y, G) & are_related(PX, PY, P)))));

	//The plan is to take the union of all subsets of NxT which are recursive parts!
	//To do so, we need the set NxT which we call NT
	cross_product_NT = cross_product(NATURALS, T)|NT|;
	//We now need the power set of NT, which we call PNT
	power_set_PNT = power_set(NT)|PNT|;

	//We call the set of all subsets of PNT which are recursive parts U
	U_def = axiom_specify[<Q: is_recursive_part(Q)>](PNT)|U|;

	//And we finally define F
	F_def = expand(union(U)|F|);
	choose F;

	prove ZERO_related_A: are_related(ZERO, A, F){
		tuple_J = tuple(ZERO, A)|J|;
		P_def = expand(singleton(J)|P|);
		prove P_recursive_part: *K(K in P -> ^X^Y(is_tuple(X, Y, K) & ((equal_sets(ZERO, X) & equal_sets(A, Y)) | ^PX^PY(is_successor(PX, X) & are_related(PY, Y, G) & are_related(PX, PY, P))))){
			given |K|;
			implies K_in_P;
			K_equal_J = P_def(K)(K_in_P);
			choose ZERO, A;
			tuple_K = equality_consistency[<Q: is_tuple(ZERO, A, Q)>](K, J)(K_equal_J)(tuple_J);
			return tuple_K, or(and(equal_sets_reflexive(ZERO), equal_sets_reflexive(A)), <:^PX^PY(is_successor(PX, ZERO) & are_related(PY, A, G) & are_related(PX, PY, P))>);
		}
		P_recursive_part = #is_recursive_part(P)(P_recursive_part);
		prove J_in_NT: ^ZERO^A(ZERO in NATURALS & A in T & is_tuple(ZERO, A, J)){
			choose ZERO, A;
			return zero_is_natural, A_in_T, tuple_J;
		}
		J_in_NT = expand(cross_product_NT)(J)(J_in_NT);
		prove P_subset_NT: *K(K in P -> K in NT){
			given |K|;
			implies K_in_P;
			K_equal_J = P_def(K)(K_in_P);
			return equality_consistency[<Q: Q in NT>](K, J)(K_equal_J)(J_in_NT);
		}
		P_subset_NT = #is_subset(P, NT)(P_subset_NT);
		P_in_PNT = expand(power_set_PNT)(P)(P_subset_NT);
		P_in_U = U_def(P)(P_in_PNT, P_recursive_part);
		prove J_in_F: ^P(P in U & J in P){
			choose P;
			return P_in_U, P_def(J)(equal_sets_reflexive(J));
		}
		J_in_F = F_def(J)(J_in_F);
		prove ZERO_related_A: ^J(J in F & is_tuple(ZERO, A, J)){
			choose J;
			return J_in_F, tuple_J;
		}
		return #are_related(ZERO, A, F)(ZERO_related_A);
	}

	//We need to show that for every natural number N, there exists Y in T such that (N, Y) is in F.
	//It's easy to see that {(0, A)} is a recursive part.
	//For any recursive part P containing (N, Y), we can construct P U {(N + 1, G(Y))}, which is a recursive part covering N + 1
	//So that's the plan
	prove covers_NATURALS: *N(N in NATURALS -> ^Y(are_related(N, Y, F))){
		//We induct on N
		R_def = axiom_specify[<N: ^Y(are_related(N, Y, F))>](NATURALS)|R|;

		prove ZERO_in_R: ^A(are_related(ZERO, A, F)){
			choose A;

			return ZERO_related_A;
		}
		ZERO_in_R = R_def(ZERO)(zero_is_natural, ZERO_in_R);

		prove closure_R: *N*N1(N in R & is_successor(N, N1) -> N1 in R){
			given |N, N1|;
			implies N_in_R, successor_N1;
			N_in_NATURALS, N_cond = R_def(N)(N_in_R);
			N1_in_NATURALS = closure_naturals(N, N1)(N_in_NATURALS, successor_N1);
			PJ_in_F, tuple_PJ = expand(N_cond|PY|)|PJ|;
			PP_in_U, PJ_in_PP = F_def(PJ)(PJ_in_F)|PP|;
			PP_in_PNT, PP_recursive_part = U_def(PP)(PP_in_U);
			PP_subset_NT = expand(power_set_PNT)(PP)(PP_in_PNT);
			PJ_in_NT = expand(PP_subset_NT)(PJ)(PJ_in_PP);
			OTHER_N_in_NATURALS, OTHER_PY_in_T, other_tuple_PJ = expand(cross_product_NT)(PJ)(PJ_in_NT)|OTHER_N, OTHER_PY|;
			equal_N, equal_PY = tuple_equal_condition(N, PY, OTHER_N, OTHER_PY, PJ, PJ)(tuple_PJ, other_tuple_PJ, equal_sets_reflexive(PJ));
			PY_in_T = equality_consistency[<Q: Q in T>](PY, OTHER_PY)(equal_PY)(OTHER_PY_in_T);
			PY_related_Y = expand(G_domain_T)(PY)(PY_in_T)|Y|;
			Y_in_T = expand(G_codomain_T)(PY, Y)(PY_related_Y);
			tuple_J = tuple(N1, Y)|J|;
			prove J_in_NT: ^N1^Y(N1 in NATURALS & Y in T & is_tuple(N1, Y, J)){
				choose N1, Y;
				return N1_in_NATURALS, Y_in_T, tuple_J;
			}
			J_in_NT = expand(cross_product_NT)(J)(J_in_NT);
			K_def = expand(singleton(J)|K|);
			PAIR_def = expand(pair(PP, K)|PAIR|);
			P_def = expand(union(PAIR)|P|);
			prove P_def: *M(M in P <-> M in PP | equal_sets(M, J)){
				given |M|;
				prove lemma0: M in P -> M in PP | equal_sets(M, J){
					implies M_in_P;
					L_in_PAIR, M_in_L = P_def(M)(M_in_P)|L|;
					return branch(PAIR_def(L)(L_in_PAIR), L_equal_PP, L_equal_K){
						return or(equality_consistency[<Q: M in Q>](L, PP)(L_equal_PP)(M_in_L), <:equal_sets(M, J)>);
					} or {
						M_in_K = equality_consistency[<Q: M in Q>](L, K)(L_equal_K)(M_in_L);
						return or(<:M in PP>, K_def(M)(M_in_K));
					};
				}
				prove lemma1: M in PP | equal_sets(M, J) -> M in P{
					implies either_premise;
					return branch(either_premise, M_in_PP, M_equal_J){
						prove M_in_P: ^L(L in PAIR & M in L){
							choose PP;
							return PAIR_def(PP)(or(equal_sets_reflexive(PP), <:equal_sets(PP, K)>)), M_in_PP;
						}
						return P_def(M)(M_in_P);
					} or {
						prove M_in_P: ^L(L in PAIR & M in L){
							choose K;
							return PAIR_def(K)(or(<:equal_sets(K, PP)>, equal_sets_reflexive(K))), K_def(M)(M_equal_J);
						}
						return P_def(M)(M_in_P);
					};
				}
				return iff(lemma0, lemma1);
			}
			prove P_subset_NT: *X(X in P -> X in NT){
				given |X|;
				implies X_in_P;
				return branch(P_def(X)(X_in_P), X_in_PP, X_equal_J){
					return expand(PP_subset_NT)(X)(X_in_PP);
				} or {
					return equality_consistency[<Q: Q in NT>](X, J)(X_equal_J)(J_in_NT);
				};
			}
			P_subset_NT = #is_subset(P, NT)(P_subset_NT);
			P_in_PNT = expand(power_set_PNT)(P)(P_subset_NT);
			prove P_recursive_part: *K(K in P -> ^X^Y(is_tuple(X, Y, K) & ((equal_sets(ZERO, X) & equal_sets(A, Y)) | ^PX^PY(is_successor(PX, X) & are_related(PY, Y, G) & are_related(PX, PY, P))))){
				given |K|;
				implies K_in_P;
				return branch(P_def(K)(K_in_P), K_in_PP, K_equal_J){
					tuple_K, either_K = expand(PP_recursive_part)(K)(K_in_PP)|KX, KY|;
					prove rest_goal: ^X^Y(is_tuple(X, Y, K) & ((equal_sets(ZERO, X) & equal_sets(A, Y)) | ^PX^PY(is_successor(PX, X) & are_related(PY, Y, G) & are_related(PX, PY, P)))){
						choose KX, KY;
						return branch(either_K, K_initial, K_predecessors){
							return tuple_K, or(K_initial, <:^PX^PY(is_successor(PX, KX) & are_related(PY, KY, G) & are_related(PX, PY, P))>);
						} or {
							predecessor_PKX, predecessor_PKY, related_PP = K_predecessors|PKX, PKY|;
							L_in_PP, tuple_L = expand(related_PP)|L|;
							L_in_P = P_def(L)(or(L_in_PP, <:equal_sets(L, J)>));
							prove related_P: ^L(L in P & is_tuple(PKX, PKY, L)){
								choose L;
								return L_in_P, tuple_L;
							}
							related_P = #are_related(PKX, PKY, P)(related_P);
							prove K_predecessors_P: ^PKX^PKY(is_successor(PKX, KX) & are_related(PKY, KY, G) & are_related(PKX, PKY, P)){
								choose PKX, PKY;
								return predecessor_PKX, predecessor_PKY, related_P;
							}
							return tuple_K, or(<:equal_sets(ZERO, KX) & equal_sets(A, KY)>, K_predecessors_P);
						};
					}
					return rest_goal;
				} or {
					prove K_predecessors_P: ^N^PY(is_successor(N, N1) & are_related(PY, Y, G) & are_related(N, PY, P)){
						choose N, PY;
						PJ_in_P = P_def(PJ)(or(PJ_in_PP, <:equal_sets(PJ, J)>));
						prove related_P: ^PJ(PJ in P & is_tuple(N, PY, PJ)){
							choose PJ;
							return PJ_in_P, tuple_PJ;
						}
						related_P = #are_related(N, PY, P)(related_P);
						return successor_N1, PY_related_Y, related_P;
					}
					prove rest_goal: ^X^Y(is_tuple(X, Y, K) & ((equal_sets(ZERO, X) & equal_sets(A, Y)) | ^PX^PY(is_successor(PX, X) & are_related(PY, Y, G) & are_related(PX, PY, P)))){
						choose N1, Y;
						tuple_K = equality_consistency[<Q: is_tuple(N1, Y, Q)>](K, J)(K_equal_J)(tuple_J);
						return tuple_K, or(<:equal_sets(ZERO, N1) & equal_sets(A, Y)>, K_predecessors_P);
					}
					return rest_goal;
				};
			}
			P_recursive_part = #is_recursive_part(P)(P_recursive_part);
			P_in_U = U_def(P)(P_in_PNT, P_recursive_part);
			J_in_P = P_def(J)(or(<:J in PP>, equal_sets_reflexive(J)));
			prove J_in_F: ^P(P in U & J in P){
				choose P;
				return P_in_U, J_in_P;
			}
			J_in_F = F_def(J)(J_in_F);
			prove N1_related_Y: ^J(J in F & is_tuple(N1, Y, J)){
				choose J;
				return J_in_F, tuple_J;
			}
			N1_related_Y = #are_related(N1, Y, F)(N1_related_Y);
			prove R_cond: ^Y(are_related(N1, Y, F)){
				choose Y;
				return N1_related_Y;
			}
			return R_def(N1)(N1_in_NATURALS, R_cond);
		}

		NATURALS_subset_R = NATURALS_induction(R)(ZERO_in_R, closure_R);
		given |N|;
		implies N_in_NATURALS;
		N_in_R = expand(NATURALS_subset_R)(N)(N_in_NATURALS);
		N_in_NATURALS, result = R_def(N)(N_in_R);

		return result;
	}

	domain_NATURALS = #is_domain(F, NATURALS)(covers_NATURALS);
	
	prove F_recursive_part: *J(J in F -> ^X^Y(is_tuple(X, Y, J) & ((equal_sets(ZERO, X) & equal_sets(A, Y)) | ^PX^PY(is_successor(PX, X) & are_related(PY, Y, G) & are_related(PX, PY, F))))){
		given |J|;
		implies J_in_F;
		P_in_U, J_in_P = F_def(J)(J_in_F)|P|;
		P_in_PNT, P_recursive_part = U_def(P)(P_in_U);
		tuple_J, either_P = expand(P_recursive_part)(J)(J_in_P)|X, Y|;
		choose X, Y;
		return tuple_J, branch(either_P, J_initial, J_predecessor_P){
			return or(J_initial, <:^PX^PY(is_successor(PX, X) & are_related(PY, Y, G) & are_related(PX, PY, F))>);
		} or {
			predecessor_PX, predecessor_PY, related_P = J_predecessor_P|PX, PY|;
			PJ_in_P, tuple_PJ = expand(related_P)|PJ|;
			prove PJ_in_F: ^P(P in U & PJ in P){
				choose P;
				return P_in_U, PJ_in_P;
			}
			PJ_in_F = F_def(PJ)(PJ_in_F);
			prove related_F: ^PJ(PJ in F & is_tuple(PX, PY, PJ)){
				choose PJ;
				return PJ_in_F, tuple_PJ;
			}
			related_F = #are_related(PX, PY, F)(related_F);
			prove J_predecessor_F: ^PX^PY(is_successor(PX, X) & are_related(PY, Y, G) & are_related(PX, PY, F)){
				choose PX, PY;
				return predecessor_PX, predecessor_PY, related_F;
			}
			return or(<:equal_sets(ZERO, X) & equal_sets(A, Y)>, J_predecessor_F);
		};
	}
	F_recursive_part = #is_recursive_part(F)(F_recursive_part);

	prove recursive_part_is_function: *P(is_recursive_part(P) -> *X(X in NATURALS -> *Y0*Y1(are_related(X, Y0, P) & are_related(X, Y1, P) -> equal_sets(Y0, Y1)))){
		given |P|;
		implies recursive_part_P;

		//We induct on X
		R_def = axiom_specify[<X: *Y0*Y1(are_related(X, Y0, P) & are_related(X, Y1, P) -> equal_sets(Y0, Y1))>](NATURALS)|R|;

		prove ZERO_in_R: *Y0*Y1(are_related(ZERO, Y0, P) & are_related(ZERO, Y1, P) -> equal_sets(Y0, Y1)){
			given |Y0, Y1|;
			implies ZERO_related_Y0, ZERO_related_Y1;
			J0_in_P, tuple_J0 = expand(ZERO_related_Y0)|J0|;
			J1_in_P, tuple_J1 = expand(ZERO_related_Y1)|J1|;

			other_tuple_J0, either_J0 = expand(recursive_part_P)(J0)(J0_in_P)|OTHER_ZERO, OTHER_Y0|;
			equal_ZERO, equal_Y0 = tuple_equal_condition(ZERO, Y0, OTHER_ZERO, OTHER_Y0, J0, J0)(tuple_J0, other_tuple_J0, equal_sets_reflexive(J0));
			either_J0 = equality_consistency[<Q: (equal_sets(ZERO, Q) & equal_sets(A, OTHER_Y0)) | ^PX^PY(is_successor(PX, Q) & are_related(PY, OTHER_Y0, G) & are_related(PX, PY, P))>](ZERO, OTHER_ZERO)(equal_ZERO)(either_J0);
			either_J0 = equality_consistency[<Q: (equal_sets(ZERO, ZERO) & equal_sets(A, Q)) | ^PX^PY(is_successor(PX, ZERO) & are_related(PY, Q, G) & are_related(PX, PY, P))>](Y0, OTHER_Y0)(equal_Y0)(either_J0);
			A_equal_Y0 = branch(either_J0, equal_initial, predecessor_exists){
				ZERO_equal_ZERO, A_equal_Y0 = equal_initial;
				return A_equal_Y0;
			} or {
				predecessor_PX, PY_related_Y, PX_related_PY = predecessor_exists|PX, PY|;
				PX_in_ZERO = expand(predecessor_PX)(PX)(or(<:PX in PX>, equal_sets_reflexive(PX)));
				PX_in_EMPTY_SET = equality_consistency[<Q: PX in Q>](EMPTY_SET, ZERO)(zero_definition)(PX_in_ZERO);
				absurdity = empty_set_condition(PX)(PX_in_EMPTY_SET);
				return axiom_absurdity[<:equal_sets(A, Y0)>](absurdity);
			};

			other_tuple_J1, either_J1 = expand(recursive_part_P)(J1)(J1_in_P)|OTHER_ZERO_2, OTHER_Y1|;
			equal_ZERO, equal_Y1 = tuple_equal_condition(ZERO, Y1, OTHER_ZERO_2, OTHER_Y1, J1, J1)(tuple_J1, other_tuple_J1, equal_sets_reflexive(J1));
			either_J1 = equality_consistency[<Q: (equal_sets(ZERO, Q) & equal_sets(A, OTHER_Y1)) | ^PX^PY(is_successor(PX, Q) & are_related(PY, OTHER_Y1, G) & are_related(PX, PY, P))>](ZERO, OTHER_ZERO_2)(equal_ZERO)(either_J1);
			either_J1 = equality_consistency[<Q: (equal_sets(ZERO, ZERO) & equal_sets(A, Q)) | ^PX^PY(is_successor(PX, ZERO) & are_related(PY, Q, G) & are_related(PX, PY, P))>](Y1, OTHER_Y1)(equal_Y1)(either_J1);
			A_equal_Y1 = branch(either_J1, equal_initial, predecessor_exists){
				ZERO_equal_ZERO, A_equal_Y1 = equal_initial;
				return A_equal_Y1;
			} or {
				predecessor_PX, PY_related_Y, PX_related_PY = predecessor_exists|PX, PY|;
				PX_in_ZERO = expand(predecessor_PX)(PX)(or(<:PX in PX>, equal_sets_reflexive(PX)));
				PX_in_EMPTY_SET = equality_consistency[<Q: PX in Q>](EMPTY_SET, ZERO)(zero_definition)(PX_in_ZERO);
				absurdity = empty_set_condition(PX)(PX_in_EMPTY_SET);
				return axiom_absurdity[<:equal_sets(A, Y1)>](absurdity);
			};

			return equal_sets_transitive(Y0, A, Y1)(equal_sets_symmetric(A, Y0)(A_equal_Y0), A_equal_Y1);
		}
		ZERO_in_R = R_def(ZERO)(zero_is_natural, ZERO_in_R);

		prove closure_R: *N*N1(N in R & is_successor(N, N1) -> N1 in R){
			given |N, N1|;
			implies N_in_R, successor_N1;
			N_in_NATURALS, N_cond = R_def(N)(N_in_R);
			N1_in_NATURALS = closure_naturals(N, N1)(N_in_NATURALS, successor_N1);
			N_in_N1 = expand(successor_N1)(N)(or(<:N in N>, equal_sets_reflexive(N)));
			prove N1_cond: *Y0*Y1(are_related(N1, Y0, P) & are_related(N1, Y1, P) -> equal_sets(Y0, Y1)){
				given |Y0, Y1|;
				implies N1_related_Y0, N1_related_Y1;
				J0_in_P, tuple_J0 = expand(N1_related_Y0)|J0|;
				J1_in_P, tuple_J1 = expand(N1_related_Y1)|J1|;

				other_tuple_J0, either_J0 = expand(recursive_part_P)(J0)(J0_in_P)|OTHER_N1, OTHER_Y0|;
				equal_N1, equal_Y0 = tuple_equal_condition(N1, Y0, OTHER_N1, OTHER_Y0, J0, J0)(tuple_J0, other_tuple_J0, equal_sets_reflexive(J0));
				either_J0 = equality_consistency[<Q: (equal_sets(ZERO, Q) & equal_sets(A, OTHER_Y0)) | ^PX^PY(is_successor(PX, Q) & are_related(PY, OTHER_Y0, G) & are_related(PX, PY, P))>](N1, OTHER_N1)(equal_N1)(either_J0);
				either_J0 = equality_consistency[<Q: (equal_sets(ZERO, N1) & equal_sets(A, Q)) | ^PX^PY(is_successor(PX, N1) & are_related(PY, Q, G) & are_related(PX, PY, P))>](Y0, OTHER_Y0)(equal_Y0)(either_J0);
				predecessor_J0 = branch(either_J0, J0_initial, predecessor_J0){
					ZERO_equal_N1, A_equal_Y0 = J0_initial;
					N_in_ZERO = equality_consistency[<Q: N in Q>](ZERO, N1)(ZERO_equal_N1)(N_in_N1);
					N_in_EMPTY_SET = equality_consistency[<Q: N in Q>](EMPTY_SET, ZERO)(zero_definition)(N_in_ZERO);
					absurdity = empty_set_condition(N)(N_in_EMPTY_SET);
					return axiom_absurdity[right(either_J0)](absurdity);
				} or {
					return predecessor_J0;
				};

				other_tuple_J1, either_J1 = expand(recursive_part_P)(J1)(J1_in_P)|OTHER_N1_2, OTHER_Y1|;
				equal_N1, equal_Y1 = tuple_equal_condition(N1, Y1, OTHER_N1_2, OTHER_Y1, J1, J1)(tuple_J1, other_tuple_J1, equal_sets_reflexive(J1));
				either_J1 = equality_consistency[<Q: (equal_sets(ZERO, Q) & equal_sets(A, OTHER_Y1)) | ^PX^PY(is_successor(PX, Q) & are_related(PY, OTHER_Y1, G) & are_related(PX, PY, P))>](N1, OTHER_N1_2)(equal_N1)(either_J1);
				either_J1 = equality_consistency[<Q: (equal_sets(ZERO, N1) & equal_sets(A, Q)) | ^PX^PY(is_successor(PX, N1) & are_related(PY, Q, G) & are_related(PX, PY, P))>](Y1, OTHER_Y1)(equal_Y1)(either_J1);
				predecessor_J1 = branch(either_J1, J1_initial, predecessor_J1){
					ZERO_equal_N1, A_equal_Y1 = J1_initial;
					N_in_ZERO = equality_consistency[<Q: N in Q>](ZERO, N1)(ZERO_equal_N1)(N_in_N1);
					N_in_EMPTY_SET = equality_consistency[<Q: N in Q>](EMPTY_SET, ZERO)(zero_definition)(N_in_ZERO);
					absurdity = empty_set_condition(N)(N_in_EMPTY_SET);
					return axiom_absurdity[right(either_J1)](absurdity);
				} or {
					return predecessor_J1;
				};

				predecessor_PX0, predecessor_PY0, PX0_related_PY0 = predecessor_J0|PX0, PY0|;
				predecessor_PX1, predecessor_PY1, PX1_related_PY1 = predecessor_J1|PX1, PY1|;
				PX0_equal_N = predecessor_unique(PX0, N, N1)(predecessor_PX0, successor_N1);
				PX1_equal_N = predecessor_unique(PX1, N, N1)(predecessor_PX1, successor_N1);
				N_related_PY0 = equality_consistency[<Q: are_related(Q, PY0, P)>](PX0, N)(PX0_equal_N)(PX0_related_PY0);
				N_related_PY1 = equality_consistency[<Q: are_related(Q, PY1, P)>](PX1, N)(PX1_equal_N)(PX1_related_PY1);
				PY0_equal_PY1 = N_cond(PY0, PY1)(N_related_PY0, N_related_PY1);
				other_predecessor_PY1 = equality_consistency[<Q: are_related(Q, Y1, G)>](PY0, PY1)(PY0_equal_PY1)(predecessor_PY1);
				return expand(function_G)(PY0, Y0, Y1)(predecessor_PY0, other_predecessor_PY1);
			}
			return R_def(N1)(N1_in_NATURALS, N1_cond);
		}

		NATURALS_subset_R = NATURALS_induction(R)(ZERO_in_R, closure_R);
		given |X|;
		implies X_in_NATURALS;
		X_in_R = expand(NATURALS_subset_R)(X)(X_in_NATURALS);
		X_in_NATURALS, result = R_def(X)(X_in_R);
		return result;
	}

	prove F_is_function: *X*Y0*Y1(are_related(X, Y0, F) & are_related(X, Y1, F) -> equal_sets(Y0, Y1)){
		given |X, Y0, Y1|;
		implies X_related_Y0, X_related_Y1;
		J_in_F, tuple_J = expand(X_related_Y0)|J|;
		P_in_U, J_in_P = F_def(J)(J_in_F)|P|;
		P_in_PNT, P_recursive = U_def(P)(P_in_U);
		P_subset_NT = expand(power_set_PNT)(P)(P_in_PNT);
		J_in_NT = expand(P_subset_NT)(J)(J_in_P);
		OTHER_X_in_NATURALS, OTHER_Y0_in_T, other_tuple_J = expand(cross_product_NT)(J)(J_in_NT)|OTHER_X, OTHER_Y0|;
		equal_X, equal_Y0 = tuple_equal_condition(X, Y0, OTHER_X, OTHER_Y0, J, J)(tuple_J, other_tuple_J, equal_sets_reflexive(J));
		X_in_NATURALS = equality_consistency[<Q: Q in NATURALS>](X, OTHER_X)(equal_X)(OTHER_X_in_NATURALS);
		return recursive_part_is_function(F)(F_recursive_part)(X)(X_in_NATURALS)(Y0, Y1)(X_related_Y0, X_related_Y1);
	}
	F_is_function = #is_function(F)(F_is_function);

	prove F_recursive: *N*N1*U*V(N in NATURALS & is_successor(N, N1) & are_related(N, U, F) & are_related(N1, V, F) -> are_related(U, V, G)){
		given |N, N1, U, V|;
		implies N_in_NATURALS, successor_N1, N_related_U, N1_related_V;
		N_in_N1 = expand(successor_N1)(N)(or(<:N in N>, equal_sets_reflexive(N)));
		J1_in_F, tuple_J1 = expand(N1_related_V)|J1|;
		other_tuple_J1, either_J1 = expand(F_recursive_part)(J1)(J1_in_F)|OTHER_N1, OTHER_V|;
		equal_N1, equal_V = tuple_equal_condition(N1, V, OTHER_N1, OTHER_V, J1, J1)(tuple_J1, other_tuple_J1, equal_sets_reflexive(J1));
		either_J1 = equality_consistency[<Q: (equal_sets(ZERO, Q) & equal_sets(A, OTHER_V)) | ^PN^PV(is_successor(PN, Q) & are_related(PV, OTHER_V, G) & are_related(PN, PV, F))>](N1, OTHER_N1)(equal_N1)(either_J1);
		either_J1 = equality_consistency[<Q: (equal_sets(ZERO, N1) & equal_sets(A, Q)) | ^PN^PV(is_successor(PN, N1) & are_related(PV, Q, G) & are_related(PN, PV, F))>](V, OTHER_V)(equal_V)(either_J1);
		predecessor_J1 = branch(either_J1, initial_J1, predecessor_J1){
			ZERO_equal_N1, A_equal_V = initial_J1;
			N_in_ZERO = equality_consistency[<Q: N in Q>](ZERO, N1)(ZERO_equal_N1)(N_in_N1);
			N_in_EMPTY_SET = equality_consistency[<Q: N in Q>](EMPTY_SET, ZERO)(zero_definition)(N_in_ZERO);
			absurdity = empty_set_condition(N)(N_in_EMPTY_SET);
			return axiom_absurdity[right(either_J1)](absurdity);
		} or {
			return predecessor_J1;
		};

		predecessor_PN1, predecessor_PV, PN1_related_PV = predecessor_J1|PN1, PV|;
		PN1_equal_N = predecessor_unique(PN1, N, N1)(predecessor_PN1, successor_N1);
		N_related_PV = equality_consistency[<Q: are_related(Q, PV, F)>](PN1, N)(PN1_equal_N)(PN1_related_PV);
		U_equal_PV = expand(F_is_function)(N, U, PV)(N_related_U, N_related_PV);
		return equality_consistency[<Q: are_related(Q, V, G)>](U, PV)(U_equal_PV)(predecessor_PV);
	}

	prove codomain_T: *X*Y(are_related(X, Y, F) -> Y in T){
		given |X, Y|;
		implies X_related_Y;
		J_in_F, tuple_J = expand(X_related_Y)|J|;
		P_in_U, J_in_P = F_def(J)(J_in_F)|P|;
		P_in_PNT, P_recursive = U_def(P)(P_in_U);
		P_subset_NT = expand(power_set_PNT)(P)(P_in_PNT);
		J_in_NT = expand(P_subset_NT)(J)(J_in_P);
		OTHER_X_in_NATURALS, OTHER_Y_in_T, other_tuple_J = expand(cross_product_NT)(J)(J_in_NT)|OTHER_X, OTHER_Y|;
		equal_X, equal_Y = tuple_equal_condition(X, Y, OTHER_X, OTHER_Y, J, J)(tuple_J, other_tuple_J, equal_sets_reflexive(J));
		return equality_consistency[<Q: Q in T>](Y, OTHER_Y)(equal_Y)(OTHER_Y_in_T);
	}
	codomain_T = #is_codomain(F, T)(codomain_T);

	return #is_recursively_defined_naturals(T, A, G, F)(F_is_function, domain_NATURALS, codomain_T, ZERO_related_A, F_recursive);
}

//We want to prove that any recursive function is unique with respect to the function used to define it
prove naturals_recursively_defined_unique: *T*A*G(A in T & is_function(G) & is_domain(G, T) & is_codomain(G, T) -> *F0*F1(is_recursively_defined_naturals(T, A, G, F0) & is_recursively_defined_naturals(T, A, G, F1) -> equal_relations(NATURALS, T, F0, F1))){
	empty_in_naturals, closure_naturals = expand(NATURALS_inductive);

	given |T, A, G|;
	implies A_in_T, function_G, G_domain_T, G_codomain_T;
	given |F0, F1|;
	implies F0_recursively_defined, F1_recursively_defined;
	function_F0, F0_domain_NATURALS, F0_codomain_T, ZERO_related_A_F0, F0_recursion = expand(F0_recursively_defined);
	function_F1, F1_domain_NATURALS, F1_codomain_T, ZERO_related_A_F1, F1_recursion = expand(F1_recursively_defined);

	prove F0_equal_F1: *X*Y(X in NATURALS & Y in T -> (are_related(X, Y, F0) <-> are_related(X, Y, F1))){
		//We must induct on X
		R_def = axiom_specify[<Q: *Y(Y in T -> (are_related(Q, Y, F0) <-> are_related(Q, Y, F1)))>](NATURALS)|R|;

		prove ZERO_in_R: *Y(Y in T -> (are_related(ZERO, Y, F0) <-> are_related(ZERO, Y, F1))){
			given |Y|;
			implies Y_in_T;
			prove lemma0: are_related(ZERO, Y, F0) -> are_related(ZERO, Y, F1){
				implies ZERO_related_Y_F0;
				Y_equal_A = expand(function_F0)(ZERO, Y, A)(ZERO_related_Y_F0, ZERO_related_A_F0);
				return equality_consistency[<Q: are_related(ZERO, Q, F1)>](Y, A)(Y_equal_A)(ZERO_related_A_F1);
			}
			prove lemma1: are_related(ZERO, Y, F1) -> are_related(ZERO, Y, F0){
				implies ZERO_related_Y_F1;
				Y_equal_A = expand(function_F1)(ZERO, Y, A)(ZERO_related_Y_F1, ZERO_related_A_F1);
				return equality_consistency[<Q: are_related(ZERO, Q, F0)>](Y, A)(Y_equal_A)(ZERO_related_A_F0);
			}
			return iff(lemma0, lemma1);
		}
		ZERO_in_R = R_def(ZERO)(zero_is_natural, ZERO_in_R);

		prove closure_R: *N*N1(N in R & is_successor(N, N1) -> N1 in R){
			given |N, N1|;
			implies N_in_R, successor_N1;
			N_in_NATURALS, N_cond = R_def(N)(N_in_R);
			N1_in_NATURALS = closure_naturals(N, N1)(N_in_NATURALS, successor_N1);
			prove N1_cond: *Y(Y in T -> (are_related(N1, Y, F0) <-> are_related(N1, Y, F1))){
				given |Y|;
				implies Y_in_T;
				prove lemma0: are_related(N1, Y, F0) -> are_related(N1, Y, F1){
					implies N1_related_Y_F0;
					N_related_PY_F0 = expand(F0_domain_NATURALS)(N)(N_in_NATURALS)|PY|;
					PY_in_T = expand(F0_codomain_T)(N, PY)(N_related_PY_F0);
					N_related_PY_F1 = N_cond(PY)(PY_in_T)(N_related_PY_F0);
					N1_related_OTHER_Y_F1 = expand(F1_domain_NATURALS)(N1)(N1_in_NATURALS)|OTHER_Y|;
					PY_related_Y_G = F0_recursion(N, N1, PY, Y)(N_in_NATURALS, successor_N1, N_related_PY_F0, N1_related_Y_F0);
					PY_related_OTHER_Y_G = F1_recursion(N, N1, PY, OTHER_Y)(N_in_NATURALS, successor_N1, N_related_PY_F1, N1_related_OTHER_Y_F1);
					equal_Y = expand(function_G)(PY, Y, OTHER_Y)(PY_related_Y_G, PY_related_OTHER_Y_G);
					return equality_consistency[<Q: are_related(N1, Q, F1)>](Y, OTHER_Y)(equal_Y)(N1_related_OTHER_Y_F1);
				}
				prove lemma1: are_related(N1, Y, F1) -> are_related(N1, Y, F0){
					implies N1_related_Y_F1;
					N_related_PY_F1 = expand(F1_domain_NATURALS)(N)(N_in_NATURALS)|PY|;
					PY_in_T = expand(F1_codomain_T)(N, PY)(N_related_PY_F1);
					N_related_PY_F0 = N_cond(PY)(PY_in_T)(N_related_PY_F1);
					N1_related_OTHER_Y_F0 = expand(F0_domain_NATURALS)(N1)(N1_in_NATURALS)|OTHER_Y|;
					PY_related_Y_G = F1_recursion(N, N1, PY, Y)(N_in_NATURALS, successor_N1, N_related_PY_F1, N1_related_Y_F1);
					PY_related_OTHER_Y_G = F0_recursion(N, N1, PY, OTHER_Y)(N_in_NATURALS, successor_N1, N_related_PY_F0, N1_related_OTHER_Y_F0);
					equal_Y = expand(function_G)(PY, Y, OTHER_Y)(PY_related_Y_G, PY_related_OTHER_Y_G);
					return equality_consistency[<Q: are_related(N1, Q, F0)>](Y, OTHER_Y)(equal_Y)(N1_related_OTHER_Y_F0);
				}
				return iff(lemma0, lemma1);
			}
			return R_def(N1)(N1_in_NATURALS, N1_cond);
		}
		
		NATURALS_subset_R = NATURALS_induction(R)(ZERO_in_R, closure_R);
		given |X, Y|;
		implies X_in_NATURALS, Y_in_T;
		X_in_R = expand(NATURALS_subset_R)(X)(X_in_NATURALS);
		X_in_NATURALS, result = R_def(X)(X_in_R);
		return result(Y)(Y_in_T);
	}

	return #equal_relations(NATURALS, T, F0, F1)(F0_equal_F1);
}
