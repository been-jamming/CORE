//Define when X and Y are related under R
define are_related(X, Y, R): ^T(T in R & is_tuple(X, Y, T));

//Define when a relation R is reflexive with respect to A
define is_reflexive(R, A): *X(X in A -> are_related(X, X, R));

//Define when a relation R is symmetric
define is_symmetric(R): *X*Y(are_related(X, Y, R) -> are_related(Y, X, R));

//Define when a relation R is transitive
define is_transitive(R): *X*Y*Z(are_related(X, Y, R) & are_related(Y, Z, R) -> are_related(X, Z, R));

//Define an equivalence relation with respect to A (for reflexivity)
define is_equivalence_relation(R, A): is_reflexive(R, A) & is_symmetric(R) & is_transitive(R);

//Define a function!
define is_function(F): *X*Y*Z(are_related(X, Y, F) & are_related(X, Z, F) -> equal_sets(Y, Z));

//Useful lemma for constructing relations using propositions
prove relation_existence_lemma[P(2)]: *A*B^C*X*Y((are_related(X, Y, C) -> X in A & Y in B & P(X, Y)) & (X in A & Y in B & P(X, Y) -> are_related(X, Y, C))){
	given |A, B|;
	T_cross = cross_product(A, B)|T|;
	C_specified = axiom_specify[<P: ^X^Y(X in A & Y in B & is_tuple(X, Y, P) & P(X, Y))>](T)|C|;
	choose C;
	given |X, Y|;
	prove lemma0: are_related(X, Y, C) -> X in A & Y in B & P(X, Y){
		implies related_XY;
		extract are_related#(X, Y, C)(related_XY)|TUPLE_XY|: XY_in_C, tuple_XY;
		extract C_specified(TUPLE_XY): C_specified_left, C_specified_right;
		extract C_specified_left(XY_in_C): XY_in_T, tuple_existence;
		extract tuple_existence|OTHER_X, OTHER_Y|: OTHER_X_in_A, OTHER_Y_in_B, other_tuple_XY, P_other;
		extract tuple_equal_condition(OTHER_X, OTHER_Y, X, Y, TUPLE_XY, TUPLE_XY)(and(other_tuple_XY, tuple_XY, equal_sets_reflexive(TUPLE_XY))): equal_X, equal_Y;
		X_in_A = equality_consistency[<S: S in A>](OTHER_X, X)(and(equal_X, OTHER_X_in_A));
		Y_in_B = equality_consistency[<S: S in B>](OTHER_Y, Y)(and(equal_Y, OTHER_Y_in_B));
		P_other = equality_consistency[<S: P(S, OTHER_Y)>](OTHER_X, X)(and(equal_X, P_other));
		P_XY = equality_consistency[<S: P(X, S)>](OTHER_Y, Y)(and(equal_Y, P_other));
		return and(X_in_A, Y_in_B, P_XY);
	}
	prove lemma1: X in A & Y in B & P(X, Y) -> are_related(X, Y, C){
		implies premises;
		extract premises: X_in_A, Y_in_B, P_XY;
		Z_tuple = tuple(X, Y)|Z|;
		extract T_cross(Z): T_cross_left, T_cross_right;
		extract C_specified(Z): C_specified_left, C_specified_right;
		prove lemma: ^J^K(J in A & K in B & is_tuple(J, K, Z)){
			choose X, Y;
			return and(X_in_A, Y_in_B, Z_tuple);
		}
		Z_in_T = T_cross_right(lemma);
		prove lemma: ^J^K(J in A & K in B & is_tuple(J, K, Z) & P(J, K)){
			choose X, Y;
			return and(X_in_A, Y_in_B, Z_tuple, P_XY);
		}
		Z_in_C = C_specified_right(and(Z_in_T, lemma));
		prove related_def: ^S(S in C & is_tuple(X, Y, S)){
			choose Z;
			return and(Z_in_C, Z_tuple);
		}
		return #are_related(X, Y, C)(related_def);
	}
	return and(lemma0, lemma1);
}

//Useful lemma for constructing functions using propositions
//prove function_existence_lemma[P(2)]: *A*B(*X*Y*Z(X in A & Y in B & Z in B & P(X, Y) & P(X, Z) -> equal_sets(X, Z)) -> ^F*X*Y(is_function(F) & (are_related(X, Y, F) -> X in A & Y in B & P(X, Y)) & (X in A & Y in B & P(X, Y) -> are_related(X, Y, F)))){
