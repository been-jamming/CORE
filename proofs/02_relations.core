//Define when X and Y are related under R
define are_related(X, Y, R): ^T(T in R & is_tuple(X, Y, T));

//Define when a relation R is reflexive with respect to A
define is_reflexive(R, A): *X(X in A -> are_related(X, X, R));

//Define when a relation R is symmetric
define is_symmetric(R): *X*Y(are_related(X, Y, R) -> are_related(Y, X, R));

//Define when a relation R is transitive
define is_transitive(R): *X*Y*Z(are_related(X, Y, R) & are_related(Y, Z, R) -> are_related(X, Z, R));

//Define an equivalence relation with respect to A (for reflexivity)
define is_equivalence_relation(R, A): is_reflexive(R, A) & is_symmetric(R) & is_transitive(R);

//Define a function!
define is_function(F): *X*Y*Z(are_related(X, Y, F) & are_related(X, Z, F) -> equal_sets(Y, Z));

//Define when a function is injective with respect to a domain A
define is_injective(F, A): *X*Y(X in A & Y in A & ^Z(are_related(X, Z, F) & are_related(Y, Z, F)) -> equal_sets(X, Y));

//Define when a function is surjective with respect to a codomain A
define is_surjective(F, A): *Y(Y in A -> ^X(are_related(X, Y, F)));

//Useful lemma for constructing relations using propositions
prove relation_existence_lemma[P(2)]: *A*B^C*X*Y(are_related(X, Y, C) <-> X in A & Y in B & P(X, Y)){
	given |A, B|;
	T_cross = expand(cross_product(A, B)|T|);
	C_specified = axiom_specify[<S: ^X^Y(X in A & Y in B & is_tuple(X, Y, S) & P(X, Y))>](T)|C|;
	choose C;
	given |X, Y|;
	prove lemma0: are_related(X, Y, C) -> X in A & Y in B & P(X, Y){
		implies related_XY;
		extract expand(related_XY)|TUPLE_XY|: XY_in_C, tuple_XY;
		extract C_specified(TUPLE_XY)(XY_in_C): XY_in_T, tuple_existence;
		extract tuple_existence|OTHER_X, OTHER_Y|: OTHER_X_in_A, OTHER_Y_in_B, other_tuple_XY, P_other;
		extract tuple_equal_condition(OTHER_X, OTHER_Y, X, Y, TUPLE_XY, TUPLE_XY)(and(other_tuple_XY, tuple_XY, equal_sets_reflexive(TUPLE_XY))): equal_X, equal_Y;
		X_in_A = equality_consistency[<S: S in A>](OTHER_X, X)(equal_X)(OTHER_X_in_A);
		Y_in_B = equality_consistency[<S: S in B>](OTHER_Y, Y)(equal_Y)(OTHER_Y_in_B);
		P_other = equality_consistency[<S: P(S, OTHER_Y)>](OTHER_X, X)(equal_X)(P_other);
		P_XY = equality_consistency[<S: P(X, S)>](OTHER_Y, Y)(equal_Y)(P_other);
		return and(X_in_A, Y_in_B, P_XY);
	}
	prove lemma1: X in A & Y in B & P(X, Y) -> are_related(X, Y, C){
		implies premises;
		extract premises: X_in_A, Y_in_B, P_XY;
		Z_tuple = tuple(X, Y)|Z|;
		prove lemma: ^J^K(J in A & K in B & is_tuple(J, K, Z)){
			choose X, Y;
			return and(X_in_A, Y_in_B, Z_tuple);
		}
		Z_in_T = T_cross(Z)(lemma);
		prove lemma: ^J^K(J in A & K in B & is_tuple(J, K, Z) & P(J, K)){
			choose X, Y;
			return and(X_in_A, Y_in_B, Z_tuple, P_XY);
		}
		Z_in_C = C_specified(Z)(and(Z_in_T, lemma));
		prove related_def: ^S(S in C & is_tuple(X, Y, S)){
			choose Z;
			return and(Z_in_C, Z_tuple);
		}
		return #are_related(X, Y, C)(related_def);
	}
	return iff(lemma0, lemma1);
}

//Define when C is the equivalence class with respect to an equivalence relation R on A
define is_equivalence_class(R, A, C): ^X(X in A & *Y(Y in C <-> Y in A & are_related(X, Y, R)));

//Define when C is the equivalence classes for R
define is_equivalence_classes(R, A, C): *Y(Y in C <-> is_equivalence_class(R, A, Y));

//Prove that equivalence classes exist for any equivalence relation
prove equivalence_classes: *A*R(is_equivalence_relation(R, A) -> ^C(is_equivalence_classes(R, A, C))){
	given |A, R|;
	implies equiv_relation;
	extract expand(equiv_relation): reflexive, symmetric, transitive;
	power_set_P = expand(power_set(A)|P|);
	C_def = axiom_specify[<S: is_equivalence_class(R, A, S)>](P)|C|;
	choose C;
	prove equiv_classes_def: *Y(Y in C <-> is_equivalence_class(R, A, Y)){
		given |Y|;
		prove lemma0: Y in C -> is_equivalence_class(R, A, Y){
			implies Y_in_C;
			extract C_def(Y)(Y_in_C): Y_in_P, result;
			return result;
		}
		prove lemma1: is_equivalence_class(R, A, Y) -> Y in C{
			implies equiv_class;
			extract expand(equiv_class)|Y_REP|: Y_REP_in_A, closure;
			prove subset_def: *J(J in Y -> J in A){
				given |J|;
				implies J_in_Y;
				extract closure(J)(J_in_Y): J_in_A, related_Y_REP_J;
				return J_in_A;
			}
			Y_subset_A = #is_subset(Y, A)(subset_def);
			Y_in_P = power_set_P(Y)(Y_subset_A);
			return C_def(Y)(and(Y_in_P, equiv_class));
		}
		return iff(lemma0, lemma1);
	}
	return #is_equivalence_classes(R, A, C)(equiv_classes_def);
}

//Prove that equivalence classes are disjoint
prove equivalence_classes_disjoint: *A*R*C(is_equivalence_relation(R, A) & is_equivalence_classes(R, A, C) -> *X*Y(X in C & Y in C & ^Z(Z in X & Z in Y) -> equal_sets(X, Y))){
	given |A, R, C|;
	implies premises;
	extract premises: equiv_relation, equiv_classes;
	extract expand(equiv_relation): reflexive, symmetric, transitive;
	given |X, Y|;
	implies premises;
	extract premises: X_in_C, Y_in_C, not_disjoint;
	X_equiv_class = expand(equiv_classes)(X)(X_in_C);
	Y_equiv_class = expand(equiv_classes)(Y)(Y_in_C);
	extract expand(X_equiv_class)|X_REP|: X_REP_in_A, X_closure;
	extract expand(Y_equiv_class)|Y_REP|: Y_REP_in_A, Y_closure;
	extract not_disjoint|Z|: Z_in_X, Z_in_Y;
	extract X_closure(Z)(Z_in_X): Z_in_A, related_X_REP_Z;
	extract Y_closure(Z)(Z_in_Y): Z_in_A, related_Y_REP_Z;
	related_Z_Y_REP = expand(symmetric)(Y_REP, Z)(related_Y_REP_Z);
	related_reps = expand(transitive)(X_REP, Z, Y_REP)(and(related_X_REP_Z, related_Z_Y_REP));
	related_reps_other = expand(symmetric)(X_REP, Y_REP)(related_reps);
	prove equal_def: *J(J in X <-> J in Y){
		given |J|;
		prove lemma0: J in X -> J in Y{
			implies J_in_X;
			extract X_closure(J)(J_in_X): J_in_A, related_X_REP_J;
			related_Y_REP_J = expand(transitive)(Y_REP, X_REP, J)(and(related_reps_other, related_X_REP_J));
			return Y_closure(J)(and(J_in_A, related_Y_REP_J));
		}
		prove lemma1: J in Y -> J in X{
			implies J_in_Y;
			extract Y_closure(J)(J_in_Y): J_in_A, related_Y_REP_J;
			related_X_REP_J = expand(transitive)(X_REP, Y_REP, J)(and(related_reps, related_Y_REP_J));
			return X_closure(J)(and(J_in_A, related_X_REP_J));
		}
		return iff(lemma0, lemma1);
	}
	return #equal_sets(X, Y)(equal_def);
}

//Prove that every element of A has an equivalence class
prove equivalence_classes_class: *A*R*C(is_equivalence_relation(R, A) & is_equivalence_classes(R, A, C) -> *X(X in A -> ^D(D in C & X in D))){
	given |A, R, C|;
	implies premises;
	extract premises: equiv_relation, equiv_classes;
	extract expand(equiv_relation): reflexive, symmetric, transitive;
	given |X|;
	implies X_in_A;
	D_def = axiom_specify[<S: are_related(X, S, R)>](A)|D|;
	choose D;
	X_in_D = D_def(X)(and(X_in_A, expand(reflexive)(X)(X_in_A)));
	prove equiv_class_def: ^X(X in A & *Y(Y in D <-> Y in A & are_related(X, Y, R))){
		choose X;
		prove right_def: *Y(Y in D <-> Y in A & are_related(X, Y, R)){
			given |Y|;
			prove lemma0: Y in D -> Y in A & are_related(X, Y, R){
				implies Y_in_D;
				extract D_def(Y)(Y_in_D): Y_in_A, related;
				return and(Y_in_A, related);
			}
			prove lemma1: Y in A & are_related(X, Y, R) -> Y in D{
				implies premises;
				return D_def(Y)(premises);
			}
			return iff(lemma0, lemma1);
		}
		return and(X_in_A, right_def);
	}
	equiv_class = #is_equivalence_class(R, A, D)(equiv_class_def);
	D_in_C = expand(equiv_classes)(D)(equiv_class);
	return and(D_in_C, X_in_D);
}

//Prove that equivalence classes, if they exist, are unique
prove equivalence_classes_unique: *A*R*C*D(is_equivalence_classes(R, A, C) & is_equivalence_classes(R, A, D) -> equal_sets(C, D)){
	given |A, R, C, D|;
	implies both_equiv_classes;
	extract both_equiv_classes: equiv_classes_C, equiv_classes_D;
	return definition_uniqueness_lemma[<S: is_equivalence_class(R, A, S)>](C, D)(and(expand(equiv_classes_C), expand(equiv_classes_D)));
}

