include "zfc_axioms.core";

dependent define is_relation(A);
dependent define related(X, Y, A);
dependent define function(A): is_relation(A) & *X*Y*Z(related(X, Y, A) & related(X, Z, A) -> Y = Z);
axiom relation_exists[P(2)]: *A*B^R(is_relation(R) & *X*Y(related(X, Y, R) <-> P(X, Y) & X in A & Y in B));

//Here are the peano arithmetic axioms
axiom equal_reflexive: *A(A = A);
axiom equal_symmetric: *A*B(A = B <-> B = A);
axiom equal_transitive: *A*B*C(A = B & B = C -> A = C);

object NATURALS;
object ZERO;

axiom zero_natural: ZERO in NATURALS;
axiom successor: *A^B(successor(B, A));
axiom successor_unique: *A*B*C(successor(A, C) & successor(B, C) -> A = B);
axiom successor_natural: *X*Y(X in NATURALS & successor(Y, X) -> Y in NATURALS);
axiom successor_injective: *X*Y*Z(successor(X, Y) & successor(X, Z) -> Y = Z);
axiom zero_not_successor: *X*Y(successor(X, Y) -> ~X = ZERO);
//Since we're working in ZFC, this axiom is strong enough
axiom induction[P(1)]: P(ZERO) & *X*Y(P(X) & successor(Y, X) -> P(Y)) -> *N(N in NATURALS -> P(N));

one_def = successor(ZERO)|ONE|;
one_natural = successor_natural(ZERO, ONE)(zero_natural, one_def);
two_def = successor(ONE)|TWO|;
two_natural = successor_natural(ONE, TWO)(one_natural, two_def);

