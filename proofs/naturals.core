include "zfc_axioms.core";
include "relations_axioms.core";

axiom exists[P(1)]: *X(P(X) -> ^Y(P(Y)));
axiom equal_reflexive: *A(A = A);
axiom equal_symmetric: *A*B(A = B <-> B = A);
axiom equal_transitive: *A*B*C(A = B & B = C -> A = C);

object NATURALS;
object ZERO;

axiom zero_natural: ZERO in NATURALS;
axiom successor: *A^B(successor(B, A));
axiom successor_unique: *A*B*C(successor(A, C) & successor(B, C) -> A = B);
axiom successor_natural: *X*Y(X in NATURALS & successor(Y, X) -> Y in NATURALS);
axiom successor_injective: *X*Y*Z(successor(X, Y) & successor(X, Z) -> Y = Z);
axiom zero_not_successor: *X(~successor(ZERO, X));
//Since we're working in ZFC, this axiom is strong enough
axiom induction[P(1)]: P(ZERO) & *X*Y(P(X) & successor(Y, X) -> P(Y)) -> *N(N in NATURALS -> P(N));

one_def = successor(ZERO)|ONE|;
one_natural = successor_natural(ZERO, ONE)(zero_natural, one_def);
two_def = successor(ONE)|TWO|;
two_natural = successor_natural(ONE, TWO)(one_natural, two_def);

//First I need to prove that the predecessor of a natural number exists
prove predecessor: *M(M in NATURALS & ~M = ZERO -> ^N(N in NATURALS & successor(M, N))){
	//The proposition to induct on
	define P(M): M in NATURALS & (~M = ZERO -> ^N(N in NATURALS & successor(M, N)));
	prove base_case: ~ZERO = ZERO -> ^N(N in NATURALS & successor(ZERO, N)){
		assume not_reflexive;
		return zero_natural, not_reflexive(equal_reflexive(ZERO));
	}
	base_case = #P(ZERO)(zero_natural, base_case);
	prove inductive_case: *M*L(P(M) & successor(L, M) -> P(L)){
		given |M, L|;
		assume P_M, successor_L;
		M_natural, M_cond = expand(P_M);
		L_natural = successor_natural(M, L)(M_natural, successor_L);
		prove L_cond: ~L = ZERO -> ^N(N in NATURALS & successor(L, N)){
			assume L_not_zero;
			choose M;
			return M_natural, successor_L;
		}
		return #P(L)(L_natural, L_cond);
	}
	result = induction[<M: P(M)>](base_case, inductive_case);
	given |M|;
	assume M_natural, M_not_zero;
	M_natural, M_cond = expand(result(M)(M_natural));
	return M_cond(M_not_zero);
}

//Now I will prove that the predecessor of a natural number is natural
prove predecessor_natural: *N*M(M in NATURALS & successor(M, N) -> N in NATURALS){
	given |N, M|;
	assume M_natural, successor_M;
	prove M_not_zero: ~M = ZERO{
		not M_eq_ZERO;
		successor_zero = replace[<Q: successor(Q, N)>](M, ZERO)(M_eq_ZERO)(successor_M);
		return zero_not_successor(N)(successor_zero);
	}
	N2_natural, successor_M_N2 = predecessor(M)(M_natural, M_not_zero)|N2|;
	N_eq_N2 = successor_injective(M, N, N2)(successor_M, successor_M_N2);
	return replace[<Q: Q in NATURALS>](N, N2)(N_eq_N2)(N2_natural);
}

//We'll see how this goes
//Attempt number 2
prove recursion: *F*D*S(function(F) & domain(D, F) & codomain(D, F) & S in D -> ^G(function(G) & domain(NATURALS, G) & codomain(D, G) & *X(related(ZERO, X, G) <-> X = S) & *N*M*Y(successor(M, N) & related(M, Y, G) -> ^X(related(N, X, G) & related(X, Y, F))))){
	given |F, D, S|;
	assume function_F, F_domain_D, F_codomain_D, S_in_D;
	//Define the partial versions of G as "recursive parts"
	define recursive_part(A): is_relation(A) & *X(related(ZERO, X, A) -> X = S) & *N*M*Y(successor(M, N) & related(M, Y, A) -> ^X(related(N, X, A) & related(X, Y, F)));
	//Now X and Y are related under G if they are related by some recursive part
	relation_G, G_def = relation_exists[<X, Y: ^A(recursive_part(A) & related(X, Y, A))>](NATURALS, D)|G|;
	choose G;

	//We have to construct the simplest non-trivial recursive part manually
	//It relates 0 and S
	relation_INITIAL, INITIAL_def = relation_exists[<X, Y: X = ZERO & Y = S>](NATURALS, D)|INITIAL|;
	//Prove that zero is only related to S
	prove initial_zero: *X(related(ZERO, X, INITIAL) -> X = S){
		given |X|;
		assume zero_related_X;
		return INITIAL_def(ZERO, X)(zero_related_X);
	}
	//Prove that INITIAL is recursive
	prove initial_recursive: *N*M*Y(successor(M, N) & related(M, Y, INITIAL) -> ^X(related(N, X, INITIAL) & related(X, Y, F))){
		given |N, M, Y|;
		assume successor_M, M_related_Y;
		M_eq_zero, Y_eq_S, M_in_NATURALS, Y_in_D = INITIAL_def(M, Y)(M_related_Y);
		successor_zero = replace[<Q: successor(Q, N)>](M, ZERO)(M_eq_zero)(successor_M);
		return zero_not_successor(N)(successor_zero);
	}
	recursive_part_INITIAL = #recursive_part(INITIAL)(relation_INITIAL, initial_zero, initial_recursive);
	zero_related_S_INITIAL = INITIAL_def(ZERO, S)(equal_reflexive(ZERO), equal_reflexive(S), zero_natural, S_in_D);
	initial_exists = exists[<Q: recursive_part(Q) & related(ZERO, S, Q)>](INITIAL)(recursive_part_INITIAL, zero_related_S_INITIAL);
	zero_related_S_G = G_def(ZERO, S)(initial_exists, zero_natural, S_in_D);

	//Now for each natural number, we need to prove that G relates it
	prove G_relates_naturals: *N(N in NATURALS -> ^X(related(N, X, G))){
		zero_related_exists = exists[<Q: related(ZERO, Q, G)>](S)(zero_related_S_G);

		//Now we have to prove that if N is related, N + 1 is
		prove inductive_step: *N*M(^X(related(N, X, G)) & successor(M, N) -> ^Y(related(M, Y, G))){
			given |N, M|;
			assume X_exists, successor_M;
			N_related_X = X_exists|X|;
			P_exists, N_natural, X_in_D = G_def(N, X)(N_related_X);
			M_natural = successor_natural(N, M)(N_natural, successor_M);
			recursive_P, N_related_X_P = P_exists|P|;
			relation_P, zero_P, recursion_P = expand(recursive_P);
			X_related_Y_F = expand(F_domain_D)(X)(X_in_D)|Y|;
			Y_in_D = expand(F_codomain_D)(X, Y)(X_related_Y_F);
			choose Y;
			//I will define a new recursive part which relates M to Y and uses P for everything else
			relation_Q, Q_def = relation_exists[<L, Z: related(L, Z, P) | L = M & Z = Y>](NATURALS, D)|Q|;
			N_related_X_Q = Q_def(N, X)(N_related_X_P, N_natural, X_in_D);
			M_related_Y_Q = Q_def(M, Y)(equal_reflexive(M), equal_reflexive(Y), M_natural, Y_in_D);
			//Now I must prove that zero is only related to S
			prove Q_zero: *Z(related(ZERO, Z, Q) -> Z = S){
				given |Z|;
				assume zero_related_Z;
				either, zero_natural, Z_in_D = Q_def(ZERO, Z)(zero_related_Z);
				return branch(either, zero_related_Z_P, both){
					return zero_P(Z)(zero_related_Z_P);
				} or {
					zero_eq_M, Z_eq_Y = both;
					successor_zero = replace[<Q: successor(Q, N)>](ZERO, M)(zero_eq_M)(successor_M);
					return trivial(<: false -> Z = S>)(zero_not_successor(N)(successor_zero));
				};
			}
			//And next I need that Q is recursive
			prove Q_recursive: *L*R*V(successor(R, L) & related(R, V, Q) -> ^U(related(L, U, Q) & related(U, V, F))){
				given |L, R, V|;
				assume successor_R, R_related_V_Q;
				either, R_natural, V_in_D = Q_def(R, V)(R_related_V_Q);
				return branch(either, R_related_V_P, both){
					L_related_U_P, U_related_V_F = recursion_P(L, R, V)(successor_R, R_related_V_P)|U|;
					L_natural = predecessor_natural(L, R)(R_natural, successor_R);
					exist = exists[<C: related(U, C, F)>](V)(U_related_V_F);
					U_in_D = expand(F_domain_D)(U)(exist);
					L_related_U_Q = Q_def(L, U)(L_related_U_P, L_natural, U_in_D);
					return exists[<C: related(L, C, Q) & related(C, V, F)>](U)(L_related_U_Q, U_related_V_F);
				} or {
					R_eq_M, V_eq_Y = both;
					successor_M_other = replace[<T: successor(T, L)>](R, M)(R_eq_M)(successor_R);
					N_eq_L = successor_injective(M, N, L)(successor_M, successor_M_other);
					prove exist: ^X(related(L, X, Q) & related(X, V, F)){
						choose X;
						return replace[<T: related(T, X, Q)>](N, L)(N_eq_L)(N_related_X_Q), replace[<T: related(X, T, F)>](V, Y)(V_eq_Y)(X_related_Y_F);
					}
					return exist;
				};
			}
			//Now we know that Q is a recursive part!
			Q_recursive = #recursive_part(Q)(relation_Q, Q_zero, Q_recursive);
			exist = exists[<C: recursive_part(C) & related(M, Y, C)>](Q)(Q_recursive, M_related_Y_Q);
			return G_def(M, Y)(exist, M_natural, Y_in_D);
		}
		//Completing the induction
		return induction[<N: ^X(related(N, X, G))>](zero_related_exists, inductive_step);
	}

	//I must prove there is at most one object related to each natural
	prove function_G: *N*X*Y(related(N, X, G) & related(N, Y, G) -> X = Y){
		//By induction
		prove base_case: *X*Y(related(ZERO, X, G) & related(ZERO, Y, G) -> X = Y){
			given |X, Y|;
			assume zero_related_X, zero_related_Y;
			P_exists, zero_natural, X_in_D = G_def(ZERO, X)(zero_related_X);
			recursive_P, zero_related_X_P = P_exists|P|;
			relation_P, zero_P, recursion_P = expand(recursive_P);
			X_eq_S = zero_P(X)(zero_related_X_P);
			Q_exists, zero_natural, Y_in_D = G_def(ZERO, Y)(zero_related_Y);
			recursive_Q, zero_related_Y_Q = Q_exists|Q|;
			relation_Q, zero_Q, recursion_Q = expand(recursive_Q);
			Y_eq_S = zero_Q(Y)(zero_related_Y_Q);
			S_eq_Y = equal_symmetric(Y, S)(Y_eq_S);
			return equal_transitive(X, S, Y)(X_eq_S, S_eq_Y);
		}
		prove inductive_step: *N*M(*X*Y(related(N, X, G) & related(N, Y, G) -> X = Y) & successor(M, N) -> *X*Y(related(M, X, G) & related(M, Y, G) -> X = Y)){
			given |N, M|;
			assume unique_N, successor_M;
			given |X, Y|;
			assume M_related_X, M_related_Y;

			P_exists, M_natural, X_in_D = G_def(M, X)(M_related_X);
			recursive_P, M_related_X_P = P_exists|P|;
			relation_P, zero_P, recursion_P = expand(recursive_P);
			N_related_U_P, U_related_X_F = recursion_P(N, M, X)(successor_M, M_related_X_P)|U|;
			exist = exists[<C: related(U, C, F)>](X)(U_related_X_F);
			U_in_D = expand(F_domain_D)(U)(exist);
			N_natural = predecessor_natural(N, M)(M_natural, successor_M);
			exist = exists[<C: recursive_part(C) & related(N, U, C)>](P)(recursive_P, N_related_U_P);
			N_related_U = G_def(N, U)(exist, N_natural, U_in_D);

			Q_exists, M_natural, Y_in_D = G_def(M, Y)(M_related_Y);
			recursive_Q, M_related_Y_Q = Q_exists|Q|;
			relation_Q, zero_Q, recursion_Q = expand(recursive_Q);
			N_related_V_Q, V_related_Y_F = recursion_Q(N, M, Y)(successor_M, M_related_Y_Q)|V|;
			exist = exists[<C: related(V, C, F)>](Y)(V_related_Y_F);
			V_in_D = expand(F_domain_D)(V)(exist);
			exist = exists[<C: recursive_part(C) & related(N, V, C)>](Q)(recursive_Q, N_related_V_Q);
			N_related_V = G_def(N, V)(exist, N_natural, V_in_D);

			//Here is where we are using the inductive hypothesis
			U_eq_V = unique_N(U, V)(N_related_U, N_related_V);
			U_related_Y_F = replace[<C: related(C, Y, F)>](U, V)(U_eq_V)(V_related_Y_F);
			relation_F, unique_output = expand(function_F);
			return unique_output(U, X, Y)(U_related_X_F, U_related_Y_F);
		}

		result = induction[<N: *X*Y(related(N, X, G) & related(N, Y, G) -> X = Y)>](base_case, inductive_step);
		given |N, X, Y|;
		assume N_related_X, N_related_Y;
		exist, N_natural, X_in_D = G_def(N, X)(N_related_X);
		return result(N)(N_natural)(X, Y)(N_related_X, N_related_Y);
	}

	//We've proven G is a function!
	//This is the hardest part (I think)
	function_G = #function(G)(relation_G, function_G);

	//Next we prove the domain of G is the naturals
	prove domain_naturals: *N(N in NATURALS <-> ^X(related(N, X, G))){
		given |N|;
		prove lemma: ^X(related(N, X, G)) -> N in NATURALS{
			assume exist;
			N_related_X = exist|X|;
			exist, N_natural, X_in_D = G_def(N, X)(N_related_X);
			return N_natural;
		}
		return iff(G_relates_naturals(N), lemma);
	}
	domain_naturals = #domain(NATURALS, G)(domain_naturals);

	//And we prove the codomain of G is D
	prove codomain_D: *X*Y(related(X, Y, G) -> Y in D){
		given |X, Y|;
		assume X_related_Y;
		exist, X_natural, Y_in_D = G_def(X, Y)(X_related_Y);
		return Y_in_D;
	}
	codomain_D = #codomain(D, G)(codomain_D);

	//Now we show what objects are related to zero by G
	prove zero_G: *X(related(ZERO, X, G) <-> X = S){
		given |X|;
		prove lemma0: related(ZERO, X, G) -> X = S{
			assume zero_related_X;
			relation_G, function_G = expand(function_G);
			return function_G(ZERO, X, S)(zero_related_X, zero_related_S_G);
		}
		prove lemma1: X = S -> related(ZERO, X, G){
			assume X_eq_S;
			return replace[<C: related(ZERO, C, G)>](X, S)(X_eq_S)(zero_related_S_G);
		}
		return iff(lemma0, lemma1);
	}

	//Finally, we show that G(n) is F applied n times
	prove recursion_G: *N*M*Y(successor(M, N) & related(M, Y, G) -> ^X(related(N, X, G) & related(X, Y, F))){
		given |N, M, Y|;
		assume successor_M, M_related_Y;
		exist, M_natural, Y_in_D = G_def(M, Y)(M_related_Y);
		recursive_P, M_related_Y_P = exist|P|;
		relation_P, zero_P, recursion_P = expand(recursive_P);
		N_related_X_P, X_related_Y_F = recursion_P(N, M, Y)(successor_M, M_related_Y_P)|X|;
		choose X;
		exist = exists[<C: related(X, C, F)>](Y)(X_related_Y_F);
		X_in_D = expand(F_domain_D)(X)(exist);
		N_natural = predecessor_natural(N, M)(M_natural, successor_M);
		exist = exists[<C: recursive_part(C) & related(N, X, C)>](P)(recursive_P, N_related_X_P);
		N_related_X = G_def(N, X)(exist, N_natural, X_in_D);
		return N_related_X, X_related_Y_F;
	}

	//Finally!
	return function_G, domain_naturals, codomain_D, zero_G, recursion_G;
}

//Construct the successor function as an object
SUCCESSOR_relation, SUCCESSOR_def = relation_exists[<X, Y: successor(Y, X)>](NATURALS, NATURALS)|SUCCESSOR|;

//This function's domain is the naturals
prove successor_domain_naturals: *N(N in NATURALS <-> ^M(related(N, M, SUCCESSOR))){
	given |N|;
	prove lemma0: N in NATURALS -> ^M(related(N, M, SUCCESSOR)){
		assume N_natural;
		successor_M = successor(N)|M|;
		choose M;
		M_natural = successor_natural(N, M)(N_natural, successor_M);
		return SUCCESSOR_def(N, M)(successor_M, N_natural, M_natural);
	}
	prove lemma1: ^M(related(N, M, SUCCESSOR)) -> N in NATURALS{
		assume exist;
		N_related_M = exist|M|;
		return SUCCESSOR_def(N, M)(N_related_M);
	}
	return iff(lemma0, lemma1);
}
successor_domain_naturals = #domain(NATURALS, SUCCESSOR)(successor_domain_naturals);

//The codomain is also the naturals
prove successor_codomain_naturals: *N*M(related(N, M, SUCCESSOR) -> M in NATURALS){
	given |N, M|;
	assume N_related_M;
	return SUCCESSOR_def(N, M)(N_related_M);
}
successor_codomain_naturals = #codomain(NATURALS, SUCCESSOR)(successor_codomain_naturals);

//Proving it's a function
prove successor_function: *N*M*L(related(N, M, SUCCESSOR) & related(N, L, SUCCESSOR) -> M = L){
	given |N, M, L|;
	assume N_related_M, N_related_L;
	successor_M, N_natural, M_natural = SUCCESSOR_def(N, M)(N_related_M);
	successor_L, N_natural, L_natural = SUCCESSOR_def(N, L)(N_related_L);
	return successor_unique(M, L, N)(successor_M, successor_L);
}
successor_function = #function(SUCCESSOR)(SUCCESSOR_relation, successor_function);

define addition_function(F, N): function(F) & domain(NATURALS, F) & codomain(NATURALS, F) & related(ZERO, N, F) & *M*Y*L*Z(successor(L, M) & related(M, Y, F) & related(L, Z, F) -> successor(Z, Y));

define sum(A, B, C): *F(addition_function(F, B) -> related(C, A, F));

prove addition_function_exists: *N(N in NATURALS -> ^F(addition_function(F, N))){
	given |N|;
	assume N_natural;
	F_def = recursion(SUCCESSOR, NATURALS, N)(successor_function, successor_domain_naturals, successor_codomain_naturals, N_natural)|F|;
	choose F;
	function_F, domain_naturals, codomain_naturals, F_zero, F_recursion = F_def;
	relation_F, function_F_def = expand(function_F);
	ZERO_related_N = F_zero(N)(equal_reflexive(N));
	prove recursion: *M*Y*L*Z(successor(L, M) & related(M, Y, F) & related(L, Z, F) -> successor(Z, Y)){
		given |M, Y, L, Z|;
		assume successor_L, M_related_Y, L_related_Z;
		M_related_Y2, Y2_related_Z_successor = F_recursion(M, L, Z)(successor_L, L_related_Z)|Y2|;
		Y_eq_Y2 = function_F_def(M, Y, Y2)(M_related_Y, M_related_Y2);
		Y_related_Z_successor = replace[<C: related(C, Z, SUCCESSOR)>](Y, Y2)(Y_eq_Y2)(Y2_related_Z_successor);
		return SUCCESSOR_def(Y, Z)(Y_related_Z_successor);
	}
	return #addition_function(F, N)(function_F, domain_naturals, codomain_naturals, ZERO_related_N, recursion);
}

