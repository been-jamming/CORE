include "zfc_axioms.core";
include "relations_axioms.core";

axiom exists[P(1)]: *X(P(X) -> ^Y(P(Y)));
axiom equal_reflexive: *A(A = A);
axiom equal_symmetric: *A*B(A = B <-> B = A);
axiom equal_transitive: *A*B*C(A = B & B = C -> A = C);

object NATURALS;
object ZERO;

axiom zero_natural: ZERO in NATURALS;
axiom successor: *A^B(successor(B, A));
axiom successor_unique: *A*B*C(successor(A, C) & successor(B, C) -> A = B);
axiom successor_natural: *X*Y(X in NATURALS & successor(Y, X) -> Y in NATURALS);
axiom successor_injective: *X*Y*Z(successor(X, Y) & successor(X, Z) -> Y = Z);
axiom zero_not_successor: *X(~successor(ZERO, X));
//Since we're working in ZFC, this axiom is strong enough
axiom induction[P(1)]: P(ZERO) & *X*Y(P(X) & successor(Y, X) -> P(Y)) -> *N(N in NATURALS -> P(N));

one_def = successor(ZERO)|ONE|;
one_natural = successor_natural(ZERO, ONE)(zero_natural, one_def);
two_def = successor(ONE)|TWO|;
two_natural = successor_natural(ONE, TWO)(one_natural, two_def);

//First I need to prove that the predecessor of a natural number exists
prove predecessor: *M(M in NATURALS & ~M = ZERO -> ^N(N in NATURALS & successor(M, N))){
	//The proposition to induct on
	define P(M): M in NATURALS & (~M = ZERO -> ^N(N in NATURALS & successor(M, N)));
	prove base_case: ~ZERO = ZERO -> ^N(N in NATURALS & successor(ZERO, N)){
		assume not_reflexive;
		return zero_natural, not_reflexive(equal_reflexive(ZERO));
	}
	base_case = #P(ZERO)(zero_natural, base_case);
	prove inductive_case: *M*L(P(M) & successor(L, M) -> P(L)){
		given |M, L|;
		assume P_M, successor_L;
		M_natural, M_cond = expand(P_M);
		L_natural = successor_natural(M, L)(M_natural, successor_L);
		prove L_cond: ~L = ZERO -> ^N(N in NATURALS & successor(L, N)){
			assume L_not_zero;
			choose M;
			return M_natural, successor_L;
		}
		return #P(L)(L_natural, L_cond);
	}
	result = induction[<M: P(M)>](base_case, inductive_case);
	given |M|;
	assume M_natural, M_not_zero;
	M_natural, M_cond = expand(result(M)(M_natural));
	return M_cond(M_not_zero);
}

//Now I will prove that the predecessor of a natural number is natural
prove predecessor_natural: *N*M(M in NATURALS & successor(M, N) -> N in NATURALS){
	given |N, M|;
	assume M_natural, successor_M;
	prove M_not_zero: ~M = ZERO{
		assume M_eq_ZERO;
		successor_zero = replace[<Q: successor(Q, N)>](M, ZERO)(M_eq_ZERO)(successor_M);
		return zero_not_successor(N)(successor_zero);
	}
	N2_natural, successor_M_N2 = predecessor(M)(M_natural, M_not_zero)|N2|;
	N_eq_N2 = successor_injective(M, N, N2)(successor_M, successor_M_N2);
	return replace[<Q: Q in NATURALS>](N, N2)(N_eq_N2)(N2_natural);
}

//We'll see how this goes
//Attempt number 2
prove recursion: *F*D*S(function(F) & domain(D, F) & codomain(D, F) & S in D -> ^G(function(G) & domain(NATURALS, G) & codomain(D, G) & *X(related(ZERO, X, G) <-> X = S) & *N*M*Y(successor(M, N) & related(M, Y, G) -> ^X(related(N, X, G) & related(X, Y, F))))){
	given |F, D, S|;
	assume function_F, F_domain_D, F_codomain_D, S_in_D;
	//Define the partial versions of G as "recursive parts"
	define recursive_part(A): is_relation(A) & *X(related(ZERO, X, A) -> X = S) & *N*M*Y(successor(M, N) & related(M, Y, A) -> ^X(related(N, X, A) & related(X, Y, F)));
	//Now X and Y are related under G if they are related by some recursive part
	relation_G, G_def = relation_exists[<X, Y: ^A(recursive_part(A) & related(X, Y, A))>](NATURALS, D)|G|;
	choose G;

	//We have to construct the simplest non-trivial recursive part manually
	//It relates 0 and S
	relation_INITIAL, INITIAL_def = relation_exists[<X, Y: X = ZERO & Y = S>](NATURALS, D)|INITIAL|;
	//Prove that zero is only related to S
	prove initial_zero: *X(related(ZERO, X, INITIAL) -> X = S){
		given |X|;
		assume zero_related_X;
		return INITIAL_def(ZERO, X)(zero_related_X);
	}
	//Prove that INITIAL is recursive
	prove initial_recursive: *N*M*Y(successor(M, N) & related(M, Y, INITIAL) -> ^X(related(N, X, INITIAL) & related(X, Y, F))){
		given |N, M, Y|;
		assume successor_M, M_related_Y;
		M_eq_zero, Y_eq_S, M_in_NATURALS, Y_in_D = INITIAL_def(M, Y)(M_related_Y);
		successor_zero = replace[<Q: successor(Q, N)>](M, ZERO)(M_eq_zero)(successor_M);
		return zero_not_successor(N)(successor_zero);
	}
	recursive_part_INITIAL = #recursive_part(INITIAL)(relation_INITIAL, initial_zero, initial_recursive);
	zero_related_S_INITIAL = INITIAL_def(ZERO, S)(equal_reflexive(ZERO), equal_reflexive(S), zero_natural, S_in_D);
	initial_exists = exists[<Q: recursive_part(Q) & related(ZERO, S, Q)>](INITIAL)(recursive_part_INITIAL, zero_related_S_INITIAL);
	zero_related_S_G = G_def(ZERO, S)(initial_exists, zero_natural, S_in_D);

	//Now for each natural number, we need to prove that G relates it
	prove G_relates_naturals: *N(N in NATURALS -> ^X(related(N, X, G))){
		zero_related_exists = exists[<Q: related(ZERO, Q, G)>](S)(zero_related_S_G);

		//Now we have to prove that if N is related, N + 1 is
		prove inductive_step: *N*M(^X(related(N, X, G)) & successor(M, N) -> ^Y(related(M, Y, G))){
			given |N, M|;
			assume X_exists, successor_M;
			N_related_X = X_exists|X|;
			P_exists, N_natural, X_in_D = G_def(N, X)(N_related_X);
			M_natural = successor_natural(N, M)(N_natural, successor_M);
			recursive_P, N_related_X_P = P_exists|P|;
			relation_P, zero_P, recursion_P = expand(recursive_P);
			X_related_Y_F = expand(F_domain_D)(X)(X_in_D)|Y|;
			Y_in_D = expand(F_codomain_D)(X, Y)(X_related_Y_F);
			choose Y;
			//I will define a new recursive part which relates M to Y and uses P for everything else
			relation_Q, Q_def = relation_exists[<L, Z: related(L, Z, P) | L = M & Z = Y>](NATURALS, D)|Q|;
			N_related_X_Q = Q_def(N, X)(N_related_X_P, N_natural, X_in_D);
			M_related_Y_Q = Q_def(M, Y)(equal_reflexive(M), equal_reflexive(Y), M_natural, Y_in_D);
			//Now I must prove that zero is only related to S
			prove Q_zero: *Z(related(ZERO, Z, Q) -> Z = S){
				given |Z|;
				assume zero_related_Z;
				either, zero_natural, Z_in_D = Q_def(ZERO, Z)(zero_related_Z);
				return branch(either, zero_related_Z_P, both){
					return zero_P(Z)(zero_related_Z_P);
				} or {
					zero_eq_M, Z_eq_Y = both;
					successor_zero = replace[<Q: successor(Q, N)>](ZERO, M)(zero_eq_M)(successor_M);
					return trivial(<: false -> Z = S>)(zero_not_successor(N)(successor_zero));
				};
			}
			//And next I need that Q is recursive
			prove Q_recursive: *L*R*V(successor(R, L) & related(R, V, Q) -> ^U(related(L, U, Q) & related(U, V, F))){
				given |L, R, V|;
				assume successor_R, R_related_V_Q;
				either, R_natural, V_in_D = Q_def(R, V)(R_related_V_Q);
				return branch(either, R_related_V_P, both){
					L_related_U_P, U_related_V_F = recursion_P(L, R, V)(successor_R, R_related_V_P)|U|;
					L_natural = predecessor_natural(L, R)(R_natural, successor_R);
					exist = exists[<C: related(U, C, F)>](V)(U_related_V_F);
					U_in_D = expand(F_domain_D)(U)(exist);
					L_related_U_Q = Q_def(L, U)(L_related_U_P, L_natural, U_in_D);
					return exists[<C: related(L, C, Q) & related(C, V, F)>](U)(L_related_U_Q, U_related_V_F);
				} or {
					R_eq_M, V_eq_Y = both;
					successor_M_other = replace[<T: successor(T, L)>](R, M)(R_eq_M)(successor_R);
					N_eq_L = successor_injective(M, N, L)(successor_M, successor_M_other);
					prove exist: ^X(related(L, X, Q) & related(X, V, F)){
						choose X;
						return replace[<T: related(T, X, Q)>](N, L)(N_eq_L)(N_related_X_Q), replace[<T: related(X, T, F)>](V, Y)(V_eq_Y)(X_related_Y_F);
					}
					return exist;
				};
			}
			//Now we know that Q is a recursive part!
			Q_recursive = #recursive_part(Q)(relation_Q, Q_zero, Q_recursive);
			exist = exists[<C: recursive_part(C) & related(M, Y, C)>](Q)(Q_recursive, M_related_Y_Q);
			return G_def(M, Y)(exist, M_natural, Y_in_D);
		}
		//Completing the induction
		return induction[<N: ^X(related(N, X, G))>](zero_related_exists, inductive_step);
	}

	//I must prove there is at most one object related to each natural
	prove function_G: *N*X*Y(related(N, X, G) & related(N, Y, G) -> X = Y){
		//By induction
		prove base_case: *X*Y(related(ZERO, X, G) & related(ZERO, Y, G) -> X = Y){
			given |X, Y|;
			assume zero_related_X, zero_related_Y;
			P_exists, zero_natural, X_in_D = G_def(ZERO, X)(zero_related_X);
			recursive_P, zero_related_X_P = P_exists|P|;
			relation_P, zero_P, recursion_P = expand(recursive_P);
			X_eq_S = zero_P(X)(zero_related_X_P);
			Q_exists, zero_natural, Y_in_D = G_def(ZERO, Y)(zero_related_Y);
			recursive_Q, zero_related_Y_Q = Q_exists|Q|;
			relation_Q, zero_Q, recursion_Q = expand(recursive_Q);
			Y_eq_S = zero_Q(Y)(zero_related_Y_Q);
			S_eq_Y = equal_symmetric(Y, S)(Y_eq_S);
			return equal_transitive(X, S, Y)(X_eq_S, S_eq_Y);
		}
		prove inductive_step: *N*M(*X*Y(related(N, X, G) & related(N, Y, G) -> X = Y) & successor(M, N) -> *X*Y(related(M, X, G) & related(M, Y, G) -> X = Y)){
			given |N, M|;
			assume unique_N, successor_M;
			given |X, Y|;
			assume M_related_X, M_related_Y;

			P_exists, M_natural, X_in_D = G_def(M, X)(M_related_X);
			recursive_P, M_related_X_P = P_exists|P|;
			relation_P, zero_P, recursion_P = expand(recursive_P);
			N_related_U_P, U_related_X_F = recursion_P(N, M, X)(successor_M, M_related_X_P)|U|;
			exist = exists[<C: related(U, C, F)>](X)(U_related_X_F);
			U_in_D = expand(F_domain_D)(U)(exist);
			N_natural = predecessor_natural(N, M)(M_natural, successor_M);
			exist = exists[<C: recursive_part(C) & related(N, U, C)>](P)(recursive_P, N_related_U_P);
			N_related_U = G_def(N, U)(exist, N_natural, U_in_D);

			Q_exists, M_natural, Y_in_D = G_def(M, Y)(M_related_Y);
			recursive_Q, M_related_Y_Q = Q_exists|Q|;
			relation_Q, zero_Q, recursion_Q = expand(recursive_Q);
			N_related_V_Q, V_related_Y_F = recursion_Q(N, M, Y)(successor_M, M_related_Y_Q)|V|;
			exist = exists[<C: related(V, C, F)>](Y)(V_related_Y_F);
			V_in_D = expand(F_domain_D)(V)(exist);
			exist = exists[<C: recursive_part(C) & related(N, V, C)>](Q)(recursive_Q, N_related_V_Q);
			N_related_V = G_def(N, V)(exist, N_natural, V_in_D);

			//Here is where we are using the inductive hypothesis
			U_eq_V = unique_N(U, V)(N_related_U, N_related_V);
			U_related_Y_F = replace[<C: related(C, Y, F)>](U, V)(U_eq_V)(V_related_Y_F);
			relation_F, unique_output = expand(function_F);
			return unique_output(U, X, Y)(U_related_X_F, U_related_Y_F);
		}

		result = induction[<N: *X*Y(related(N, X, G) & related(N, Y, G) -> X = Y)>](base_case, inductive_step);
		given |N, X, Y|;
		assume N_related_X, N_related_Y;
		exist, N_natural, X_in_D = G_def(N, X)(N_related_X);
		return result(N)(N_natural)(X, Y)(N_related_X, N_related_Y);
	}

	//We've proven G is a function!
	//This is the hardest part (I think)
	function_G = #function(G)(relation_G, function_G);

	//Next we prove the domain of G is the naturals
	prove domain_naturals: *N(N in NATURALS <-> ^X(related(N, X, G))){
		given |N|;
		prove lemma: ^X(related(N, X, G)) -> N in NATURALS{
			assume exist;
			N_related_X = exist|X|;
			exist, N_natural, X_in_D = G_def(N, X)(N_related_X);
			return N_natural;
		}
		return iff(G_relates_naturals(N), lemma);
	}
	domain_naturals = #domain(NATURALS, G)(domain_naturals);

	//And we prove the codomain of G is D
	prove codomain_D: *X*Y(related(X, Y, G) -> Y in D){
		given |X, Y|;
		assume X_related_Y;
		exist, X_natural, Y_in_D = G_def(X, Y)(X_related_Y);
		return Y_in_D;
	}
	codomain_D = #codomain(D, G)(codomain_D);

	//Now we show what objects are related to zero by G
	prove zero_G: *X(related(ZERO, X, G) <-> X = S){
		given |X|;
		prove lemma0: related(ZERO, X, G) -> X = S{
			assume zero_related_X;
			relation_G, function_G = expand(function_G);
			return function_G(ZERO, X, S)(zero_related_X, zero_related_S_G);
		}
		prove lemma1: X = S -> related(ZERO, X, G){
			assume X_eq_S;
			return replace[<C: related(ZERO, C, G)>](X, S)(X_eq_S)(zero_related_S_G);
		}
		return iff(lemma0, lemma1);
	}

	//Finally, we show that G(n) is F applied n times
	prove recursion_G: *N*M*Y(successor(M, N) & related(M, Y, G) -> ^X(related(N, X, G) & related(X, Y, F))){
		given |N, M, Y|;
		assume successor_M, M_related_Y;
		exist, M_natural, Y_in_D = G_def(M, Y)(M_related_Y);
		recursive_P, M_related_Y_P = exist|P|;
		relation_P, zero_P, recursion_P = expand(recursive_P);
		N_related_X_P, X_related_Y_F = recursion_P(N, M, Y)(successor_M, M_related_Y_P)|X|;
		choose X;
		exist = exists[<C: related(X, C, F)>](Y)(X_related_Y_F);
		X_in_D = expand(F_domain_D)(X)(exist);
		N_natural = predecessor_natural(N, M)(M_natural, successor_M);
		exist = exists[<C: recursive_part(C) & related(N, X, C)>](P)(recursive_P, N_related_X_P);
		N_related_X = G_def(N, X)(exist, N_natural, X_in_D);
		return N_related_X, X_related_Y_F;
	}

	//Finally!
	return function_G, domain_naturals, codomain_D, zero_G, recursion_G;
}

//Construct the successor function as an object
SUCCESSOR_relation, SUCCESSOR_def = relation_exists[<X, Y: successor(Y, X)>](NATURALS, NATURALS)|SUCCESSOR|;

//This function's domain is the naturals
prove successor_domain_naturals: *N(N in NATURALS <-> ^M(related(N, M, SUCCESSOR))){
	given |N|;
	prove lemma0: N in NATURALS -> ^M(related(N, M, SUCCESSOR)){
		assume N_natural;
		successor_M = successor(N)|M|;
		choose M;
		M_natural = successor_natural(N, M)(N_natural, successor_M);
		return SUCCESSOR_def(N, M)(successor_M, N_natural, M_natural);
	}
	prove lemma1: ^M(related(N, M, SUCCESSOR)) -> N in NATURALS{
		assume exist;
		N_related_M = exist|M|;
		return SUCCESSOR_def(N, M)(N_related_M);
	}
	return iff(lemma0, lemma1);
}
successor_domain_naturals = #domain(NATURALS, SUCCESSOR)(successor_domain_naturals);

//The codomain is also the naturals
prove successor_codomain_naturals: *N*M(related(N, M, SUCCESSOR) -> M in NATURALS){
	given |N, M|;
	assume N_related_M;
	return SUCCESSOR_def(N, M)(N_related_M);
}
successor_codomain_naturals = #codomain(NATURALS, SUCCESSOR)(successor_codomain_naturals);

//Proving it's a function
prove successor_function: *N*M*L(related(N, M, SUCCESSOR) & related(N, L, SUCCESSOR) -> M = L){
	given |N, M, L|;
	assume N_related_M, N_related_L;
	successor_M, N_natural, M_natural = SUCCESSOR_def(N, M)(N_related_M);
	successor_L, N_natural, L_natural = SUCCESSOR_def(N, L)(N_related_L);
	return successor_unique(M, L, N)(successor_M, successor_L);
}
successor_function = #function(SUCCESSOR)(SUCCESSOR_relation, successor_function);

define addition_function(F, N): function(F) & domain(NATURALS, F) & codomain(NATURALS, F) & related(ZERO, N, F) & *M*Y*L*Z(successor(L, M) & related(M, Y, F) & related(L, Z, F) -> successor(Z, Y));

define sum(A, B, C): B in NATURALS & C in NATURALS & *F(addition_function(F, B) -> related(C, A, F));

//Addition functions always exist
prove addition_function_exists: *N(N in NATURALS -> ^F(addition_function(F, N))){
	given |N|;
	assume N_natural;
	F_def = recursion(SUCCESSOR, NATURALS, N)(successor_function, successor_domain_naturals, successor_codomain_naturals, N_natural)|F|;
	choose F;
	function_F, domain_naturals, codomain_naturals, F_zero, F_recursion = F_def;
	relation_F, function_F_def = expand(function_F);
	ZERO_related_N = F_zero(N)(equal_reflexive(N));
	prove recursion: *M*Y*L*Z(successor(L, M) & related(M, Y, F) & related(L, Z, F) -> successor(Z, Y)){
		given |M, Y, L, Z|;
		assume successor_L, M_related_Y, L_related_Z;
		M_related_Y2, Y2_related_Z_successor = F_recursion(M, L, Z)(successor_L, L_related_Z)|Y2|;
		Y_eq_Y2 = function_F_def(M, Y, Y2)(M_related_Y, M_related_Y2);
		Y_related_Z_successor = replace[<C: related(C, Z, SUCCESSOR)>](Y, Y2)(Y_eq_Y2)(Y2_related_Z_successor);
		return SUCCESSOR_def(Y, Z)(Y_related_Z_successor);
	}
	return #addition_function(F, N)(function_F, domain_naturals, codomain_naturals, ZERO_related_N, recursion);
}

//Addition functions are unique
prove addition_function_unique: *N*F*G*X*Y(N in NATURALS & addition_function(F, N) & addition_function(G, N) & related(X, Y, F) -> related(X, Y, G)){
	given |N, F, G, X, Y|;
	assume N_natural, addition_F, addition_G, X_related_Y_F;
	function_F, domain_F, codomain_F, zero_F, recursive_F = expand(addition_F);
	relation_F, function_F = expand(function_F);
	function_G, domain_G, codomain_G, zero_G, recursive_G = expand(addition_G);
	relation_G, function_G = expand(function_G);
	Y_exists = exists[<Q: related(X, Q, F)>](Y)(X_related_Y_F);
	X_natural = expand(domain_F)(X)(Y_exists);
	prove induction_result: *X(X in NATURALS -> *Y(related(X, Y, F) -> related(X, Y, G))){
		prove base_case: *Y(related(ZERO, Y, F) -> related(ZERO, Y, G)){
			given |Y|;
			assume ZERO_related_Y_F;
			N_eq_Y = function_F(ZERO, N, Y)(zero_F, ZERO_related_Y_F);
			return replace[<Q: related(ZERO, Q, G)>](N, Y)(N_eq_Y)(zero_G);
		}
		prove inductive_step: *X*Y(*V(related(X, V, F) -> related(X, V, G)) & successor(Y, X) -> *V(related(Y, V, F) -> related(Y, V, G))){
			given |X, Y|;
			assume hypothesis, successor_Y;
			given |V|;
			assume Y_related_V_F;
			V_exists = exists[<Q: related(Y, Q, F)>](V)(Y_related_V_F);
			Y_natural = expand(domain_F)(Y)(V_exists);
			X_natural = predecessor_natural(X, Y)(Y_natural, successor_Y);
			X_related_W_F = expand(domain_F)(X)(X_natural)|W|;
			X_related_W_G = hypothesis(W)(X_related_W_F);
			successor_V = recursive_F(X, W, Y, V)(successor_Y, X_related_W_F, Y_related_V_F);
			Y_related_V1_G = expand(domain_G)(Y)(Y_natural)|V1|;
			successor_V1 = recursive_G(X, W, Y, V1)(successor_Y, X_related_W_G, Y_related_V1_G);
			V_eq_V1 = successor_unique(V, V1, W)(successor_V, successor_V1);
			return replace[<Q: related(Y, Q, G)>](V, V1)(V_eq_V1)(Y_related_V1_G);
		}
		return induction[<Q: *Y(related(Q, Y, F) -> related(Q, Y, G))>](base_case, inductive_step);
	}
	return induction_result(X)(X_natural)(Y)(X_related_Y_F);
}

//The sum of two naturals exists
prove sum: *A*B(A in NATURALS & B in NATURALS -> ^C(sum(C, A, B))){
	given |A, B|;
	assume A_natural, B_natural;
	addition_F = addition_function_exists(A)(A_natural)|F|;
	function_F, domain_F, codomain_F, zero_F, recursion_F = expand(addition_F);
	B_related_C_F = expand(domain_F)(B)(B_natural)|C|;
	choose C;
	prove sum_C: *G(addition_function(G, A) -> related(B, C, G)){
		given |G|;
		assume addition_G;
		return addition_function_unique(A, F, G, B, C)(A_natural, addition_F, addition_G, B_related_C_F);
	}
	return #sum(C, A, B)(A_natural, B_natural, sum_C);
}

//The sum of two natural numbers is unique
prove sum_unique: *A*B*C*D(sum(C, A, B) & sum(D, A, B) -> C = D){
	given |A, B, C, D|;
	assume sum_C, sum_D;
	A_natural, B_natural, sum_C = expand(sum_C);
	A_natural, B_natural, sum_D = expand(sum_D);
	addition_F = addition_function_exists(A)(A_natural)|F|;
	function_F, domain_F, codomain_F, zero_F, recursion_F = expand(addition_F);
	relation_F, function_F = expand(function_F);
	B_related_C_F = sum_C(F)(addition_F);
	B_related_D_F = sum_D(F)(addition_F);
	return function_F(B, C, D)(B_related_C_F, B_related_D_F);
}

//The sum of N and 0 is N
prove sum_zero: *A(A in NATURALS -> sum(A, A, ZERO)){
	given |A|;
	assume A_natural;
	prove sum_A: *F(addition_function(F, A) -> related(ZERO, A, F)){
		given |F|;
		assume addition_F;
		return expand(addition_F);
	}
	return #sum(A, A, ZERO)(A_natural, zero_natural, sum_A);
}

//The recursive rule for sum
prove sum_recursion: *A*B*C*D*E(successor(C, B) & sum(D, A, B) & sum(E, A, C) -> successor(E, D)){
	given |A, B, C, D, E|;
	assume successor_C, sum_D, sum_E;
	A_natural, B_natural, sum_D = expand(sum_D);
	A_natural, C_natural, sum_E = expand(sum_E);
	addition_F = addition_function_exists(A)(A_natural)|F|;
	B_related_D_F = sum_D(F)(addition_F);
	C_related_E_F = sum_E(F)(addition_F);
	function_F, domain_F, codomain_F, zero_F, recursion_F = expand(addition_F);
	return recursion_F(B, D, C, E)(successor_C, B_related_D_F, C_related_E_F);
}

//The sum of two naturals is natural
prove sum_natural: *A*B*C(sum(A, B, C) -> A in NATURALS){
	given |A, B, C|;
	assume sum_A;
	B_natural, C_natural, sum_A = expand(sum_A);
	addition_F = addition_function_exists(B)(B_natural)|F|;
	C_related_A_F = sum_A(F)(addition_F);
	function_F, domain_F, codomain_F, zero_F, recursion_F = expand(addition_F);
	return expand(codomain_F)(C, A)(C_related_A_F);
}

//These two rules uniquely determine addition. They are often used as a definition.

//Now I must prove that addition is commutative. I can do this by proving the symmetric versions of the defining identities.

//Symmetric version of the sum_zero identity
prove sum_zero2: *A(A in NATURALS -> sum(A, ZERO, A)){
	base_step = sum_zero(ZERO)(zero_natural);
	prove inductive_step: *Y*Z(sum(Y, ZERO, Y) & successor(Z, Y) -> sum(Z, ZERO, Z)){
		given |Y, Z|;
		assume sum_Y, successor_Z;
		zero_natural, Y_natural, sum_Y = expand(sum_Y);
		Z_natural = successor_natural(Y, Z)(Y_natural, successor_Z);
		prove sum_Z: *F(addition_function(F, ZERO) -> related(Z, Z, F)){
			given |F|;
			assume addition_F;
			Y_related_Y_F = sum_Y(F)(addition_F);
			function_F, domain_F, codomain_F, zero_F, recursion_F = expand(addition_F);
			Z_related_Z2_F = expand(domain_F)(Z)(Z_natural)|Z2|;
			successor_Z2 = recursion_F(Y, Y, Z, Z2)(successor_Z, Y_related_Y_F, Z_related_Z2_F);
			Z_eq_Z2 = successor_unique(Z, Z2, Y)(successor_Z, successor_Z2);
			return replace[<Q: related(Z, Q, F)>](Z, Z2)(Z_eq_Z2)(Z_related_Z2_F);
		}
		return #sum(Z, ZERO, Z)(zero_natural, Z_natural, sum_Z);
	}
	return induction[<Q: sum(Q, ZERO, Q)>](base_step, inductive_step);
}

//Symmetric version of the sum_recursion identity
prove sum_recursion2: *A*B*C*D*E(successor(B, A) & sum(D, A, C) & sum(E, B, C) -> successor(E, D)){
	define R(C): *A*B*D*E(successor(B, A) & sum(D, A, C) & sum(E, B, C) -> successor(E, D));
	prove base_case: *A*B*D*E(successor(B, A) & sum(D, A, ZERO) & sum(E, B, ZERO) -> successor(E, D)){
		given |A, B, D, E|;
		assume successor_B, sum_D, sum_E;
		A_natural, zero_natural, sum_D_def = expand(sum_D);
		B_natural, zero_natural, sum_E_def = expand(sum_E);
		sum_A = sum_zero(A)(A_natural);
		sum_B = sum_zero(B)(B_natural);
		A_eq_D = sum_unique(A, ZERO, A, D)(sum_A, sum_D);
		B_eq_E = sum_unique(B, ZERO, B, E)(sum_B, sum_E);
		result = replace[<Q: successor(Q, A)>](B, E)(B_eq_E)(successor_B);
		return replace[<Q: successor(E, Q)>](A, D)(A_eq_D)(result);
	}
	base_case = #R(ZERO)(base_case);

	prove inductive_step: *Y*Z(R(Y) & successor(Z, Y) -> R(Z)){
		given |Y, Z|;
		assume R_Y, successor_Z;
		R_Y = expand(R_Y);
		prove R_Z: *A*B*D*E(successor(B, A) & sum(D, A, Z) & sum(E, B, Z) -> successor(E, D)){
			given |A, B, D, E|;
			assume successor_B, sum_D, sum_E;
			A_natural, Z_natural, sum_D_def = expand(sum_D);
			B_natural, Z_natural, sum_E_def = expand(sum_E);
			Y_natural = predecessor_natural(Y, Z)(Z_natural, successor_Z);
			sum_DP = sum(A, Y)(A_natural, Y_natural)|DP|;
			successor_D = sum_recursion(A, Y, Z, DP, D)(successor_Z, sum_DP, sum_D);
			sum_EP = sum(B, Y)(B_natural, Y_natural)|EP|;
			successor_E = sum_recursion(B, Y, Z, EP, E)(successor_Z, sum_EP, sum_E);
			successor_EP = R_Y(A, B, DP, EP)(successor_B, sum_DP, sum_EP);
			EP_eq_D = successor_unique(EP, D, DP)(successor_EP, successor_D);
			return replace[<Q: successor(E, Q)>](EP, D)(EP_eq_D)(successor_E);
		}
		return #R(Z)(R_Z);
	}

	result = induction[<N: R(N)>](base_case, inductive_step);
	given |A, B, C, D, E|;
	assume successor_B, sum_D, sum_E;
	A_natural, C_natural, sum_D_def = expand(sum_D);
	R_C = result(C)(C_natural);
	return expand(R_C)(A, B, D, E)(successor_B, sum_D, sum_E);
}

//Finally proving that addition commutes
prove sum_commutes: *A*B*C(sum(A, B, C) -> sum(A, C, B)){
	define R(C): *A*B(sum(A, B, C) -> sum(A, C, B));

	prove base_case: *A*B(sum(A, B, ZERO) -> sum(A, ZERO, B)){
		given |A, B|;
		assume sum_A;
		B_natural, zero_natural, sum_A_def = expand(sum_A);
		sum_B = sum_zero(B)(B_natural);
		A_eq_B = sum_unique(B, ZERO, A, B)(sum_A, sum_B);
		sum_B = sum_zero2(B)(B_natural);
		return replace[<Q: sum(Q, ZERO, B)>](A, B)(A_eq_B)(sum_B);
	}
	base_case = #R(ZERO)(base_case);

	prove inductive_step: *Y*Z(R(Y) & successor(Z, Y) -> R(Z)){
		given |Y, Z|;
		assume R_Y, successor_Z;
		R_Y = expand(R_Y);
		prove R_Z: *A*B(sum(A, B, Z) -> sum(A, Z, B)){
			given |A, B|;
			assume sum_A;
			B_natural, Z_natural, sum_A_def = expand(sum_A);
			Y_natural = predecessor_natural(Y, Z)(Z_natural, successor_Z);
			sum_AP = sum(B, Y)(B_natural, Y_natural)|AP|;
			successor_A = sum_recursion(B, Y, Z, AP, A)(successor_Z, sum_AP, sum_A);
			sum_AP = R_Y(AP, B)(sum_AP);
			sum_A2 = sum(Z, B)(Z_natural, B_natural)|A2|;
			successor_A2 = sum_recursion2(Y, Z, B, AP, A2)(successor_Z, sum_AP, sum_A2);
			A2_eq_A = successor_unique(A2, A, AP)(successor_A2, successor_A);
			return replace[<Q: sum(Q, Z, B)>](A2, A)(A2_eq_A)(sum_A2);
		}
		return #R(Z)(R_Z);
	}

	result = induction[<N: R(N)>](base_case, inductive_step);
	given |A, B, C|;
	assume sum_A;
	B_natural, C_natural, sum_A_def = expand(sum_A);
	R_C = result(C)(C_natural);
	return expand(R_C)(A, B)(sum_A);
}

//If C is the sum of A and B, then A and B are natural numbers
prove sum_operand_natural: *A*B*C(sum(C, A, B) -> A in NATURALS & B in NATURALS){
	given |A, B, C|;
	assume sum_C;
	return expand(sum_C);
}

//If the sum of A and ZERO is B, then A = B
prove sum_zero_identity: *A*B(sum(B, A, ZERO) | sum(B, ZERO, A) -> A = B){
	given |A, B|;
	assume either;
	sum_B = branch(either, sum_B, sum_B){
		return sum_B;
	} or {
		return sum_commutes(B, ZERO, A)(sum_B);
	};
	A_natural, zero_natural = sum_operand_natural(A, ZERO, B)(sum_B);
	sum_A = sum_zero(A)(A_natural);
	return sum_unique(A, ZERO, A, B)(sum_A, sum_B);
}

//Addition is also associative
prove sum_associates: *A*B*C*D*E*F(sum(D, A, B) & sum(F, D, C) & sum(E, B, C) -> sum(F, A, E)){
	define R(C): *A*B*D*E*F(sum(D, A, B) & sum(F, D, C) & sum(E, B, C) -> sum(F, A, E));

	prove base_case: *A*B*D*E*F(sum(D, A, B) & sum(F, D, ZERO) & sum(E, B, ZERO) -> sum(F, A, E)){
		given |A, B, D, E, F|;
		assume sum_D, sum_F, sum_E;
		D_eq_F = sum_zero_identity(D, F)(sum_F);
		B_eq_E = sum_zero_identity(B, E)(sum_E);
		result = replace[<Q: sum(D, A, Q)>](B, E)(B_eq_E)(sum_D);
		return replace[<Q: sum(Q, A, E)>](D, F)(D_eq_F)(result);
	}
	base_case = #R(ZERO)(base_case);

	prove inductive_step: *Y*Z(R(Y) & successor(Z, Y) -> R(Z)){
		given |Y, Z|;
		assume R_Y, successor_Z;
		R_Y = expand(R_Y);
		prove R_Z: *A*B*D*E*F(sum(D, A, B) & sum(F, D, Z) & sum(E, B, Z) -> sum(F, A, E)){
			given |A, B, D, E, F|;
			assume sum_D, sum_F, sum_E;
			A_natural, B_natural = sum_operand_natural(A, B, D)(sum_D);
			D_natural, Z_natural = sum_operand_natural(D, Z, F)(sum_F);
			Y_natural = predecessor_natural(Y, Z)(Z_natural, successor_Z);
			E_natural = sum_natural(E, B, Z)(sum_E);
			sum_FP = sum(D, Y)(D_natural, Y_natural)|FP|;
			sum_EP = sum(B, Y)(B_natural, Y_natural)|EP|;
			sum_FP2 = R_Y(A, B, D, EP, FP)(sum_D, sum_FP, sum_EP);
			successor_F = sum_recursion(D, Y, Z, FP, F)(successor_Z, sum_FP, sum_F);
			successor_E = sum_recursion(B, Y, Z, EP, E)(successor_Z, sum_EP, sum_E);
			sum_F2 = sum(A, E)(A_natural, E_natural)|F2|;
			successor_F2 = sum_recursion(A, EP, E, FP, F2)(successor_E, sum_FP2, sum_F2);
			F_eq_F2 = successor_unique(F, F2, FP)(successor_F, successor_F2);
			return replace[<Q: sum(Q, A, E)>](F, F2)(F_eq_F2)(sum_F2);
		}
		return #R(Z)(R_Z);
	}

	result = induction[<N: R(N)>](base_case, inductive_step);
	given |A, B, C, D, E, F|;
	assume sum_D, sum_F, sum_E;
	D_natural, C_natural = sum_operand_natural(D, C, F)(sum_F);
	return expand(result(C)(C_natural))(A, B, D, E, F)(sum_D, sum_F, sum_E);
}

//Now that we have defined addition, we can define <
//Normally when the naturals are defined using the von Neumann ordinal,
//A < B can be defined to mean that A in B.
//However, this definition works much more generally

relation A < B: A in NATURALS & B in NATURALS & *C(~sum(A, B, C));

//If A < B, then A < B + 1
prove lt_successor: *A*B*C(A < B & successor(C, B) -> A < C){
	given |A, B, C|;
	assume A_lt_B, successor_C;
	A_natural, B_natural, A_lt_B_def = expand(A_lt_B);
	C_natural = successor_natural(B, C)(B_natural, successor_C);
	prove A_lt_C: *D(~sum(A, C, D)){
		given |D|;
		assume sum_A;
		C_natural, D_natural, sum_A_def = expand(sum_A);
		successor_E = successor(D)|E|;
		E_natural = successor_natural(D, E)(D_natural, successor_E);
		sum_AP = sum(B, D)(B_natural, D_natural)|AP|;
		successor_A = sum_recursion2(B, C, D, AP, A)(successor_C, sum_AP, sum_A);
		sum_A2 = sum(B, E)(B_natural, E_natural)|A2|;
		successor_A2 = sum_recursion(B, D, E, AP, A2)(successor_E, sum_AP, sum_A2);
		A_eq_A2 = successor_unique(A, A2, AP)(successor_A, successor_A2);
		sum_A = replace[<Q: sum(Q, B, E)>](A, A2)(A_eq_A2)(sum_A2);
		return A_lt_B_def(E)(sum_A);
	}
	return #<(A, C)(A_natural, C_natural, A_lt_C);
}

//ZERO is a minimal natural number
prove zero_minimal: *N(N in NATURALS -> N = ZERO | ZERO < N){
	define R(N): N = ZERO | ZERO < N;

	base_case = #R(ZERO)(equal_reflexive(ZERO));
	prove inductive_step: *Y*Z(R(Y) & successor(Z, Y) -> R(Z)){
		given |Y, Z|;
		assume R_Y, successor_Z;
		zero_lt_Z = branch(expand(R_Y), Y_eq_ZERO, ZERO_lt_Y){
			successor_Z = replace[<Q: successor(Z, Q)>](Y, ZERO)(Y_eq_ZERO)(successor_Z);
			Z_natural = successor_natural(ZERO, Z)(zero_natural, successor_Z);
			prove zero_lt_Z: *C(~sum(ZERO, Z, C)){
				given |C|;
				assume sum_ZERO;
				Z_natural, C_natural, sum_ZERO_def = expand(sum_ZERO);
				successor_D = successor(C)|D|;
				sum_C = sum_zero2(C)(C_natural);
				successor_ZERO = sum_recursion2(ZERO, Z, C, C, ZERO)(successor_Z, sum_C, sum_ZERO);
				return zero_not_successor(C)(successor_ZERO);
			}
			return #<(ZERO, Z)(zero_natural, Z_natural, zero_lt_Z);
		} or {
			return lt_successor(ZERO, Y, Z)(ZERO_lt_Y, successor_Z);
		};
		return #R(Z)(zero_lt_Z);
	}

	result = induction[<N: R(N)>](base_case, inductive_step);
	given |N|;
	assume N_natural;
	return expand(result(N)(N_natural));
}

//Define less than or equal
relation A leq B: A in NATURALS & B in NATURALS & ^C(sum(B, A, C));

prove leq_reflexive: *A(A in NATURALS -> A leq A){
	given |A|;
	assume A_natural;
	return #leq(A, A)(A_natural, A_natural, sum_zero(A)(A_natural));
}

prove lt_alternative: *A*B(A in NATURALS & B in NATURALS -> A < B | B leq A){
	given |A, B|;
	assume A_natural, B_natural;
	return branch(excluded_middle[<: ^C(sum(A, B, C))>], B_leq_A, not_exists){
		return or(<: A < B>, #leq(B, A)(B_natural, A_natural, B_leq_A));
	} or {
		prove none: *C(~sum(A, B, C)){
			given |C|;
			assume sum_C;
			return not_exists(sum_C);
		}
		return or(#<(A, B)(A_natural, B_natural, none), <: B leq A>);
	};
}

prove lt_leq_exclusive: *A*B(~(A < B & B leq A)){
	given |A, B|;
	assume A_lt_B, B_leq_A;
	B_natural, A_natural, exists = expand(B_leq_A);
	A_natural, B_natural, none = expand(A_lt_B);
	sum_C = exists|C|;
	return none(C)(sum_C);
}

prove leq_to_lt_or_eq: *A*B(A leq B -> A = B | A < B){
	define R(A): *B(A leq B -> A = B | A < B);
	prove base_case: *B(ZERO leq B -> ZERO = B | ZERO < B){
		given |B|;
		assume zero_leq_B;
		zero_natural, B_natural, exists = expand(zero_leq_B);
		result = zero_minimal(B)(B_natural);
		return substitute(<Q(): Q | ZERO < B>)[<: B = ZERO>, <: ZERO = B>](equal_symmetric(B, ZERO))(result);
	}
	base_case = #R(ZERO)(base_case);
	prove inductive_step: *N*M(R(N) & successor(M, N) -> R(M)){
		given |N, M|;
		assume R_N, successor_M;
		R_N = expand(R_N);
		prove R_def: *B(M leq B -> M = B | M < B){
			given |B|;
			assume M_leq_B;
			M_natural, B_natural, M_leq_B_def = expand(M_leq_B);
			return branch(excluded_middle[<: B = ZERO>], B_eq_zero, B_not_zero){
				M_leq_zero = replace[<Q: M leq Q>](B, ZERO)(B_eq_zero)(M_leq_B);
				prove zero_not_lt_M: ~ZERO < M{
					assume zero_lt_M;
					return lt_leq_exclusive(ZERO, M)(zero_lt_M, M_leq_zero);
				}
				M_eq_zero = branch(zero_minimal(M)(M_natural), zero_eq_M, zero_lt_M){
					return zero_eq_M;
				} or{
					return trivial(<: false -> M = ZERO>)(zero_not_lt_M(zero_lt_M));
				};
				return or(replace[<Q: M = Q>](B, ZERO)(B_eq_zero)(M_eq_zero), <: M < B>);
			} or {
				A_natural, successor_B = predecessor(B)(B_natural, B_not_zero)|A|;
				implication_N = R_N(A);

			};
		}
	}
}

//less than is transitive: If A < B and B < C, then A < C
prove lt_transitive: *A*B*C(A < B & B < C -> A < C){
	given |A, B, C|;
	assume A_lt_B, B_lt_C;
	A_natural, B_natural, A_lt_B = expand(A_lt_B);
	B_natural, C_natural, B_lt_C = expand(B_lt_C);

	prove A_lt_C: *D(~sum(C, D, A)){
		given |D|;
		assume sum_C;
	}
}

