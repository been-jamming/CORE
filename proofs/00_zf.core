//A few logical axioms first
axiom axiom_absurdity[P]: false -> P;
axiom axiom_true: true;
axiom axiom_excluded_middle[P]: P | ~P;

//ZF in CORE (biconditional revision)

define equal_sets(A, B): *X(X in A <-> X in B);
define is_subset(A, B): *X(X in A -> X in B);
define non_empty(A): ^X(X in A);
define is_empty(A): *X(~X in A);

axiom equality_consistency[P(1)]: *X*Y(equal_sets(X, Y) -> (P(X) <-> P(Y)));

prove equal_sets_reflexive: *A(equal_sets(A, A)){
	given |A|;
	prove equal_sets_def: *X(X in A <-> X in A){
		given |X|;
		prove lemma: X in A -> X in A{
			implies X_in_A;
			return X_in_A;
		}
		return iff(lemma, lemma);
	}
	return #equal_sets(A, A)(equal_sets_def);
}

prove equal_sets_symmetric: *A*B(equal_sets(A, B) -> equal_sets(B, A)){
	given |A, B|;
	implies equal_AB;
	prove def: *X(X in B <-> X in A){
		given |X|;
		return expand(equal_AB)(X);
	}
	return #equal_sets(B, A)(def);
}

prove equal_sets_transitive: *A*B*C(equal_sets(A, B) & equal_sets(B, C) -> equal_sets(A, C)){
	given |A, B, C|;
	implies equals_both;
	extract equals_both: equal_AB, equal_BC;
	return equality_consistency[<X: equal_sets(X, C)>](B, A)(equal_sets_symmetric(A, B)(equal_AB))(equal_BC);
}

prove axiom_extensionality: *A*B(equal_sets(A, B) -> *W(A in W <-> B in W)){
	given |A, B|;
	implies equal_AB;
	given |W|;
	return equality_consistency[<X: X in W>](A, B)(equal_AB);
}

axiom axiom_regularity: *A(non_empty(A) -> ^B(B in A & *C(~C in B | ~C in A)));

axiom axiom_specify[P(1)]: *A^B*X(X in B <-> X in A & P(X));

axiom axiom_pairing: *A*B^C(A in C & B in C);

axiom axiom_union: *F^A*Y*X((Y in F & X in Y) -> X in A);

axiom axiom_replacement[P(3)]: *A(*X(X in A -> ^Y(P(X, Y, A) & *Z(P(X, Z, A) -> equal_sets(Y, Z)))) -> ^B*Y((Y in B -> ^X(X in A & P(X, Y, A))) & (^X(X in A & P(X, Y, A)) -> Y in B)));

define is_pair(A, B, C): *X(X in C <-> equal_sets(X, A) | equal_sets(X, B));

prove definition_uniqueness_lemma[P(1)]: *A*B(*X(X in A <-> P(X)) & *X(X in B <-> P(X)) -> equal_sets(A, B)){
	given |A, B|;
	implies equality_condition;
	extract equality_condition: membership_A, membership_B;
	prove equal_def: *X(X in A <-> X in B){
		given |X|;
		prove lemma0: X in A -> X in B{
			implies X_in_A;
			return membership_B(X)(membership_A(X)(X_in_A));
		}
		prove lemma1: X in B -> X in A{
			implies X_in_B;
			return membership_A(X)(membership_B(X)(X_in_B));
		}
		return iff(lemma0, lemma1);
	}
	return #equal_sets(A, B)(equal_def);
}

prove pair: *A*B^C(is_pair(A, B, C)){
	given |A, B|;
	extract axiom_pairing(A, B)|D|: A_in_D, B_in_D;
	C_specified = axiom_specify[<X: equal_sets(X, A) | equal_sets(X, B)>](D)|C|;
	choose C;
	prove pair_def: *X(X in C <-> equal_sets(X, A) | equal_sets(X, B)){
		given |X|;
		prove lemma0: X in C -> equal_sets(X, A) | equal_sets(X, B){
			implies X_in_C;
			extract C_specified(X)(X_in_C): X_in_D, result;
			return result;
		}
		prove lemma1: equal_sets(X, A) | equal_sets(X, B) -> X in C{
			implies equals_or;
			X_in_D = branch(equals_or, equal_XA, equal_XB){
				return equality_consistency[<Z: Z in D>](X, A)(equal_XA)(A_in_D);
			} or {
				return equality_consistency[<Z: Z in D>](X, B)(equal_XB)(B_in_D);
			};
			return C_specified(X)(and(X_in_D, equals_or));
		}
		return iff(lemma0, lemma1);
	}
	return #is_pair(A, B, C)(pair_def);
}

prove pair_unique: *A*B*C*D(is_pair(A, B, C) & is_pair(A, B, D) -> equal_sets(C, D)){
	given |A, B, C, D|;
	implies pairs_premise;
	extract pairs_premise: pair_C, pair_D;
	return definition_uniqueness_lemma[<X: equal_sets(X, A) | equal_sets(X, B)>](C, D)(and(expand(pair_C), expand(pair_D)));
}

define is_union(A, B): *X(X in B <-> ^Y(Y in A & X in Y));

prove union: *A^B(is_union(A, B)){
	given |A|;
	implies_in_NEW = axiom_union(A)|NEW|;
	specified = axiom_specify[<X: ^Y(Y in A & X in Y)>](NEW)|B|;
	choose B;
	prove union_def: *X(X in B <-> ^Y(Y in A & X in Y)){
		given |X|;
		prove lemma0: X in B -> ^Y(Y in A & X in Y){
			implies X_in_B;
			extract specified(X)(X_in_B): X_in_NEW, result;
			return result;
		}
		prove lemma1: ^Y(Y in A & X in Y) -> X in B{
			implies exists_condition;
			condition_Y = exists_condition|Y|;
			X_in_NEW = implies_in_NEW(Y, X)(condition_Y);
			return specified(X)(and(X_in_NEW, exists_condition));
		}
		return iff(lemma0, lemma1);
	}
	return #is_union(A, B)(union_def);
}

prove union_unique: *A*B*C(is_union(A, B) & is_union(A, C) -> equal_sets(B, C)){
	given |A, B, C|;
	implies union_both;
	extract union_both: union_B, union_C;
	return definition_uniqueness_lemma[<X: ^Y(Y in A & X in Y)>](B, C)(and(expand(union_B), expand(union_C)));
}

define is_successor(A, B): ^C^D(is_pair(A, A, C) & is_pair(A, C, D) & is_union(D, B));

prove successor_exists: *A^B(is_successor(A, B)){
	given |A|;
	pair_AA = pair(A, A)|C|;
	pair_AC = pair(A, C)|D|;
	union_B = union(D)|B|;
	choose B;
	prove successor_def: ^C^D(is_pair(A, A, C) & is_pair(A, C, D) & is_union(D, B)){
		choose C, D;
		return and(pair_AA, pair_AC, union_B);
	}
	return #is_successor(A, B)(successor_def);
}

prove successor_unique: *A*B*C(is_successor(A, B) & is_successor(A, C) -> equal_sets(B, C)){
	given |A, B, C|;
	implies successor_both;
	extract successor_both: successor_B, successor_C;
	extract expand(successor_B)|PAIR0_B, PAIR1_B|: PAIR0_B_condition, PAIR1_B_condition, union_B;
	extract expand(successor_C)|PAIR0_C, PAIR1_C|: PAIR0_C_condition, PAIR1_C_condition, union_C;
	PAIR0_equal = pair_unique(A, A, PAIR0_B, PAIR0_C)(and(PAIR0_B_condition, PAIR0_C_condition));
	PAIR1_B_other = equality_consistency[<X: is_pair(A, X, PAIR1_B)>](PAIR0_B, PAIR0_C)(PAIR0_equal)(PAIR1_B_condition);
	PAIR1_equal = pair_unique(A, PAIR0_C, PAIR1_B, PAIR1_C)(and(PAIR1_B_other, PAIR1_C_condition));
	union_B_other = equality_consistency[<X: is_union(X, B)>](PAIR1_B, PAIR1_C)(PAIR1_equal)(union_B);
	return union_unique(PAIR1_C, B, C)(and(union_B_other, union_C));
}

define is_inductive_set(X): ^E(E in X & is_empty(E)) & *Y*Z(Y in X & is_successor(Y, Z) -> Z in X);

axiom axiom_infinity: ^X(is_inductive_set(X));

axiom axiom_power_set: *X^Y*Z(is_subset(Z, X) -> Z in Y);

//These are all of the ZF axioms

define is_power_set(A, B): *X(X in B <-> is_subset(X, A));

prove power_set: *A^B(is_power_set(A, B)){
	given |A|;
	contains_subsets = axiom_power_set(A)|B_BIG|;
	restricted = axiom_specify[<X: is_subset(X, A)>](B_BIG)|B|;
	choose B;
	prove power_set_def: *X(X in B <-> is_subset(X, A)){
		given |X|;
		prove lemma0: X in B -> is_subset(X, A){
			implies X_in_B;
			extract restricted(X)(X_in_B): X_in_B_BIG, result;
			return result;
		}
		prove lemma1: is_subset(X, A) -> X in B{
			implies X_subset_A;
			X_in_B_BIG = contains_subsets(X)(X_subset_A);
			return restricted(X)(and(X_in_B_BIG, X_subset_A));
		}
		return iff(lemma0, lemma1);
	}
	return #is_power_set(A, B)(power_set_def);
}

prove power_set_unique: *A*B*C(is_power_set(A, B) & is_power_set(A, C) -> equal_sets(B, C)){
	given |A, B, C|;
	implies both_power_set;
	extract both_power_set: power_set_B, power_set_C;
	return definition_uniqueness_lemma[<X: is_subset(X, A)>](B, C)(and(expand(power_set_B), expand(power_set_C)));
}

prove empty_set_exists: ^E*X(~X in E){
	inductive = expand(axiom_infinity|INDUCTIVE_SET|);
	extract inductive: exists, closure;
	extract exists|EMPTY|: member, empty;
	choose EMPTY;
	return expand(empty);
}

prove empty_set_unique: *E*F(is_empty(E) & is_empty(F) -> equal_sets(E, F)){
	given |E, F|;
	implies both_empty;
	extract both_empty: empty_E, empty_F;
	empty_E = expand(empty_E);
	empty_F = expand(empty_F);
	prove equal_def: *X(X in E <-> X in F){
		given |X|;
		prove lemma0: X in E -> X in F{
			implies X_in_E;
			return axiom_absurdity[<:X in F>](empty_E(X)(X_in_E));
		}
		prove lemma1: X in F -> X in E{
			implies X_in_F;
			return axiom_absurdity[<:X in E>](empty_F(X)(X_in_F));
		}
		return iff(lemma0, lemma1);
	}
	return #equal_sets(E, F)(equal_def);
}

empty_set_condition = empty_set_exists|EMPTY_SET|;

define is_natural_numbers(N): *X(X in N <-> *I(is_inductive_set(I) -> X in I));

prove natural_numbers_exist: ^N(is_natural_numbers(N)){
	is_inductive = axiom_infinity|INDUCTIVE_SET|;
	specified = axiom_specify[<X: *I(is_inductive_set(I) -> X in I)>](INDUCTIVE_SET)|N|;
	choose N;
	prove natural_numbers_def: *X(X in N <-> *I(is_inductive_set(I) -> X in I)){
		given |X|;
		prove lemma0: X in N -> *I(is_inductive_set(I) -> X in I){
			implies X_in_N;
			extract specified(X)(X_in_N): X_in_INDUCTIVE_SET, result;
			return result;
		}
		prove lemma1: *I(is_inductive_set(I) -> X in I) -> X in N{
			implies in_all_inductive;
			X_in_INDUCTIVE_SET = in_all_inductive(INDUCTIVE_SET)(is_inductive);
			return specified(X)(and(X_in_INDUCTIVE_SET, in_all_inductive));
		}
		return iff(lemma0, lemma1);
	}
	return #is_natural_numbers(N)(natural_numbers_def);
}

prove natural_numbers_unique: *N*M(is_natural_numbers(N) & is_natural_numbers(M) -> equal_sets(N, M)){
	given |N, M|;
	implies both_natural_numbers;
	extract both_natural_numbers: natural_numbers_N, natural_numbers_M;
	return definition_uniqueness_lemma[<X: *I(is_inductive_set(I) -> X in I)>](N, M)(and(expand(natural_numbers_N), expand(natural_numbers_M)));
}

naturals_definition = expand(natural_numbers_exist|NATURALS|);

prove NATURALS_inductive: is_inductive_set(NATURALS){
	prove lemma0: ^E(E in NATURALS & is_empty(E)){
		choose EMPTY_SET;
		empty = #is_empty(EMPTY_SET)(empty_set_condition);
		prove lemma: *I(is_inductive_set(I) -> EMPTY_SET in I){
			given |I|;
			implies is_inductive;
			extract expand(is_inductive): empty_condition, closure;
			extract empty_condition|EMPTY_OTHER|: empty_in, is_empty_other;
			empty_equal = empty_set_unique(EMPTY_OTHER, EMPTY_SET)(and(is_empty_other, empty));
			return equality_consistency[<X: X in I>](EMPTY_OTHER, EMPTY_SET)(empty_equal)(empty_in);
		}
		return and(naturals_definition(EMPTY_SET)(lemma), empty);
	}
	prove lemma1: *Y*Z(Y in NATURALS & is_successor(Y, Z) -> Z in NATURALS){
		given |Y, Z|;
		implies both;
		extract both: Y_in_NATURALS, Z_successor;
		prove lemma: *I(is_inductive_set(I) -> Z in I){
			given |I|;
			implies is_inductive;
			extract expand(is_inductive): empty_condition, closure;
			Y_in_I = naturals_definition(Y)(Y_in_NATURALS)(I)(is_inductive);
			return closure(Y, Z)(and(Y_in_I, Z_successor));
		}
		return naturals_definition(Z)(lemma);
	}
	return #is_inductive_set(NATURALS)(and(lemma0, lemma1));
}

prove NATURALS_induction: *S(EMPTY_SET in S & *Y*Z(Y in S & is_successor(Y, Z) -> Z in S) -> is_subset(NATURALS, S)){
	given |S|;
	implies premise;
	extract premise: EMPTY_SET_in_S, closure;
	prove lemma: ^E(E in S & is_empty(E)){
		choose EMPTY_SET;
		return and(EMPTY_SET_in_S, #is_empty(EMPTY_SET)(empty_set_condition));
	}
	inductive_S = #is_inductive_set(S)(and(lemma, closure));
	prove subset_def: *X(X in NATURALS -> X in S){
		given |X|;
		implies X_in_NATURALS;
		return naturals_definition(X)(X_in_NATURALS)(S)(inductive_S);
	}
	return #is_subset(NATURALS, S)(subset_def);
}

