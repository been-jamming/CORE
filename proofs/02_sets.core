//This file is for some basic set theory definitions and results

//For proving definitions are unique
prove definition_uniqueness_lemma[P(1)]: *A*B(*X((X in A -> P(X)) & (P(X) -> X in A)) & *X((X in B -> P(X)) & (P(X) -> X in B)) -> equal_sets(A, B)){
	given A{
		given B{
			implies both{
				prove def: *X((X in A -> X in B) & (X in B -> X in A)){
					given X{
						prove lemma0: X in A -> X in B{
							implies X_in_A{
								return right(right(both)(X))(left(left(both)(X))(X_in_A));
							}
						}
						prove lemma1: X in B -> X in A{
							implies X_in_B{
								return right(left(both)(X))(left(right(both)(X))(X_in_B));
							}
						}
						return and(lemma0, lemma1);
					}
				}
				return #equal_sets(A)(B)(def);
			}
		}
	}
}

//Induction lemma for the natural numbers
prove induction_lemma: *Q((EMPTY_SET in Q & *X*Y(X in Q & is_successor(X, Y) -> Y in Q)) -> is_subset(NATURALS, Q)){
	given Q{
		implies both{
			prove lemma: ^S(S in Q & is_empty(S)){
				choose EMPTY_SET{
					return and(left(both), #is_empty(EMPTY_SET)(empty_set_condition));
				}
			}
			inductive = #is_inductive_set(Q)(and(lemma, right(both)));
			prove def: *X(X in NATURALS -> X in Q){
				given X{
					implies X_in_NAT{
						return left(naturals_definition(X))(X_in_NAT)(Q)(inductive);
					}
				}
			}
			return #is_subset(NATURALS)(Q)(def);
		}
	}
}

//The defining property of pairs. This will be used to prove the defining property of tuples.
prove pair_equal_condition: *A*B*C*D*E*F(is_pair(A, B, E) & is_pair(C, D, F) & equal_sets(E, F) -> equal_sets(A, C) | equal_sets(A, D)){
	given A{
		given B{
			given C{
				given D{
					given E{
						given F{
							implies p{
								pair_AB = is_pair#(A, B, E)(left(p));
								pair_CD = is_pair#(C, D, F)(left(right(p)));
								equal_EF = equal_sets#(E, F)(right(right(p)));
								A_equal_A = equal_sets_reflexive(A);
								define A_equal_B: equal_sets(A, B);
								A_in_E = right(pair_AB(A))(or(A_equal_A, (A_equal_B)));
								A_in_F = left(equal_EF(A))(A_in_E);
								return left(pair_CD(A))(A_in_F);
							}
						}
					}
				}
			}
		}
	}
}

//Swapping elements of pair still gives the same pair
prove pair_swap_equal: *A*B*C(is_pair(A, B, C) -> is_pair(B, A, C)){
	given A{
		given B{
			given C{
				implies pair0{
					pair0_def = is_pair#(A)(B)(C)(pair0);
					prove pair1_def: *X((X in C -> equal_sets(X, B) | equal_sets(X, A)) & (equal_sets(X, B) | equal_sets(X, A) -> X in C)){
						given X{
							prove lemma0: X in C -> equal_sets(X, B) | equal_sets(X, A){
								implies p{
									return swap(left(pair0_def(X))(p));
								}
							}
							prove lemma1: equal_sets(X, B) | equal_sets(X, A) -> X in C{
								implies p{
									return right(pair0_def(X))(swap(p));
								}
							}
							return and(lemma0, lemma1);
						}
					}
					return #is_pair(B)(A)(C)(pair1_def);
				}
			}
		}
	}
}

//Pairs are subsets of the set that the elements came from
prove pair_subset: *A*B*C*D(B in A & C in A & is_pair(B, C, D) -> is_subset(D, A)){
	given A{
		given B{
			given C{
				given D{
					implies p{
						pair_def = is_pair#(B)(C)(D)(right(right(p)));
						prove def: *X(X in D -> X in A){
							given X{
								implies X_in_D{
									equal_B_or_C = left(pair_def(X))(X_in_D);
									define in_A(Y): Y in A;
									return branch(equal_B_or_C, equal_B, equal_C){
										return right(axiom_extensionality(X, B)(equal_B)(A))(left(p));
									} or {
										return right(axiom_extensionality(X, C)(equal_C)(A))(left(right(p)));
									};
								}
							}
						}
						return #is_subset(D)(A)(def);
					}
				}
			}
		}
	}
}

//Now in order to define relations, we have to define tuples (A, B)
//I will use the standard definition that (A, B) = {{A}, {A, B}}
define is_tuple(A, B, C): ^D^E(is_pair(A, A, D) & is_pair(A, B, E) & is_pair(D, E, C));

//tuples exists
prove tuple_exists: *A*B^C(is_tuple(A, B, C)){
	given A{
		given B{
			pair_AA = pair_exists(A)(A)(D);
			pair_AB = pair_exists(A)(B)(E);
			pair_DE = pair_exists(D)(E)(C);
			choose C{
				prove def: ^D^E(is_pair(A, A, D) & is_pair(A, B, E) & is_pair(D, E, C)){
					choose D{
						choose E{
							return and(pair_AA, pair_AB, pair_DE);
						}
					}
				}
				return #is_tuple(A)(B)(C)(def);
			}
		}
	}
}

//tuples are unique
prove tuple_unique: *A*B*C*D(is_tuple(A, B, C) & is_tuple(A, B, D) -> equal_sets(C, D)){
	given A{
		given B{
			given C{
				given D{
					implies both{
						C_tuple = is_tuple#(A)(B)(C)(left(both))(AA_pairC)(AB_pairC);
						D_tuple = is_tuple#(A)(B)(D)(right(both))(AA_pairD)(AB_pairD);
						AA_pairC_equal_AA_pairD = pair_unique(A)(A)(AA_pairC)(AA_pairD)(and(left(C_tuple), left(D_tuple)));
						AB_pairC_equal_AB_pairD = pair_unique(A)(B)(AB_pairC)(AB_pairD)(and(left(right(C_tuple)), left(right(D_tuple))));
						define pair(X): is_pair(X, AB_pairC, C);
						intermediate_pair = equality_consistency[(pair)](AA_pairC)(AA_pairD)(and(AA_pairC_equal_AA_pairD, right(right(C_tuple))));
						define pair(X): is_pair(AA_pairD, X, C);
						intermediate_pair = equality_consistency[(pair)](AB_pairC)(AB_pairD)(and(AB_pairC_equal_AB_pairD, intermediate_pair));
						return pair_unique(AA_pairD)(AB_pairD)(C)(D)(and(intermediate_pair, right(right(D_tuple))));
					}
				}
			}
		}
	}
}
//So tuples (ordered pairs) are well defined
//Why are they called ordered pairs? Because of this:

//Defining property of tuples
prove tuple_equal_condition: *A*B*C*D*E*F(is_tuple(A, B, E) & is_tuple(C, D, F) & equal_sets(E, F) -> equal_sets(A, C) & equal_sets(B, D)){
	given A{
		given B{
			given C{
				given D{
					given E{
						given F{
							implies p{
								AB_tuple_condition = is_tuple#(A)(B)(E)(left(p))(AA_pair)(AB_pair);
								CD_tuple_condition = is_tuple#(C)(D)(F)(left(right(p)))(CC_pair)(CD_pair);
								AA_CC_or_AA_CD = pair_equal_condition(AA_pair)(AB_pair)(CC_pair)(CD_pair)(E)(F)(and(right(right(AB_tuple_condition)), right(right(CD_tuple_condition)), right(right(p))));
								AC_or_AD = branch(AA_CC_or_AA_CD, AA_CC, AA_CD){
									AC_or_AC = pair_equal_condition(A)(A)(C)(C)(AA_pair)(CC_pair)(and(left(AB_tuple_condition), left(CD_tuple_condition), AA_CC));
									define AC: equal_sets(A, C);
									define AD: equal_sets(A, D);
									return or(or_combine[(AC)](AC_or_AC), (AD));
								} or {
									return pair_equal_condition(A)(A)(C)(D)(AA_pair)(CD_pair)(and(left(AB_tuple_condition), left(right(CD_tuple_condition)), AA_CD));
								};
								is_swap_tuple = pair_swap_equal(AA_pair)(AB_pair)(E)(right(right(AB_tuple_condition)));
								AB_CC_or_AB_CD = pair_equal_condition(AB_pair)(AA_pair)(CC_pair)(CD_pair)(E)(F)(and(is_swap_tuple, right(right(CD_tuple_condition)), right(right(p))));
								BA_condition = pair_swap_equal(A)(B)(AB_pair)(left(right(AB_tuple_condition)));
								BC_or_BD = branch(AB_CC_or_AB_CD, AB_CC, AB_CD){
									BC_or_BC = pair_equal_condition(B)(A)(C)(C)(AB_pair)(CC_pair)(and(BA_condition, left(CD_tuple_condition), AB_CC));
									define BC: equal_sets(B, C);
									define BD: equal_sets(B, D);
									return or(or_combine[(BC)](BC_or_BC), (BD));
								} or {
									return pair_equal_condition(B)(A)(C)(D)(AB_pair)(CD_pair)(and(BA_condition, left(right(CD_tuple_condition)), AB_CD));
								};

								FE = equal_sets_symmetric(E)(F)(right(right(p)));
								CC_AA_or_CC_AB = pair_equal_condition(CC_pair)(CD_pair)(AA_pair)(AB_pair)(F)(E)(and(right(right(CD_tuple_condition)), right(right(AB_tuple_condition)), FE));
								CA_or_CB = branch(CC_AA_or_CC_AB, CC_AA, CC_AB){
									CA_or_CA = pair_equal_condition(C)(C)(A)(A)(CC_pair)(AA_pair)(and(left(CD_tuple_condition), left(AB_tuple_condition), CC_AA));
									define CA: equal_sets(C, A);
									define CB: equal_sets(C, B);
									return or(or_combine[(CA)](CA_or_CA), (CB));
								} or {
									return pair_equal_condition(C)(C)(A)(B)(CC_pair)(AB_pair)(and(left(CD_tuple_condition), left(right(AB_tuple_condition)), CC_AB));
								};
								
								is_swap_tuple = pair_swap_equal(CC_pair)(CD_pair)(F)(right(right(CD_tuple_condition)));
								CD_AA_or_CD_AB = pair_equal_condition(CD_pair)(CC_pair)(AA_pair)(AB_pair)(F)(E)(and(is_swap_tuple, right(right(AB_tuple_condition)), FE));
								DC_condition = pair_swap_equal(C)(D)(CD_pair)(left(right(CD_tuple_condition)));
								DA_or_DB = branch(CD_AA_or_CD_AB, CD_AA, CD_AB){
									DA_or_DA = pair_equal_condition(D)(C)(A)(A)(CD_pair)(AA_pair)(and(DC_condition, left(AB_tuple_condition), CD_AA));
									define DA: equal_sets(D, A);
									define DB: equal_sets(D, B);
									return or(or_combine[(DA)](DA_or_DA), (DB));
								} or {
									return pair_equal_condition(D)(C)(A)(B)(CD_pair)(AB_pair)(and(DC_condition, left(right(AB_tuple_condition)), CD_AB));
								};

								//Now we split into 4 cases
								return branch(AC_or_AD, AC, AD){
									return branch(BC_or_BD, BC, BD){
										AB = equal_sets_transitive(A)(C)(B)(and(AC, equal_sets_symmetric(B)(C)(BC)));
										return branch(DA_or_DB, DA, DB){
											DB = equal_sets_transitive(D)(A)(B)(and(DA, AB));
											return and(AC, equal_sets_symmetric(D)(B)(DB));
										} or {
											return and(AC, equal_sets_symmetric(D)(B)(DB));
										};
									} or {
										return and(AC, BD);
									};
								} or {
									return branch(BC_or_BD, BC, BD){
										//The critical case
										define XX_pair_condition(X): is_pair(X, X, AA_pair);
										DD_pair_condition = equality_consistency[(XX_pair_condition)](A)(D)(and(AD, left(AB_tuple_condition)));
										CD = branch(AA_CC_or_AA_CD, AA_CC, AA_CD){
											CD_or_CD = pair_equal_condition(C)(C)(D)(D)(CC_pair)(AA_pair)(and(left(CD_tuple_condition), DD_pair_condition, equal_sets_symmetric(AA_pair)(CC_pair)(AA_CC)));
											define CD: equal_sets(C, D);
											return or_combine[(CD)](CD_or_CD);
										} or {
											CD_or_CD = pair_equal_condition(C)(D)(D)(D)(CD_pair)(AA_pair)(and(left(right(CD_tuple_condition)), DD_pair_condition, equal_sets_symmetric(AA_pair)(CD_pair)(AA_CD)));
											define CD: equal_sets(C, D);
											return or_combine[(CD)](CD_or_CD);
										};
										AC = equal_sets_transitive(A)(D)(C)(and(AD, equal_sets_symmetric(C)(D)(CD)));
										BD = equal_sets_transitive(B)(C)(D)(and(BC, CD));
										return and(AC, BD);
									} or {
										AB = equal_sets_transitive(A)(D)(B)(and(AD, equal_sets_symmetric(B)(D)(BD)));
										return branch(CA_or_CB, CA, CB){
											return and(equal_sets_symmetric(C)(A)(CA), BD);
										} or {
											CA = equal_sets_transitive(C)(B)(A)(and(CB, equal_sets_symmetric(A)(B)(AB)));
											return and(equal_sets_symmetric(C)(A)(CA), BD);
										};
									};
								};
							}
						}
					}
				}
			}
		}
	}
}

//We want a set which contains exactly the pairs of members from a single set
prove all_pairs_exists: *A^B*C((C in B -> ^D^E(D in A & E in A & is_pair(D, E, C))) & (^D^E(D in A & E in A & is_pair(D, E, C)) -> C in B)){
	given A{
		power_set = power_set_exists(A)(P_A);
		power_set = is_power_set#(A)(P_A)(power_set);
		define pair_condition(X): ^D^E(D in A & E in A & is_pair(D, E, X));
		restrict = axiom_specify[(pair_condition)](P_A)(B);
		choose B{
			given C{
				prove lemma0: C in B -> ^D^E(D in A & E in A & is_pair(D, E, C)){
					implies C_in_B{
						return right(left(restrict(C))(C_in_B));
					}
				}
				prove lemma1: ^D^E(D in A & E in A & is_pair(D, E, C)) -> C in B{
					implies pair_statement{
						all = pair_statement(D)(E);
						C_subset_A = pair_subset(A)(D)(E)(C)(all);
						C_in_P_A = right(power_set(C))(C_subset_A);
						return right(restrict(C))(and(C_in_P_A, pair_statement));
					}
				}
				return and(lemma0, lemma1);
			}
		}
	}
}

//Defining the two union of sets
define is_two_union(A, B, C): *X((X in C -> X in A | X in B) & (X in A | X in B -> X in C));

prove two_union: *A*B^C(is_two_union(A, B, C)){
	given A{
		given B{
			pair_AB = pair_exists(A)(B)(AB);
			pair_AB = is_pair#(A)(B)(AB)(pair_AB);
			union_AB = union_exists(AB)(C);
			union_AB = is_union#(AB)(C)(union_AB);
			choose C{
				prove def: *X((X in C -> X in A | X in B) & (X in A | X in B -> X in C)){
					given X{
						prove lemma0: X in C -> X in A | X in B{
							implies X_in_C{
								X_in_union = right(union_AB(X))(X_in_C)(L);
								X_in_L = left(X_in_union);
								equal_A_or_equal_B = left(pair_AB(L))(right(X_in_union));
								return branch(equal_A_or_equal_B, equal_A, equal_B){
									define X_in_B: X in B;
									return or(left(equal_sets#(L)(A)(equal_A)(X))(X_in_L), (X_in_B));
								} or {
									define X_in_A: X in A;
									return swap(or(left(equal_sets#(L)(B)(equal_B)(X))(X_in_L), (X_in_A)));
								};
							}
						}
						prove lemma1: X in A | X in B -> X in C{
							implies X_in_A_or_X_in_B{
								return branch(X_in_A_or_X_in_B, X_in_A, X_in_B){
									define A_equal_B: equal_sets(A, B);
									A_equal_A = equal_sets_reflexive(A);
									A_in_AB = right(pair_AB(A))(or(A_equal_A, (A_equal_B)));
									prove part: ^A(X in A & A in AB){
										choose A{
											return and(X_in_A, A_in_AB);
										}
									}
									return left(union_AB(X))(part);
								} or {
									define B_equal_A: equal_sets(B, A);
									B_equal_B = equal_sets_reflexive(B);
									B_in_AB = right(pair_AB(B))(swap(or(B_equal_B, (B_equal_A))));
									prove part: ^B(X in B & B in AB){
										choose B{
											return and(X_in_B, B_in_AB);
										}
									}
									return left(union_AB(X))(part);
								};
							}
						}
						return and(lemma0, lemma1);
					}
				}
				return #is_two_union(A)(B)(C)(def);
			}
		}
	}
}

prove two_union_unique: *A*B*C*D(is_two_union(A, B, C) & is_two_union(A, B, D) -> equal_sets(C, D)){
	given A{
		given B{
			given C{
				given D{
					implies both{
						C_two = is_two_union#(A)(B)(C)(left(both));
						D_two = is_two_union#(A)(B)(D)(right(both));
						prove def: *X((X in C -> X in D) & (X in D -> X in C)){
							given X{
								prove lemma0: X in C -> X in D{
									implies X_in_C{
										return right(D_two(X))(left(C_two(X))(X_in_C));
									}
								}
								prove lemma1: X in D -> X in C{
									implies X_in_D{
										return right(C_two(X))(left(D_two(X))(X_in_D));
									}
								}
								return and(lemma0, lemma1);
							}
						}
						return #equal_sets(C)(D)(def);
					}
				}
			}
		}
	}
}

//Now we can finaly prove that the cross product between two sets exists. C is AxB in the following definition:
define is_cross_product(A, B, C): *X((X in C -> ^Y^Z(Y in A & Z in B & is_tuple(Y, Z, X))) & (^Y^Z(Y in A & Z in B & is_tuple(Y, Z, X)) -> X in C));

prove cross_product: *A*B^C(is_cross_product(A, B, C)){
	given A{
		given B{
			AB_union = two_union(A)(B)(AB);
			AB_union = is_two_union#(A)(B)(AB)(AB_union);
			all_pairs_AB = all_pairs_exists(AB)(pairs_AB);
			next_all_pairs = all_pairs_exists(pairs_AB)(C_BIG);
			define restrict_condition(X): ^Y^Z(Y in A & Z in B & is_tuple(Y, Z, X));
			restrict = axiom_specify[(restrict_condition)](C_BIG)(C);
			choose C{
				prove def: *X((X in C -> ^Y^Z(Y in A & Z in B & is_tuple(Y, Z, X))) & (^Y^Z(Y in A & Z in B & is_tuple(Y, Z, X)) -> X in C)){
					given X{
						prove lemma0: X in C -> ^Y^Z(Y in A & Z in B & is_tuple(Y, Z, X)){
							implies X_in_C{
								return right(left(restrict(X))(X_in_C));
							}
						}
						prove lemma1: ^Y^Z(Y in A & Z in B & is_tuple(Y, Z, X)) -> X in C{
							implies Y_Z_exist{
								all = Y_Z_exist(Y)(Z);
								tuple_YZ = is_tuple#(Y)(Z)(X)(right(right(all)));
								pairs = tuple_YZ(YY)(YZ);
								define Y_in_B: Y in B;
								define Z_in_A: Z in A;
								Y_in_AB = right(AB_union(Y))(or(left(all), (Y_in_B)));
								Z_in_AB = right(AB_union(Z))(swap(or(left(right(all)), (Z_in_A))));
								prove pairs_AB_lemma0: ^Y^Z(Y in AB & Z in AB & is_pair(Y, Z, YY)){
									choose Y{
										choose Y{
											return and(Y_in_AB, Y_in_AB, left(pairs));
										}
									}
								}
								prove pairs_AB_lemma1: ^Y^Z(Y in AB & Z in AB & is_pair(Y, Z, YZ)){
									choose Y{
										choose Z{
											return and(Y_in_AB, Z_in_AB, left(right(pairs)));
										}
									}
								}
								YY_in_pairs_AB = right(all_pairs_AB(YY))(pairs_AB_lemma0);
								YZ_in_pairs_AB = right(all_pairs_AB(YZ))(pairs_AB_lemma1);
								prove pairs_pairs_lemma: ^YY^YZ(YY in pairs_AB & YZ in pairs_AB & is_pair(YY, YZ, X)){
									choose YY{
										choose YZ{
											return and(YY_in_pairs_AB, YZ_in_pairs_AB, right(right(pairs)));
										}
									}
								}
								X_in_C_BIG = right(next_all_pairs(X))(pairs_pairs_lemma);
								return right(restrict(X))(and(X_in_C_BIG, Y_Z_exist));
							}
						}
						return and(lemma0, lemma1);
					}
				}
				return #is_cross_product(A)(B)(C)(def);
			}
		}
	}
}

//Prove (easily) that cross products are unique
prove cross_product_unique: *A*B*C*D(is_cross_product(A, B, C) & is_cross_product(A, B, D) -> equal_sets(C, D)){
	given A{
		given B{
			given C{
				given D{
					implies both{
						C_def = is_cross_product#(A)(B)(C)(left(both));
						D_def = is_cross_product#(A)(B)(D)(right(both));
						prove def: *X((X in C -> X in D) & (X in D -> X in C)){
							given X{
								prove lemma0: X in C -> X in D{
									implies X_in_C{
										return right(D_def(X))(left(C_def(X))(X_in_C));
									}
								}
								prove lemma1: X in D -> X in C{
									implies X_in_D{
										return right(C_def(X))(left(D_def(X))(X_in_D));
									}
								}
								return and(lemma0, lemma1);
							}
						}
						return #equal_sets(C)(D)(def);
					}
				}
			}
		}
	}
}

//We haven't constructed intersections yet. We should do that now...
define is_intersection(A, B): *X((*Y(Y in A -> X in Y) -> X in B) & (X in B -> *Y(Y in A -> X in Y)));

//Intersections exist
//In order to construct the intersection, we need to know that it sits inside of some other set
//That we can construct. Luckily, the intersection is always a subset of the union (when the union
//Is not empty). For empty sets, it's impossible to define the intersection.
prove intersection: *A(non_empty(A) -> ^B(is_intersection(A, B))){
	given A{
		implies non_empty_A{
			non_empty_A = non_empty#(A)(non_empty_A);
			union_A = union_exists(A)(UNION);
			union_A = is_union#(A)(UNION)(union_A);
			define restrict_condition(X): *Y(Y in A -> X in Y);
			restricted = axiom_specify[(restrict_condition)](UNION)(INTERSECTION);
			choose INTERSECTION{
				prove def: *X((*Y(Y in A -> X in Y) -> X in INTERSECTION) & (X in INTERSECTION -> *Y(Y in A -> X in Y))){
					given X{
						prove lemma0: *Y(Y in A -> X in Y) -> X in INTERSECTION{
							implies all_Y{
								R_in_A = non_empty_A(R);
								X_in_R = all_Y(R)(R_in_A);
								prove exists: ^R(X in R & R in A){
									choose R{
										return and(X_in_R, R_in_A);
									}
								}
								X_in_UNION = left(union_A(X))(exists);
								return right(restricted(X))(and(X_in_UNION, all_Y));
							}
						}
						prove lemma1: X in INTERSECTION -> *Y(Y in A -> X in Y){
							implies X_in_INTERSECTION{
								return right(left(restricted(X))(X_in_INTERSECTION));
							}
						}
						return and(lemma0, lemma1);
					}
				}
				return #is_intersection(A)(INTERSECTION)(def);
			}
		}
	}
}

//Intersections are unique
prove intersection_unique: *A*B*C(is_intersection(A, B) & is_intersection(A, C) -> equal_sets(B, C)){
	given A{
		given B{
			given C{
				implies intersections{
					intersection_AB = is_intersection#(A)(B)(left(intersections));
					intersection_AC = is_intersection#(A)(C)(right(intersections));
					prove def: *X((X in B -> X in C) & (X in C -> X in B)){
						given X{
							prove lemma0: X in B -> X in C{
								implies X_in_B{
									return left(intersection_AC(X))(right(intersection_AB(X))(X_in_B));
								}
							}
							prove lemma1: X in C -> X in B{
								implies X_in_C{
									return left(intersection_AB(X))(right(intersection_AC(X))(X_in_C));
								}
							}
							return and(lemma0, lemma1);
						}
					}
					return #equal_sets(B)(C)(def);
				}
			}
		}
	}
}

//Define the set difference. C = A - B:
define is_set_difference(A, B, C): *X((X in C -> X in A & ~X in B) & (X in A & ~X in B -> X in C));

prove set_difference: *A*B^C(is_set_difference(A, B, C)){
	given A{
		given B{
			define restrict(X): ~X in B;
			restricted = axiom_specify[(restrict)](A)(C);
			choose C{
				return #is_set_difference(A)(B)(C)(restricted);
			}
		}
	}
}

prove set_difference_unique: *A*B*C*D(is_set_difference(A, B, C) & is_set_difference(A, B, D) -> equal_sets(C, D)){
	given A{
		given B{
			define def(X): X in A & ~X in B;
			given C{
				given D{
					implies both{
						return definition_uniqueness_lemma[(def)](C)(D)(and(is_set_difference#(A)(B)(C)(left(both)), is_set_difference#(A)(B)(D)(right(both))));
					}
				}
			}
		}
	}
}

