<!DOCTYPE html><html><head><title>file</title></head><body><div class="header">CORE Source</div><div class="CORE_source"><code style="white-space: pre-wrap;">//Define when X <b style="color: green;">and</b> Y are related under R
<b style="color: blue;">define</b> are_related(X, Y, R): <b style="color: red;">^</b>T(T in R <b style="color: red;">&</b> is_tuple(X, Y, T));

//Define when a relation R is reflexive with respect to A
<b style="color: blue;">define</b> is_reflexive(R, A): <b style="color: red;">*</b>X(X in A <b style="color: red;">-&gt</b> are_related(X, X, R));

//Define when a relation R is symmetric
<b style="color: blue;">define</b> is_symmetric(R): <b style="color: red;">*</b>X<b style="color: red;">*</b>Y(are_related(X, Y, R) <b style="color: red;">-&gt</b> are_related(Y, X, R));

//Define when a relation R is transitive
<b style="color: blue;">define</b> is_transitive(R): <b style="color: red;">*</b>X<b style="color: red;">*</b>Y<b style="color: red;">*</b>Z(are_related(X, Y, R) <b style="color: red;">&</b> are_related(Y, Z, R) <b style="color: red;">-&gt</b> are_related(X, Z, R));

//Define an equivalence relation with respect to A (for reflexivity)
<b style="color: blue;">define</b> is_equivalence_relation(R, A): is_reflexive(R, A) <b style="color: red;">&</b> is_symmetric(R) <b style="color: red;">&</b> is_transitive(R);

//Define a function!
<b style="color: blue;">define</b> is_function(F): <b style="color: red;">*</b>X<b style="color: red;">*</b>Y<b style="color: red;">*</b>Z(are_related(X, Y, F) <b style="color: red;">&</b> are_related(X, Z, F) <b style="color: red;">-&gt</b> equal_sets(Y, Z));

//Define when a function is injective with respect to a domain A
<b style="color: blue;">define</b> is_injective(F, A): <b style="color: red;">*</b>X<b style="color: red;">*</b>Y(X in A <b style="color: red;">&</b> Y in A <b style="color: red;">&</b> <b style="color: red;">^</b>Z(are_related(X, Z, F) <b style="color: red;">&</b> are_related(Y, Z, F)) <b style="color: red;">-&gt</b> equal_sets(X, Y));

//Define when a function is surjective with respect to a codomain A
<b style="color: blue;">define</b> is_surjective(F, A): <b style="color: red;">*</b>Y(Y in A <b style="color: red;">-&gt</b> <b style="color: red;">^</b>X(are_related(X, Y, F)));

//Define when A is a domain for F
<b style="color: blue;">define</b> is_domain(F, A): <b style="color: red;">*</b>X(X in A <b style="color: red;">-&gt</b> <b style="color: red;">^</b>Y(are_related(X, Y, F)));

//Define when A is a domain for F
<b style="color: blue;">define</b> is_codomain(F, A): <b style="color: red;">*</b>X<b style="color: red;">*</b>Y(are_related(X, Y, F) <b style="color: red;">-&gt</b> Y in A);

//Define when B is the image of A under F
<b style="color: blue;">define</b> is_image(F, A, B): <b style="color: red;">*</b>Y(Y in B <b style="color: red;">&lt-&gt</b> <b style="color: red;">^</b>X(X in A <b style="color: red;">&</b> are_related(X, Y, F)));

//Define an identity function on A
<b style="color: blue;">define</b> is_identity_function(F, A): is_function(F) <b style="color: red;">&</b> is_domain(F, A) <b style="color: red;">&</b> <b style="color: red;">*</b>X<b style="color: red;">*</b>Y(are_related(X, Y, F) <b style="color: red;">&lt-&gt</b> equal_sets(X, Y));

//Define the composition H of two relations
<b style="color: blue;">define</b> is_composition(F, G, H): <b style="color: red;">*</b>X<b style="color: red;">*</b>Y(are_related(X, Y, H) <b style="color: red;">&lt-&gt</b> <b style="color: red;">^</b>Z(are_related(X, Z, G) <b style="color: red;">&</b> are_related(Z, Y, F)));

//The <b style="color: blue;">axiom</b> of choice!
<b style="color: blue;">axiom</b> axiom_choice: <b style="color: red;">*</b>C(<b style="color: red;">*</b>X(X in C <b style="color: red;">-&gt</b> not_empty(X)) <b style="color: red;">-&gt</b> <b style="color: red;">^</b>F(is_function(F) <b style="color: red;">&</b> is_domain(F, C) <b style="color: red;">&</b> <b style="color: red;">*</b>X<b style="color: red;">*</b>Y(are_related(X, Y, F) <b style="color: red;">-&gt</b> Y in X)));
//The axiomization of ZFC is complete. Time to do some math!

//Useful lemma for constructing relations using propositions
<b style="color: blue;">prove</b> relation_existence_lemma[P(2)]: <b style="color: red;">*</b>A<b style="color: red;">*</b>B<b style="color: red;">^</b>C<b style="color: red;">*</b>X<b style="color: red;">*</b>Y(are_related(X, Y, C) <b style="color: red;">&lt-&gt</b> X in A <b style="color: red;">&</b> Y in B <b style="color: red;">&</b> P(X, Y)){
	<b style="color: blue;">given</b> <b style="color: red;">|</b>A, B<b style="color: red;">|</b>;
	T_cross = <b style="color: green;">expand</b>(cross_product(A, B)<b style="color: red;">|</b>T<b style="color: red;">|</b>);
	C_specified = axiom_specify[&ltS: <b style="color: red;">^</b>X<b style="color: red;">^</b>Y(X in A <b style="color: red;">&</b> Y in B <b style="color: red;">&</b> is_tuple(X, Y, S) <b style="color: red;">&</b> P(X, Y))&gt](T)<b style="color: red;">|</b>C<b style="color: red;">|</b>;
	<b style="color: blue;">choose</b> C;
	<b style="color: blue;">given</b> <b style="color: red;">|</b>X, Y<b style="color: red;">|</b>;
	<b style="color: blue;">prove</b> lemma0: are_related(X, Y, C) <b style="color: red;">-&gt</b> X in A <b style="color: red;">&</b> Y in B <b style="color: red;">&</b> P(X, Y){
		<b style="color: blue;">implies</b> related_XY;
		<b style="color: blue;">extract</b> <b style="color: green;">expand</b>(related_XY)<b style="color: red;">|</b>TUPLE_XY<b style="color: red;">|</b>: XY_in_C, tuple_XY;
		<b style="color: blue;">extract</b> C_specified(TUPLE_XY)(XY_in_C): XY_in_T, tuple_existence;
		<b style="color: blue;">extract</b> tuple_existence<b style="color: red;">|</b>OTHER_X, OTHER_Y<b style="color: red;">|</b>: OTHER_X_in_A, OTHER_Y_in_B, other_tuple_XY, P_other;
		<b style="color: blue;">extract</b> tuple_equal_condition(OTHER_X, OTHER_Y, X, Y, TUPLE_XY, TUPLE_XY)(other_tuple_XY, tuple_XY, equal_sets_reflexive(TUPLE_XY)): equal_X, equal_Y;
		X_in_A = equality_consistency[&ltS: S in A&gt](OTHER_X, X)(equal_X)(OTHER_X_in_A);
		Y_in_B = equality_consistency[&ltS: S in B&gt](OTHER_Y, Y)(equal_Y)(OTHER_Y_in_B);
		P_other = equality_consistency[&ltS: P(S, OTHER_Y)&gt](OTHER_X, X)(equal_X)(P_other);
		P_XY = equality_consistency[&ltS: P(X, S)&gt](OTHER_Y, Y)(equal_Y)(P_other);
		<b style="color: blue;">return</b> X_in_A, Y_in_B, P_XY;
	}
	<b style="color: blue;">prove</b> lemma1: X in A <b style="color: red;">&</b> Y in B <b style="color: red;">&</b> P(X, Y) <b style="color: red;">-&gt</b> are_related(X, Y, C){
		<b style="color: blue;">implies</b> X_in_A, Y_in_B, P_XY;
		Z_tuple = tuple(X, Y)<b style="color: red;">|</b>Z<b style="color: red;">|</b>;
		<b style="color: blue;">prove</b> lemma: <b style="color: red;">^</b>J<b style="color: red;">^</b>K(J in A <b style="color: red;">&</b> K in B <b style="color: red;">&</b> is_tuple(J, K, Z)){
			<b style="color: blue;">choose</b> X, Y;
			<b style="color: blue;">return</b> X_in_A, Y_in_B, Z_tuple;
		}
		Z_in_T = T_cross(Z)(lemma);
		<b style="color: blue;">prove</b> lemma: <b style="color: red;">^</b>J<b style="color: red;">^</b>K(J in A <b style="color: red;">&</b> K in B <b style="color: red;">&</b> is_tuple(J, K, Z) <b style="color: red;">&</b> P(J, K)){
			<b style="color: blue;">choose</b> X, Y;
			<b style="color: blue;">return</b> X_in_A, Y_in_B, Z_tuple, P_XY;
		}
		Z_in_C = C_specified(Z)(Z_in_T, lemma);
		<b style="color: blue;">prove</b> related_def: <b style="color: red;">^</b>S(S in C <b style="color: red;">&</b> is_tuple(X, Y, S)){
			<b style="color: blue;">choose</b> Z;
			<b style="color: blue;">return</b> Z_in_C, Z_tuple;
		}
		<b style="color: blue;">return</b> #are_related(X, Y, C)(related_def);
	}
	<b style="color: blue;">return</b> <b style="color: green;">iff</b>(lemma0, lemma1);
}

//Define when C is the equivalence class with respect to an equivalence relation R on A
<b style="color: blue;">define</b> is_equivalence_class(R, A, C): <b style="color: red;">^</b>X(X in A <b style="color: red;">&</b> <b style="color: red;">*</b>Y(Y in C <b style="color: red;">&lt-&gt</b> Y in A <b style="color: red;">&</b> are_related(X, Y, R)));

//Define when C is the equivalence classes for R
<b style="color: blue;">define</b> is_equivalence_classes(R, A, C): <b style="color: red;">*</b>Y(Y in C <b style="color: red;">&lt-&gt</b> is_equivalence_class(R, A, Y));

//Define when two relations F <b style="color: green;">and</b> G are equal
<b style="color: blue;">define</b> equal_relations(F, G): <b style="color: red;">*</b>X<b style="color: red;">*</b>Y(are_related(X, Y, F) <b style="color: red;">&lt-&gt</b> are_related(X, Y, G));

//Prove that equivalence classes exist for any equivalence relation
<b style="color: blue;">prove</b> equivalence_classes: <b style="color: red;">*</b>A<b style="color: red;">*</b>R(is_equivalence_relation(R, A) <b style="color: red;">-&gt</b> <b style="color: red;">^</b>C(is_equivalence_classes(R, A, C))){
	<b style="color: blue;">given</b> <b style="color: red;">|</b>A, R<b style="color: red;">|</b>;
	<b style="color: blue;">implies</b> equiv_relation;
	<b style="color: blue;">extract</b> <b style="color: green;">expand</b>(equiv_relation): reflexive, symmetric, transitive;
	power_set_P = <b style="color: green;">expand</b>(power_set(A)<b style="color: red;">|</b>P<b style="color: red;">|</b>);
	C_def = axiom_specify[&ltS: is_equivalence_class(R, A, S)&gt](P)<b style="color: red;">|</b>C<b style="color: red;">|</b>;
	<b style="color: blue;">choose</b> C;
	<b style="color: blue;">prove</b> equiv_classes_def: <b style="color: red;">*</b>Y(Y in C <b style="color: red;">&lt-&gt</b> is_equivalence_class(R, A, Y)){
		<b style="color: blue;">given</b> <b style="color: red;">|</b>Y<b style="color: red;">|</b>;
		<b style="color: blue;">prove</b> lemma0: Y in C <b style="color: red;">-&gt</b> is_equivalence_class(R, A, Y){
			<b style="color: blue;">implies</b> Y_in_C;
			<b style="color: blue;">extract</b> C_def(Y)(Y_in_C): Y_in_P, result;
			<b style="color: blue;">return</b> result;
		}
		<b style="color: blue;">prove</b> lemma1: is_equivalence_class(R, A, Y) <b style="color: red;">-&gt</b> Y in C{
			<b style="color: blue;">implies</b> equiv_class;
			<b style="color: blue;">extract</b> <b style="color: green;">expand</b>(equiv_class)<b style="color: red;">|</b>Y_REP<b style="color: red;">|</b>: Y_REP_in_A, closure;
			<b style="color: blue;">prove</b> subset_def: <b style="color: red;">*</b>J(J in Y <b style="color: red;">-&gt</b> J in A){
				<b style="color: blue;">given</b> <b style="color: red;">|</b>J<b style="color: red;">|</b>;
				<b style="color: blue;">implies</b> J_in_Y;
				<b style="color: blue;">extract</b> closure(J)(J_in_Y): J_in_A, related_Y_REP_J;
				<b style="color: blue;">return</b> J_in_A;
			}
			Y_subset_A = #is_subset(Y, A)(subset_def);
			Y_in_P = power_set_P(Y)(Y_subset_A);
			<b style="color: blue;">return</b> C_def(Y)(Y_in_P, equiv_class);
		}
		<b style="color: blue;">return</b> <b style="color: green;">iff</b>(lemma0, lemma1);
	}
	<b style="color: blue;">return</b> #is_equivalence_classes(R, A, C)(equiv_classes_def);
}

//Prove that equivalence classes are disjoint
<b style="color: blue;">prove</b> equivalence_classes_disjoint: <b style="color: red;">*</b>A<b style="color: red;">*</b>R<b style="color: red;">*</b>C(is_equivalence_relation(R, A) <b style="color: red;">&</b> is_equivalence_classes(R, A, C) <b style="color: red;">-&gt</b> <b style="color: red;">*</b>X<b style="color: red;">*</b>Y(X in C <b style="color: red;">&</b> Y in C <b style="color: red;">&</b> <b style="color: red;">^</b>Z(Z in X <b style="color: red;">&</b> Z in Y) <b style="color: red;">-&gt</b> equal_sets(X, Y))){
	<b style="color: blue;">given</b> <b style="color: red;">|</b>A, R, C<b style="color: red;">|</b>;
	<b style="color: blue;">implies</b> equiv_relation, equiv_classes;
	<b style="color: blue;">extract</b> <b style="color: green;">expand</b>(equiv_relation): reflexive, symmetric, transitive;
	<b style="color: blue;">given</b> <b style="color: red;">|</b>X, Y<b style="color: red;">|</b>;
	<b style="color: blue;">implies</b> X_in_C, Y_in_C, not_disjoint;
	X_equiv_class = <b style="color: green;">expand</b>(equiv_classes)(X)(X_in_C);
	Y_equiv_class = <b style="color: green;">expand</b>(equiv_classes)(Y)(Y_in_C);
	<b style="color: blue;">extract</b> <b style="color: green;">expand</b>(X_equiv_class)<b style="color: red;">|</b>X_REP<b style="color: red;">|</b>: X_REP_in_A, X_closure;
	<b style="color: blue;">extract</b> <b style="color: green;">expand</b>(Y_equiv_class)<b style="color: red;">|</b>Y_REP<b style="color: red;">|</b>: Y_REP_in_A, Y_closure;
	<b style="color: blue;">extract</b> not_disjoint<b style="color: red;">|</b>Z<b style="color: red;">|</b>: Z_in_X, Z_in_Y;
	<b style="color: blue;">extract</b> X_closure(Z)(Z_in_X): Z_in_A, related_X_REP_Z;
	<b style="color: blue;">extract</b> Y_closure(Z)(Z_in_Y): Z_in_A, related_Y_REP_Z;
	related_Z_Y_REP = <b style="color: green;">expand</b>(symmetric)(Y_REP, Z)(related_Y_REP_Z);
	related_reps = <b style="color: green;">expand</b>(transitive)(X_REP, Z, Y_REP)(related_X_REP_Z, related_Z_Y_REP);
	related_reps_other = <b style="color: green;">expand</b>(symmetric)(X_REP, Y_REP)(related_reps);
	<b style="color: blue;">prove</b> equal_def: <b style="color: red;">*</b>J(J in X <b style="color: red;">&lt-&gt</b> J in Y){
		<b style="color: blue;">given</b> <b style="color: red;">|</b>J<b style="color: red;">|</b>;
		<b style="color: blue;">prove</b> lemma0: J in X <b style="color: red;">-&gt</b> J in Y{
			<b style="color: blue;">implies</b> J_in_X;
			<b style="color: blue;">extract</b> X_closure(J)(J_in_X): J_in_A, related_X_REP_J;
			related_Y_REP_J = <b style="color: green;">expand</b>(transitive)(Y_REP, X_REP, J)(related_reps_other, related_X_REP_J);
			<b style="color: blue;">return</b> Y_closure(J)(J_in_A, related_Y_REP_J);
		}
		<b style="color: blue;">prove</b> lemma1: J in Y <b style="color: red;">-&gt</b> J in X{
			<b style="color: blue;">implies</b> J_in_Y;
			<b style="color: blue;">extract</b> Y_closure(J)(J_in_Y): J_in_A, related_Y_REP_J;
			related_X_REP_J = <b style="color: green;">expand</b>(transitive)(X_REP, Y_REP, J)(related_reps, related_Y_REP_J);
			<b style="color: blue;">return</b> X_closure(J)(J_in_A, related_X_REP_J);
		}
		<b style="color: blue;">return</b> <b style="color: green;">iff</b>(lemma0, lemma1);
	}
	<b style="color: blue;">return</b> #equal_sets(X, Y)(equal_def);
}

//Prove that every element of A has an equivalence class
<b style="color: blue;">prove</b> equivalence_classes_class: <b style="color: red;">*</b>A<b style="color: red;">*</b>R<b style="color: red;">*</b>C(is_equivalence_relation(R, A) <b style="color: red;">&</b> is_equivalence_classes(R, A, C) <b style="color: red;">-&gt</b> <b style="color: red;">*</b>X(X in A <b style="color: red;">-&gt</b> <b style="color: red;">^</b>D(D in C <b style="color: red;">&</b> X in D))){
	<b style="color: blue;">given</b> <b style="color: red;">|</b>A, R, C<b style="color: red;">|</b>;
	<b style="color: blue;">implies</b> equiv_relation, equiv_classes;
	<b style="color: blue;">extract</b> <b style="color: green;">expand</b>(equiv_relation): reflexive, symmetric, transitive;
	<b style="color: blue;">given</b> <b style="color: red;">|</b>X<b style="color: red;">|</b>;
	<b style="color: blue;">implies</b> X_in_A;
	D_def = axiom_specify[&ltS: are_related(X, S, R)&gt](A)<b style="color: red;">|</b>D<b style="color: red;">|</b>;
	<b style="color: blue;">choose</b> D;
	X_in_D = D_def(X)(X_in_A, <b style="color: green;">expand</b>(reflexive)(X)(X_in_A));
	<b style="color: blue;">prove</b> equiv_class_def: <b style="color: red;">^</b>X(X in A <b style="color: red;">&</b> <b style="color: red;">*</b>Y(Y in D <b style="color: red;">&lt-&gt</b> Y in A <b style="color: red;">&</b> are_related(X, Y, R))){
		<b style="color: blue;">choose</b> X;
		<b style="color: blue;">prove</b> right_def: <b style="color: red;">*</b>Y(Y in D <b style="color: red;">&lt-&gt</b> Y in A <b style="color: red;">&</b> are_related(X, Y, R)){
			<b style="color: blue;">given</b> <b style="color: red;">|</b>Y<b style="color: red;">|</b>;
			<b style="color: blue;">prove</b> lemma0: Y in D <b style="color: red;">-&gt</b> Y in A <b style="color: red;">&</b> are_related(X, Y, R){
				<b style="color: blue;">implies</b> Y_in_D;
				<b style="color: blue;">extract</b> D_def(Y)(Y_in_D): Y_in_A, related;
				<b style="color: blue;">return</b> Y_in_A, related;
			}
			<b style="color: blue;">prove</b> lemma1: Y in A <b style="color: red;">&</b> are_related(X, Y, R) <b style="color: red;">-&gt</b> Y in D{
				<b style="color: blue;">implies</b> premises;
				<b style="color: blue;">return</b> D_def(Y)(premises);
			}
			<b style="color: blue;">return</b> <b style="color: green;">iff</b>(lemma0, lemma1);
		}
		<b style="color: blue;">return</b> X_in_A, right_def;
	}
	equiv_class = #is_equivalence_class(R, A, D)(equiv_class_def);
	D_in_C = <b style="color: green;">expand</b>(equiv_classes)(D)(equiv_class);
	<b style="color: blue;">return</b> D_in_C, X_in_D;
}

//Prove that equivalence classes, if they exist, are unique
<b style="color: blue;">prove</b> equivalence_classes_unique: <b style="color: red;">*</b>A<b style="color: red;">*</b>R<b style="color: red;">*</b>C<b style="color: red;">*</b>D(is_equivalence_classes(R, A, C) <b style="color: red;">&</b> is_equivalence_classes(R, A, D) <b style="color: red;">-&gt</b> equal_sets(C, D)){
	<b style="color: blue;">given</b> <b style="color: red;">|</b>A, R, C, D<b style="color: red;">|</b>;
	<b style="color: blue;">implies</b> both_equiv_classes;
	<b style="color: blue;">extract</b> both_equiv_classes: equiv_classes_C, equiv_classes_D;
	<b style="color: blue;">return</b> definition_uniqueness_lemma[&ltS: is_equivalence_class(R, A, S)&gt](C, D)(<b style="color: green;">expand</b>(equiv_classes_C), <b style="color: green;">expand</b>(equiv_classes_D));
}

</code></div></body></html>