<!DOCTYPE html><html><head><title>file</title></head><body><div class="header">CORE Source</div><div class="CORE_source"><code style="white-space: pre-wrap;">//Define when X and Y are related under R
<b style="color: blue">define </b>are_related(X, Y, R): ^T(T in R & is_tuple(X, Y, T));

//Define when a relation R is reflexive with respect to A
<b style="color: blue">define </b>is_reflexive(R, A): *X(X in A -&gt are_related(X, X, R));

//Define when a relation R is symmetric
<b style="color: blue">define </b>is_symmetric(R): *X*Y(are_related(X, Y, R) -&gt are_related(Y, X, R));

//Define when a relation R is transitive
<b style="color: blue">define </b>is_transitive(R): *X*Y*Z(are_related(X, Y, R) & are_related(Y, Z, R) -&gt are_related(X, Z, R));

//Define an equivalence relation with respect to A (for reflexivity)
<b style="color: blue">define </b>is_equivalence_relation(R, A): is_reflexive(R, A) & is_symmetric(R) & is_transitive(R);

//Define a function!
<b style="color: blue">define </b>is_function(F): *X*Y*Z(are_related(X, Y, F) & are_related(X, Z, F) -&gt equal_sets(Y, Z));

//Define when a function is injective with respect to a domain A
<b style="color: blue">define </b>is_injective(F, A): *X*Y(X in A & Y in A & ^Z(are_related(X, Z, F) & are_related(Y, Z, F)) -&gt equal_sets(X, Y));

//Define when a function is surjective with respect to a codomain A
<b style="color: blue">define </b>is_surjective(F, A): *Y(Y in A -&gt ^X(are_related(X, Y, F)));

//Define when A is a domain for F
<b style="color: blue">define </b>is_domain(F, A): *X(X in A -&gt ^Y(are_related(X, Y, F)));

//Define when A is a domain for F
<b style="color: blue">define </b>is_codomain(F, A): *X*Y(are_related(X, Y, F) -&gt Y in A);

//Define when B is the image of A under F
<b style="color: blue">define </b>is_image(F, A, B): *Y(Y in B &lt-&gt ^X(X in A & are_related(X, Y, F)));

//Define an identity function on A
<b style="color: blue">define </b>is_identity_function(F, A): is_function(F) & is_domain(F, A) & *X*Y(are_related(X, Y, F) &lt-&gt equal_sets(X, Y));

//Define the composition H of two relations
<b style="color: blue">define </b>is_composition(F, G, H): *X*Y(are_related(X, Y, H) &lt-&gt ^Z(are_related(X, Z, G) & are_related(Z, Y, F)));

//The <b style="color: blue">axiom </b>of choice!
<b style="color: blue">axiom </b>axiom_choice: *C(*X(X in C -&gt not_empty(X)) -&gt ^F(is_function(F) & is_domain(F, C) & *X*Y(are_related(X, Y, F) -&gt Y in X)));
//The axiomization of ZFC is complete. Time to do some math!

//Useful lemma for constructing relations using propositions
<b style="color: blue">prove </b>relation_existence_lemma[P(2)]: *A*B^C*X*Y(are_related(X, Y, C) &lt-&gt X in A & Y in B & P(X, Y)){
	<b style="color: blue">given </b>|A, B|;
	T_cross = expand(cross_product(A, B)|T|);
	C_specified = axiom_specify[&ltS: ^X^Y(X in A & Y in B & is_tuple(X, Y, S) & P(X, Y))&gt](T)|C|;
	<b style="color: blue">choose </b>C;
	<b style="color: blue">given </b>|X, Y|;
	<b style="color: blue">prove </b>lemma0: are_related(X, Y, C) -&gt X in A & Y in B & P(X, Y){
		<b style="color: blue">implies </b>related_XY;
		<b style="color: blue">extract </b>expand(related_XY)|TUPLE_XY|: XY_in_C, tuple_XY;
		<b style="color: blue">extract </b>C_specified(TUPLE_XY)(XY_in_C): XY_in_T, tuple_existence;
		<b style="color: blue">extract </b>tuple_existence|OTHER_X, OTHER_Y|: OTHER_X_in_A, OTHER_Y_in_B, other_tuple_XY, P_other;
		<b style="color: blue">extract </b>tuple_equal_condition(OTHER_X, OTHER_Y, X, Y, TUPLE_XY, TUPLE_XY)(other_tuple_XY, tuple_XY, equal_sets_reflexive(TUPLE_XY)): equal_X, equal_Y;
		X_in_A = equality_consistency[&ltS: S in A&gt](OTHER_X, X)(equal_X)(OTHER_X_in_A);
		Y_in_B = equality_consistency[&ltS: S in B&gt](OTHER_Y, Y)(equal_Y)(OTHER_Y_in_B);
		P_other = equality_consistency[&ltS: P(S, OTHER_Y)&gt](OTHER_X, X)(equal_X)(P_other);
		P_XY = equality_consistency[&ltS: P(X, S)&gt](OTHER_Y, Y)(equal_Y)(P_other);
		<b style="color: blue">return </b>X_in_A, Y_in_B, P_XY;
	}
	<b style="color: blue">prove </b>lemma1: X in A & Y in B & P(X, Y) -&gt are_related(X, Y, C){
		<b style="color: blue">implies </b>X_in_A, Y_in_B, P_XY;
		Z_tuple = tuple(X, Y)|Z|;
		<b style="color: blue">prove </b>lemma: ^J^K(J in A & K in B & is_tuple(J, K, Z)){
			<b style="color: blue">choose </b>X, Y;
			<b style="color: blue">return </b>X_in_A, Y_in_B, Z_tuple;
		}
		Z_in_T = T_cross(Z)(lemma);
		<b style="color: blue">prove </b>lemma: ^J^K(J in A & K in B & is_tuple(J, K, Z) & P(J, K)){
			<b style="color: blue">choose </b>X, Y;
			<b style="color: blue">return </b>X_in_A, Y_in_B, Z_tuple, P_XY;
		}
		Z_in_C = C_specified(Z)(Z_in_T, lemma);
		<b style="color: blue">prove </b>related_def: ^S(S in C & is_tuple(X, Y, S)){
			<b style="color: blue">choose </b>Z;
			<b style="color: blue">return </b>Z_in_C, Z_tuple;
		}
		<b style="color: blue">return </b>#are_related(X, Y, C)(related_def);
	}
	<b style="color: blue">return </b>iff(lemma0, lemma1);
}

//Define when C is the equivalence class with respect to an equivalence relation R on A
<b style="color: blue">define </b>is_equivalence_class(R, A, C): ^X(X in A & *Y(Y in C &lt-&gt Y in A & are_related(X, Y, R)));

//Define when C is the equivalence classes for R
<b style="color: blue">define </b>is_equivalence_classes(R, A, C): *Y(Y in C &lt-&gt is_equivalence_class(R, A, Y));

//Define when two relations F and G are equal
<b style="color: blue">define </b>equal_relations(F, G): *X*Y(are_related(X, Y, F) &lt-&gt are_related(X, Y, G));

//Prove that equivalence classes exist for any equivalence relation
<b style="color: blue">prove </b>equivalence_classes: *A*R(is_equivalence_relation(R, A) -&gt ^C(is_equivalence_classes(R, A, C))){
	<b style="color: blue">given </b>|A, R|;
	<b style="color: blue">implies </b>equiv_relation;
	<b style="color: blue">extract </b>expand(equiv_relation): reflexive, symmetric, transitive;
	power_set_P = expand(power_set(A)|P|);
	C_def = axiom_specify[&ltS: is_equivalence_class(R, A, S)&gt](P)|C|;
	<b style="color: blue">choose </b>C;
	<b style="color: blue">prove </b>equiv_classes_def: *Y(Y in C &lt-&gt is_equivalence_class(R, A, Y)){
		<b style="color: blue">given </b>|Y|;
		<b style="color: blue">prove </b>lemma0: Y in C -&gt is_equivalence_class(R, A, Y){
			<b style="color: blue">implies </b>Y_in_C;
			<b style="color: blue">extract </b>C_def(Y)(Y_in_C): Y_in_P, result;
			<b style="color: blue">return </b>result;
		}
		<b style="color: blue">prove </b>lemma1: is_equivalence_class(R, A, Y) -&gt Y in C{
			<b style="color: blue">implies </b>equiv_class;
			<b style="color: blue">extract </b>expand(equiv_class)|Y_REP|: Y_REP_in_A, closure;
			<b style="color: blue">prove </b>subset_def: *J(J in Y -&gt J in A){
				<b style="color: blue">given </b>|J|;
				<b style="color: blue">implies </b>J_in_Y;
				<b style="color: blue">extract </b>closure(J)(J_in_Y): J_in_A, related_Y_REP_J;
				<b style="color: blue">return </b>J_in_A;
			}
			Y_subset_A = #is_subset(Y, A)(subset_def);
			Y_in_P = power_set_P(Y)(Y_subset_A);
			<b style="color: blue">return </b>C_def(Y)(Y_in_P, equiv_class);
		}
		<b style="color: blue">return </b>iff(lemma0, lemma1);
	}
	<b style="color: blue">return </b>#is_equivalence_classes(R, A, C)(equiv_classes_def);
}

//Prove that equivalence classes are disjoint
<b style="color: blue">prove </b>equivalence_classes_disjoint: *A*R*C(is_equivalence_relation(R, A) & is_equivalence_classes(R, A, C) -&gt *X*Y(X in C & Y in C & ^Z(Z in X & Z in Y) -&gt equal_sets(X, Y))){
	<b style="color: blue">given </b>|A, R, C|;
	<b style="color: blue">implies </b>equiv_relation, equiv_classes;
	<b style="color: blue">extract </b>expand(equiv_relation): reflexive, symmetric, transitive;
	<b style="color: blue">given </b>|X, Y|;
	<b style="color: blue">implies </b>X_in_C, Y_in_C, not_disjoint;
	X_equiv_class = expand(equiv_classes)(X)(X_in_C);
	Y_equiv_class = expand(equiv_classes)(Y)(Y_in_C);
	<b style="color: blue">extract </b>expand(X_equiv_class)|X_REP|: X_REP_in_A, X_closure;
	<b style="color: blue">extract </b>expand(Y_equiv_class)|Y_REP|: Y_REP_in_A, Y_closure;
	<b style="color: blue">extract </b>not_disjoint|Z|: Z_in_X, Z_in_Y;
	<b style="color: blue">extract </b>X_closure(Z)(Z_in_X): Z_in_A, related_X_REP_Z;
	<b style="color: blue">extract </b>Y_closure(Z)(Z_in_Y): Z_in_A, related_Y_REP_Z;
	related_Z_Y_REP = expand(symmetric)(Y_REP, Z)(related_Y_REP_Z);
	related_reps = expand(transitive)(X_REP, Z, Y_REP)(related_X_REP_Z, related_Z_Y_REP);
	related_reps_other = expand(symmetric)(X_REP, Y_REP)(related_reps);
	<b style="color: blue">prove </b>equal_def: *J(J in X &lt-&gt J in Y){
		<b style="color: blue">given </b>|J|;
		<b style="color: blue">prove </b>lemma0: J in X -&gt J in Y{
			<b style="color: blue">implies </b>J_in_X;
			<b style="color: blue">extract </b>X_closure(J)(J_in_X): J_in_A, related_X_REP_J;
			related_Y_REP_J = expand(transitive)(Y_REP, X_REP, J)(related_reps_other, related_X_REP_J);
			<b style="color: blue">return </b>Y_closure(J)(J_in_A, related_Y_REP_J);
		}
		<b style="color: blue">prove </b>lemma1: J in Y -&gt J in X{
			<b style="color: blue">implies </b>J_in_Y;
			<b style="color: blue">extract </b>Y_closure(J)(J_in_Y): J_in_A, related_Y_REP_J;
			related_X_REP_J = expand(transitive)(X_REP, Y_REP, J)(related_reps, related_Y_REP_J);
			<b style="color: blue">return </b>X_closure(J)(J_in_A, related_X_REP_J);
		}
		<b style="color: blue">return </b>iff(lemma0, lemma1);
	}
	<b style="color: blue">return </b>#equal_sets(X, Y)(equal_def);
}

//Prove that every element of A has an equivalence class
<b style="color: blue">prove </b>equivalence_classes_class: *A*R*C(is_equivalence_relation(R, A) & is_equivalence_classes(R, A, C) -&gt *X(X in A -&gt ^D(D in C & X in D))){
	<b style="color: blue">given </b>|A, R, C|;
	<b style="color: blue">implies </b>equiv_relation, equiv_classes;
	<b style="color: blue">extract </b>expand(equiv_relation): reflexive, symmetric, transitive;
	<b style="color: blue">given </b>|X|;
	<b style="color: blue">implies </b>X_in_A;
	D_def = axiom_specify[&ltS: are_related(X, S, R)&gt](A)|D|;
	<b style="color: blue">choose </b>D;
	X_in_D = D_def(X)(X_in_A, expand(reflexive)(X)(X_in_A));
	<b style="color: blue">prove </b>equiv_class_def: ^X(X in A & *Y(Y in D &lt-&gt Y in A & are_related(X, Y, R))){
		<b style="color: blue">choose </b>X;
		<b style="color: blue">prove </b>right_def: *Y(Y in D &lt-&gt Y in A & are_related(X, Y, R)){
			<b style="color: blue">given </b>|Y|;
			<b style="color: blue">prove </b>lemma0: Y in D -&gt Y in A & are_related(X, Y, R){
				<b style="color: blue">implies </b>Y_in_D;
				<b style="color: blue">extract </b>D_def(Y)(Y_in_D): Y_in_A, related;
				<b style="color: blue">return </b>Y_in_A, related;
			}
			<b style="color: blue">prove </b>lemma1: Y in A & are_related(X, Y, R) -&gt Y in D{
				<b style="color: blue">implies </b>premises;
				<b style="color: blue">return </b>D_def(Y)(premises);
			}
			<b style="color: blue">return </b>iff(lemma0, lemma1);
		}
		<b style="color: blue">return </b>X_in_A, right_def;
	}
	equiv_class = #is_equivalence_class(R, A, D)(equiv_class_def);
	D_in_C = expand(equiv_classes)(D)(equiv_class);
	<b style="color: blue">return </b>D_in_C, X_in_D;
}

//Prove that equivalence classes, if they exist, are unique
<b style="color: blue">prove </b>equivalence_classes_unique: *A*R*C*D(is_equivalence_classes(R, A, C) & is_equivalence_classes(R, A, D) -&gt equal_sets(C, D)){
	<b style="color: blue">given </b>|A, R, C, D|;
	<b style="color: blue">implies </b>both_equiv_classes;
	<b style="color: blue">extract </b>both_equiv_classes: equiv_classes_C, equiv_classes_D;
	<b style="color: blue">return </b>definition_uniqueness_lemma[&ltS: is_equivalence_class(R, A, S)&gt](C, D)(expand(equiv_classes_C), expand(equiv_classes_D));
}

</code></div></body></html>