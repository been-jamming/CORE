<!DOCTYPE html><html><head><title>CORE result</title><link rel="stylesheet" href="../style.css"></link><link rel="stylesheet" href="https://fontlibrary.org/face/pixelated" type="text/css"></link></head><body><h1 style="font-size: 4vw">CORE library</h1><div class="page_body"><div class="card"><b>Result type</b>: proof<br><b>Result name</b>: naturals_recursion_theorem<br><b>Description</b>: We want to prove that functions can be recursively constructed<br>I think I will replace the current construction of addition with a new proof<br>Since this proof is more general.<br>This result will also be used to define multiplication! It could be used, for instance, to define the fibonacci numbers.<br>It's pretty important.<br><br><b>Source</b>:<br><br><code style="white-space: pre-wrap; cursor: default;"><b style="color: blue;">prove</b> <b style="cursor: pointer;" onclick="window.location.href = '../03_addition/naturals_recursion_theorem.html';" onmouseover="popup_window(this, 'naturals_recursion_theorem | 03_addition');" onmouseout="close_popup();">naturals_recursion_theorem</b>: <b style="color: red;">*</b>T<b style="color: red;">*</b>A<b style="color: red;">*</b>G(A in T <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/is_function.html';" onmouseover="popup_window(this, 'is_function | 02_relations');" onmouseout="close_popup();">is_function</b>(G) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/is_domain.html';" onmouseover="popup_window(this, 'is_domain | 02_relations');" onmouseout="close_popup();">is_domain</b>(G, T) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/is_codomain.html';" onmouseover="popup_window(this, 'is_codomain | 02_relations');" onmouseout="close_popup();">is_codomain</b>(G, T) <b style="color: red;">-&gt</b> <b style="color: red;">^</b>F(<b style="cursor: pointer;" onclick="window.location.href = '../03_addition/is_recursively_defined_naturals.html';" onmouseover="popup_window(this, 'is_recursively_defined_naturals | 03_addition');" onmouseout="close_popup();">is_recursively_defined_naturals</b>(T, A, G, F))){
	empty_in_naturals, closure_naturals = <b style="color: green;">expand</b>(<b style="cursor: pointer;" onclick="window.location.href = '../03_addition/NATURALS_inductive.html';" onmouseover="popup_window(this, 'NATURALS_inductive | 03_addition');" onmouseout="close_popup();">NATURALS_inductive</b>);

	<b style="color: blue;">given</b> <b style="color: red;">|</b>T, A, G<b style="color: red;">|</b>;
	<b style="color: blue;">implies</b> A_in_T, function_G, G_domain_T, G_codomain_T;
	//Define a recursive part to be a subset of what will be F
	//An element of P is either (0, A) <b style="color: green;">or</b> a <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/successor.html';" onmouseover="popup_window(this, 'successor | 00_zf');" onmouseout="close_popup();">successor</b> of something else in P
	<b style="color: blue;">define</b> is_recursive_part(P): <b style="color: red;">*</b>T(T in P <b style="color: red;">-&gt</b> <b style="color: red;">^</b>X<b style="color: red;">^</b>Y(<b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(X, Y, T) <b style="color: red;">&</b> ((<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(ZERO, X) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(A, Y)) <b style="color: red;">|</b> <b style="color: red;">^</b>PX<b style="color: red;">^</b>PY(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(PX, X) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(PY, Y, G) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(PX, PY, P)))));

	//The plan is to take the <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/union.html';" onmouseover="popup_window(this, 'union | 00_zf');" onmouseout="close_popup();">union</b> of all subsets of NxT which are recursive parts!
	//To do so, we need the set NxT which we call NT
	cross_product_NT = <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/cross_product.html';" onmouseover="popup_window(this, 'cross_product | 01_sets');" onmouseout="close_popup();">cross_product</b>(NATURALS, T)<b style="color: red;">|</b>NT<b style="color: red;">|</b>;
	//We now need the power set of NT, which we call PNT
	power_set_PNT = <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/power_set.html';" onmouseover="popup_window(this, 'power_set | 01_sets');" onmouseout="close_popup();">power_set</b>(NT)<b style="color: red;">|</b>PNT<b style="color: red;">|</b>;

	//We call the set of all subsets of PNT which are recursive parts U
	U_def = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/axiom_specify.html';" onmouseover="popup_window(this, 'axiom_specify | 00_zf');" onmouseout="close_popup();">axiom_specify</b>[&ltQ: is_recursive_part(Q)&gt](PNT)<b style="color: red;">|</b>U<b style="color: red;">|</b>;

	//And we finally <b style="color: blue;">define</b> F
	F_def = <b style="color: green;">expand</b>(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/union.html';" onmouseover="popup_window(this, 'union | 00_zf');" onmouseout="close_popup();">union</b>(U)<b style="color: red;">|</b>F<b style="color: red;">|</b>);
	<b style="color: blue;">choose</b> F;

	<b style="color: blue;">prove</b> ZERO_related_A: <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(ZERO, A, F){
		tuple_J = <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/tuple.html';" onmouseover="popup_window(this, 'tuple | 01_sets');" onmouseout="close_popup();">tuple</b>(ZERO, A)<b style="color: red;">|</b>J<b style="color: red;">|</b>;
		P_def = <b style="color: green;">expand</b>(<b style="cursor: pointer;" onclick="window.location.href = '../01_sets/singleton.html';" onmouseover="popup_window(this, 'singleton | 01_sets');" onmouseout="close_popup();">singleton</b>(J)<b style="color: red;">|</b>P<b style="color: red;">|</b>);
		<b style="color: blue;">prove</b> P_recursive_part: <b style="color: red;">*</b>K(K in P <b style="color: red;">-&gt</b> <b style="color: red;">^</b>X<b style="color: red;">^</b>Y(<b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(X, Y, K) <b style="color: red;">&</b> ((<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(ZERO, X) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(A, Y)) <b style="color: red;">|</b> <b style="color: red;">^</b>PX<b style="color: red;">^</b>PY(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(PX, X) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(PY, Y, G) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(PX, PY, P))))){
			<b style="color: blue;">given</b> <b style="color: red;">|</b>K<b style="color: red;">|</b>;
			<b style="color: blue;">implies</b> K_in_P;
			K_equal_J = P_def(K)(K_in_P);
			<b style="color: blue;">choose</b> ZERO, A;
			tuple_K = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(ZERO, A, Q)&gt](K, J)(K_equal_J)(tuple_J);
			<b style="color: blue;">return</b> tuple_K, <b style="color: green;">or</b>(<b style="color: green;">and</b>(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets_reflexive.html';" onmouseover="popup_window(this, 'equal_sets_reflexive | 00_zf');" onmouseout="close_popup();">equal_sets_reflexive</b>(ZERO), <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets_reflexive.html';" onmouseover="popup_window(this, 'equal_sets_reflexive | 00_zf');" onmouseout="close_popup();">equal_sets_reflexive</b>(A)), &lt:<b style="color: red;">^</b>PX<b style="color: red;">^</b>PY(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(PX, ZERO) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(PY, A, G) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(PX, PY, P))&gt);
		}
		P_recursive_part = #is_recursive_part(P)(P_recursive_part);
		<b style="color: blue;">prove</b> J_in_NT: <b style="color: red;">^</b>ZERO<b style="color: red;">^</b>A(ZERO in NATURALS <b style="color: red;">&</b> A in T <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(ZERO, A, J)){
			<b style="color: blue;">choose</b> ZERO, A;
			<b style="color: blue;">return</b> zero_is_natural, A_in_T, tuple_J;
		}
		J_in_NT = <b style="color: green;">expand</b>(cross_product_NT)(J)(J_in_NT);
		<b style="color: blue;">prove</b> P_subset_NT: <b style="color: red;">*</b>K(K in P <b style="color: red;">-&gt</b> K in NT){
			<b style="color: blue;">given</b> <b style="color: red;">|</b>K<b style="color: red;">|</b>;
			<b style="color: blue;">implies</b> K_in_P;
			K_equal_J = P_def(K)(K_in_P);
			<b style="color: blue;">return</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: Q in NT&gt](K, J)(K_equal_J)(J_in_NT);
		}
		P_subset_NT = #<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_subset.html';" onmouseover="popup_window(this, 'is_subset | 00_zf');" onmouseout="close_popup();">is_subset</b>(P, NT)(P_subset_NT);
		P_in_PNT = <b style="color: green;">expand</b>(power_set_PNT)(P)(P_subset_NT);
		P_in_U = U_def(P)(P_in_PNT, P_recursive_part);
		<b style="color: blue;">prove</b> J_in_F: <b style="color: red;">^</b>P(P in U <b style="color: red;">&</b> J in P){
			<b style="color: blue;">choose</b> P;
			<b style="color: blue;">return</b> P_in_U, P_def(J)(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets_reflexive.html';" onmouseover="popup_window(this, 'equal_sets_reflexive | 00_zf');" onmouseout="close_popup();">equal_sets_reflexive</b>(J));
		}
		J_in_F = F_def(J)(J_in_F);
		<b style="color: blue;">prove</b> ZERO_related_A: <b style="color: red;">^</b>J(J in F <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(ZERO, A, J)){
			<b style="color: blue;">choose</b> J;
			<b style="color: blue;">return</b> J_in_F, tuple_J;
		}
		<b style="color: blue;">return</b> #<b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(ZERO, A, F)(ZERO_related_A);
	}

	//We need to show that for every natural number N, there exists Y in T such that (N, Y) is in F.
	//It's easy to see that {(0, A)} is a recursive part.
	//For any recursive part P containing (N, Y), we can construct P U {(N + 1, G(Y))}, which is a recursive part covering N + 1
	//So that's the plan
	<b style="color: blue;">prove</b> covers_NATURALS: <b style="color: red;">*</b>N(N in NATURALS <b style="color: red;">-&gt</b> <b style="color: red;">^</b>Y(<b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(N, Y, F))){
		//We induct on N
		R_def = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/axiom_specify.html';" onmouseover="popup_window(this, 'axiom_specify | 00_zf');" onmouseout="close_popup();">axiom_specify</b>[&ltN: <b style="color: red;">^</b>Y(<b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(N, Y, F))&gt](NATURALS)<b style="color: red;">|</b>R<b style="color: red;">|</b>;

		<b style="color: blue;">prove</b> ZERO_in_R: <b style="color: red;">^</b>A(<b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(ZERO, A, F)){
			<b style="color: blue;">choose</b> A;

			<b style="color: blue;">return</b> ZERO_related_A;
		}
		ZERO_in_R = R_def(ZERO)(zero_is_natural, ZERO_in_R);

		<b style="color: blue;">prove</b> closure_R: <b style="color: red;">*</b>N<b style="color: red;">*</b>N1(N in R <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(N, N1) <b style="color: red;">-&gt</b> N1 in R){
			<b style="color: blue;">given</b> <b style="color: red;">|</b>N, N1<b style="color: red;">|</b>;
			<b style="color: blue;">implies</b> N_in_R, successor_N1;
			N_in_NATURALS, N_cond = R_def(N)(N_in_R);
			N1_in_NATURALS = closure_naturals(N, N1)(N_in_NATURALS, successor_N1);
			PJ_in_F, tuple_PJ = <b style="color: green;">expand</b>(N_cond<b style="color: red;">|</b>PY<b style="color: red;">|</b>)<b style="color: red;">|</b>PJ<b style="color: red;">|</b>;
			PP_in_U, PJ_in_PP = F_def(PJ)(PJ_in_F)<b style="color: red;">|</b>PP<b style="color: red;">|</b>;
			PP_in_PNT, PP_recursive_part = U_def(PP)(PP_in_U);
			PP_subset_NT = <b style="color: green;">expand</b>(power_set_PNT)(PP)(PP_in_PNT);
			PJ_in_NT = <b style="color: green;">expand</b>(PP_subset_NT)(PJ)(PJ_in_PP);
			OTHER_N_in_NATURALS, OTHER_PY_in_T, other_tuple_PJ = <b style="color: green;">expand</b>(cross_product_NT)(PJ)(PJ_in_NT)<b style="color: red;">|</b>OTHER_N, OTHER_PY<b style="color: red;">|</b>;
			equal_N, equal_PY = <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/tuple_equal_condition.html';" onmouseover="popup_window(this, 'tuple_equal_condition | 01_sets');" onmouseout="close_popup();">tuple_equal_condition</b>(N, PY, OTHER_N, OTHER_PY, PJ, PJ)(tuple_PJ, other_tuple_PJ, <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets_reflexive.html';" onmouseover="popup_window(this, 'equal_sets_reflexive | 00_zf');" onmouseout="close_popup();">equal_sets_reflexive</b>(PJ));
			PY_in_T = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: Q in T&gt](PY, OTHER_PY)(equal_PY)(OTHER_PY_in_T);
			PY_related_Y = <b style="color: green;">expand</b>(G_domain_T)(PY)(PY_in_T)<b style="color: red;">|</b>Y<b style="color: red;">|</b>;
			Y_in_T = <b style="color: green;">expand</b>(G_codomain_T)(PY, Y)(PY_related_Y);
			tuple_J = <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/tuple.html';" onmouseover="popup_window(this, 'tuple | 01_sets');" onmouseout="close_popup();">tuple</b>(N1, Y)<b style="color: red;">|</b>J<b style="color: red;">|</b>;
			<b style="color: blue;">prove</b> J_in_NT: <b style="color: red;">^</b>N1<b style="color: red;">^</b>Y(N1 in NATURALS <b style="color: red;">&</b> Y in T <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(N1, Y, J)){
				<b style="color: blue;">choose</b> N1, Y;
				<b style="color: blue;">return</b> N1_in_NATURALS, Y_in_T, tuple_J;
			}
			J_in_NT = <b style="color: green;">expand</b>(cross_product_NT)(J)(J_in_NT);
			K_def = <b style="color: green;">expand</b>(<b style="cursor: pointer;" onclick="window.location.href = '../01_sets/singleton.html';" onmouseover="popup_window(this, 'singleton | 01_sets');" onmouseout="close_popup();">singleton</b>(J)<b style="color: red;">|</b>K<b style="color: red;">|</b>);
			PAIR_def = <b style="color: green;">expand</b>(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/pair.html';" onmouseover="popup_window(this, 'pair | 00_zf');" onmouseout="close_popup();">pair</b>(PP, K)<b style="color: red;">|</b>PAIR<b style="color: red;">|</b>);
			P_def = <b style="color: green;">expand</b>(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/union.html';" onmouseover="popup_window(this, 'union | 00_zf');" onmouseout="close_popup();">union</b>(PAIR)<b style="color: red;">|</b>P<b style="color: red;">|</b>);
			<b style="color: blue;">prove</b> P_def: <b style="color: red;">*</b>M(M in P <b style="color: red;">&lt-&gt</b> M in PP <b style="color: red;">|</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(M, J)){
				<b style="color: blue;">given</b> <b style="color: red;">|</b>M<b style="color: red;">|</b>;
				<b style="color: blue;">prove</b> lemma0: M in P <b style="color: red;">-&gt</b> M in PP <b style="color: red;">|</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(M, J){
					<b style="color: blue;">implies</b> M_in_P;
					L_in_PAIR, M_in_L = P_def(M)(M_in_P)<b style="color: red;">|</b>L<b style="color: red;">|</b>;
					<b style="color: blue;">return</b> <b style="color: green;">branch</b>(PAIR_def(L)(L_in_PAIR), L_equal_PP, L_equal_K){
						<b style="color: blue;">return</b> <b style="color: green;">or</b>(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: M in Q&gt](L, PP)(L_equal_PP)(M_in_L), &lt:<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(M, J)&gt);
					} <b style="color: green;">or</b> {
						M_in_K = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: M in Q&gt](L, K)(L_equal_K)(M_in_L);
						<b style="color: blue;">return</b> <b style="color: green;">or</b>(&lt:M in PP&gt, K_def(M)(M_in_K));
					};
				}
				<b style="color: blue;">prove</b> lemma1: M in PP <b style="color: red;">|</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(M, J) <b style="color: red;">-&gt</b> M in P{
					<b style="color: blue;">implies</b> either_premise;
					<b style="color: blue;">return</b> <b style="color: green;">branch</b>(either_premise, M_in_PP, M_equal_J){
						<b style="color: blue;">prove</b> M_in_P: <b style="color: red;">^</b>L(L in PAIR <b style="color: red;">&</b> M in L){
							<b style="color: blue;">choose</b> PP;
							<b style="color: blue;">return</b> PAIR_def(PP)(<b style="color: green;">or</b>(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets_reflexive.html';" onmouseover="popup_window(this, 'equal_sets_reflexive | 00_zf');" onmouseout="close_popup();">equal_sets_reflexive</b>(PP), &lt:<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(PP, K)&gt)), M_in_PP;
						}
						<b style="color: blue;">return</b> P_def(M)(M_in_P);
					} <b style="color: green;">or</b> {
						<b style="color: blue;">prove</b> M_in_P: <b style="color: red;">^</b>L(L in PAIR <b style="color: red;">&</b> M in L){
							<b style="color: blue;">choose</b> K;
							<b style="color: blue;">return</b> PAIR_def(K)(<b style="color: green;">or</b>(&lt:<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(K, PP)&gt, <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets_reflexive.html';" onmouseover="popup_window(this, 'equal_sets_reflexive | 00_zf');" onmouseout="close_popup();">equal_sets_reflexive</b>(K))), K_def(M)(M_equal_J);
						}
						<b style="color: blue;">return</b> P_def(M)(M_in_P);
					};
				}
				<b style="color: blue;">return</b> <b style="color: green;">iff</b>(lemma0, lemma1);
			}
			<b style="color: blue;">prove</b> P_subset_NT: <b style="color: red;">*</b>X(X in P <b style="color: red;">-&gt</b> X in NT){
				<b style="color: blue;">given</b> <b style="color: red;">|</b>X<b style="color: red;">|</b>;
				<b style="color: blue;">implies</b> X_in_P;
				<b style="color: blue;">return</b> <b style="color: green;">branch</b>(P_def(X)(X_in_P), X_in_PP, X_equal_J){
					<b style="color: blue;">return</b> <b style="color: green;">expand</b>(PP_subset_NT)(X)(X_in_PP);
				} <b style="color: green;">or</b> {
					<b style="color: blue;">return</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: Q in NT&gt](X, J)(X_equal_J)(J_in_NT);
				};
			}
			P_subset_NT = #<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_subset.html';" onmouseover="popup_window(this, 'is_subset | 00_zf');" onmouseout="close_popup();">is_subset</b>(P, NT)(P_subset_NT);
			P_in_PNT = <b style="color: green;">expand</b>(power_set_PNT)(P)(P_subset_NT);
			<b style="color: blue;">prove</b> P_recursive_part: <b style="color: red;">*</b>K(K in P <b style="color: red;">-&gt</b> <b style="color: red;">^</b>X<b style="color: red;">^</b>Y(<b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(X, Y, K) <b style="color: red;">&</b> ((<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(ZERO, X) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(A, Y)) <b style="color: red;">|</b> <b style="color: red;">^</b>PX<b style="color: red;">^</b>PY(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(PX, X) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(PY, Y, G) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(PX, PY, P))))){
				<b style="color: blue;">given</b> <b style="color: red;">|</b>K<b style="color: red;">|</b>;
				<b style="color: blue;">implies</b> K_in_P;
				<b style="color: blue;">return</b> <b style="color: green;">branch</b>(P_def(K)(K_in_P), K_in_PP, K_equal_J){
					tuple_K, either_K = <b style="color: green;">expand</b>(PP_recursive_part)(K)(K_in_PP)<b style="color: red;">|</b>KX, KY<b style="color: red;">|</b>;
					<b style="color: blue;">prove</b> rest_goal: <b style="color: red;">^</b>X<b style="color: red;">^</b>Y(<b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(X, Y, K) <b style="color: red;">&</b> ((<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(ZERO, X) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(A, Y)) <b style="color: red;">|</b> <b style="color: red;">^</b>PX<b style="color: red;">^</b>PY(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(PX, X) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(PY, Y, G) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(PX, PY, P)))){
						<b style="color: blue;">choose</b> KX, KY;
						<b style="color: blue;">return</b> <b style="color: green;">branch</b>(either_K, K_initial, K_predecessors){
							<b style="color: blue;">return</b> tuple_K, <b style="color: green;">or</b>(K_initial, &lt:<b style="color: red;">^</b>PX<b style="color: red;">^</b>PY(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(PX, KX) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(PY, KY, G) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(PX, PY, P))&gt);
						} <b style="color: green;">or</b> {
							predecessor_PKX, predecessor_PKY, related_PP = K_predecessors<b style="color: red;">|</b>PKX, PKY<b style="color: red;">|</b>;
							L_in_PP, tuple_L = <b style="color: green;">expand</b>(related_PP)<b style="color: red;">|</b>L<b style="color: red;">|</b>;
							L_in_P = P_def(L)(<b style="color: green;">or</b>(L_in_PP, &lt:<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(L, J)&gt));
							<b style="color: blue;">prove</b> related_P: <b style="color: red;">^</b>L(L in P <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(PKX, PKY, L)){
								<b style="color: blue;">choose</b> L;
								<b style="color: blue;">return</b> L_in_P, tuple_L;
							}
							related_P = #<b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(PKX, PKY, P)(related_P);
							<b style="color: blue;">prove</b> K_predecessors_P: <b style="color: red;">^</b>PKX<b style="color: red;">^</b>PKY(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(PKX, KX) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(PKY, KY, G) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(PKX, PKY, P)){
								<b style="color: blue;">choose</b> PKX, PKY;
								<b style="color: blue;">return</b> predecessor_PKX, predecessor_PKY, related_P;
							}
							<b style="color: blue;">return</b> tuple_K, <b style="color: green;">or</b>(&lt:<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(ZERO, KX) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(A, KY)&gt, K_predecessors_P);
						};
					}
					<b style="color: blue;">return</b> rest_goal;
				} <b style="color: green;">or</b> {
					<b style="color: blue;">prove</b> K_predecessors_P: <b style="color: red;">^</b>N<b style="color: red;">^</b>PY(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(N, N1) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(PY, Y, G) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(N, PY, P)){
						<b style="color: blue;">choose</b> N, PY;
						PJ_in_P = P_def(PJ)(<b style="color: green;">or</b>(PJ_in_PP, &lt:<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(PJ, J)&gt));
						<b style="color: blue;">prove</b> related_P: <b style="color: red;">^</b>PJ(PJ in P <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(N, PY, PJ)){
							<b style="color: blue;">choose</b> PJ;
							<b style="color: blue;">return</b> PJ_in_P, tuple_PJ;
						}
						related_P = #<b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(N, PY, P)(related_P);
						<b style="color: blue;">return</b> successor_N1, PY_related_Y, related_P;
					}
					<b style="color: blue;">prove</b> rest_goal: <b style="color: red;">^</b>X<b style="color: red;">^</b>Y(<b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(X, Y, K) <b style="color: red;">&</b> ((<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(ZERO, X) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(A, Y)) <b style="color: red;">|</b> <b style="color: red;">^</b>PX<b style="color: red;">^</b>PY(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(PX, X) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(PY, Y, G) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(PX, PY, P)))){
						<b style="color: blue;">choose</b> N1, Y;
						tuple_K = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(N1, Y, Q)&gt](K, J)(K_equal_J)(tuple_J);
						<b style="color: blue;">return</b> tuple_K, <b style="color: green;">or</b>(&lt:<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(ZERO, N1) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(A, Y)&gt, K_predecessors_P);
					}
					<b style="color: blue;">return</b> rest_goal;
				};
			}
			P_recursive_part = #is_recursive_part(P)(P_recursive_part);
			P_in_U = U_def(P)(P_in_PNT, P_recursive_part);
			J_in_P = P_def(J)(<b style="color: green;">or</b>(&lt:J in PP&gt, <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets_reflexive.html';" onmouseover="popup_window(this, 'equal_sets_reflexive | 00_zf');" onmouseout="close_popup();">equal_sets_reflexive</b>(J)));
			<b style="color: blue;">prove</b> J_in_F: <b style="color: red;">^</b>P(P in U <b style="color: red;">&</b> J in P){
				<b style="color: blue;">choose</b> P;
				<b style="color: blue;">return</b> P_in_U, J_in_P;
			}
			J_in_F = F_def(J)(J_in_F);
			<b style="color: blue;">prove</b> N1_related_Y: <b style="color: red;">^</b>J(J in F <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(N1, Y, J)){
				<b style="color: blue;">choose</b> J;
				<b style="color: blue;">return</b> J_in_F, tuple_J;
			}
			N1_related_Y = #<b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(N1, Y, F)(N1_related_Y);
			<b style="color: blue;">prove</b> R_cond: <b style="color: red;">^</b>Y(<b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(N1, Y, F)){
				<b style="color: blue;">choose</b> Y;
				<b style="color: blue;">return</b> N1_related_Y;
			}
			<b style="color: blue;">return</b> R_def(N1)(N1_in_NATURALS, R_cond);
		}

		NATURALS_subset_R = <b style="cursor: pointer;" onclick="window.location.href = '../03_addition/NATURALS_induction.html';" onmouseover="popup_window(this, 'NATURALS_induction | 03_addition');" onmouseout="close_popup();">NATURALS_induction</b>(R)(ZERO_in_R, closure_R);
		<b style="color: blue;">given</b> <b style="color: red;">|</b>N<b style="color: red;">|</b>;
		<b style="color: blue;">implies</b> N_in_NATURALS;
		N_in_R = <b style="color: green;">expand</b>(NATURALS_subset_R)(N)(N_in_NATURALS);
		N_in_NATURALS, result = R_def(N)(N_in_R);

		<b style="color: blue;">return</b> result;
	}

	domain_NATURALS = #<b style="cursor: pointer;" onclick="window.location.href = '../02_relations/is_domain.html';" onmouseover="popup_window(this, 'is_domain | 02_relations');" onmouseout="close_popup();">is_domain</b>(F, NATURALS)(covers_NATURALS);
	
	<b style="color: blue;">prove</b> F_recursive_part: <b style="color: red;">*</b>J(J in F <b style="color: red;">-&gt</b> <b style="color: red;">^</b>X<b style="color: red;">^</b>Y(<b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(X, Y, J) <b style="color: red;">&</b> ((<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(ZERO, X) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(A, Y)) <b style="color: red;">|</b> <b style="color: red;">^</b>PX<b style="color: red;">^</b>PY(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(PX, X) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(PY, Y, G) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(PX, PY, F))))){
		<b style="color: blue;">given</b> <b style="color: red;">|</b>J<b style="color: red;">|</b>;
		<b style="color: blue;">implies</b> J_in_F;
		P_in_U, J_in_P = F_def(J)(J_in_F)<b style="color: red;">|</b>P<b style="color: red;">|</b>;
		P_in_PNT, P_recursive_part = U_def(P)(P_in_U);
		tuple_J, either_P = <b style="color: green;">expand</b>(P_recursive_part)(J)(J_in_P)<b style="color: red;">|</b>X, Y<b style="color: red;">|</b>;
		<b style="color: blue;">choose</b> X, Y;
		<b style="color: blue;">return</b> tuple_J, <b style="color: green;">branch</b>(either_P, J_initial, J_predecessor_P){
			<b style="color: blue;">return</b> <b style="color: green;">or</b>(J_initial, &lt:<b style="color: red;">^</b>PX<b style="color: red;">^</b>PY(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(PX, X) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(PY, Y, G) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(PX, PY, F))&gt);
		} <b style="color: green;">or</b> {
			predecessor_PX, predecessor_PY, related_P = J_predecessor_P<b style="color: red;">|</b>PX, PY<b style="color: red;">|</b>;
			PJ_in_P, tuple_PJ = <b style="color: green;">expand</b>(related_P)<b style="color: red;">|</b>PJ<b style="color: red;">|</b>;
			<b style="color: blue;">prove</b> PJ_in_F: <b style="color: red;">^</b>P(P in U <b style="color: red;">&</b> PJ in P){
				<b style="color: blue;">choose</b> P;
				<b style="color: blue;">return</b> P_in_U, PJ_in_P;
			}
			PJ_in_F = F_def(PJ)(PJ_in_F);
			<b style="color: blue;">prove</b> related_F: <b style="color: red;">^</b>PJ(PJ in F <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(PX, PY, PJ)){
				<b style="color: blue;">choose</b> PJ;
				<b style="color: blue;">return</b> PJ_in_F, tuple_PJ;
			}
			related_F = #<b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(PX, PY, F)(related_F);
			<b style="color: blue;">prove</b> J_predecessor_F: <b style="color: red;">^</b>PX<b style="color: red;">^</b>PY(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(PX, X) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(PY, Y, G) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(PX, PY, F)){
				<b style="color: blue;">choose</b> PX, PY;
				<b style="color: blue;">return</b> predecessor_PX, predecessor_PY, related_F;
			}
			<b style="color: blue;">return</b> <b style="color: green;">or</b>(&lt:<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(ZERO, X) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(A, Y)&gt, J_predecessor_F);
		};
	}
	F_recursive_part = #is_recursive_part(F)(F_recursive_part);

	<b style="color: blue;">prove</b> recursive_part_is_function: <b style="color: red;">*</b>P(is_recursive_part(P) <b style="color: red;">-&gt</b> <b style="color: red;">*</b>X(X in NATURALS <b style="color: red;">-&gt</b> <b style="color: red;">*</b>Y0<b style="color: red;">*</b>Y1(<b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(X, Y0, P) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(X, Y1, P) <b style="color: red;">-&gt</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(Y0, Y1)))){
		<b style="color: blue;">given</b> <b style="color: red;">|</b>P<b style="color: red;">|</b>;
		<b style="color: blue;">implies</b> recursive_part_P;

		//We induct on X
		R_def = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/axiom_specify.html';" onmouseover="popup_window(this, 'axiom_specify | 00_zf');" onmouseout="close_popup();">axiom_specify</b>[&ltX: <b style="color: red;">*</b>Y0<b style="color: red;">*</b>Y1(<b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(X, Y0, P) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(X, Y1, P) <b style="color: red;">-&gt</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(Y0, Y1))&gt](NATURALS)<b style="color: red;">|</b>R<b style="color: red;">|</b>;

		<b style="color: blue;">prove</b> ZERO_in_R: <b style="color: red;">*</b>Y0<b style="color: red;">*</b>Y1(<b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(ZERO, Y0, P) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(ZERO, Y1, P) <b style="color: red;">-&gt</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(Y0, Y1)){
			<b style="color: blue;">given</b> <b style="color: red;">|</b>Y0, Y1<b style="color: red;">|</b>;
			<b style="color: blue;">implies</b> ZERO_related_Y0, ZERO_related_Y1;
			J0_in_P, tuple_J0 = <b style="color: green;">expand</b>(ZERO_related_Y0)<b style="color: red;">|</b>J0<b style="color: red;">|</b>;
			J1_in_P, tuple_J1 = <b style="color: green;">expand</b>(ZERO_related_Y1)<b style="color: red;">|</b>J1<b style="color: red;">|</b>;

			other_tuple_J0, either_J0 = <b style="color: green;">expand</b>(recursive_part_P)(J0)(J0_in_P)<b style="color: red;">|</b>OTHER_ZERO, OTHER_Y0<b style="color: red;">|</b>;
			equal_ZERO, equal_Y0 = <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/tuple_equal_condition.html';" onmouseover="popup_window(this, 'tuple_equal_condition | 01_sets');" onmouseout="close_popup();">tuple_equal_condition</b>(ZERO, Y0, OTHER_ZERO, OTHER_Y0, J0, J0)(tuple_J0, other_tuple_J0, <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets_reflexive.html';" onmouseover="popup_window(this, 'equal_sets_reflexive | 00_zf');" onmouseout="close_popup();">equal_sets_reflexive</b>(J0));
			either_J0 = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: (<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(ZERO, Q) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(A, OTHER_Y0)) <b style="color: red;">|</b> <b style="color: red;">^</b>PX<b style="color: red;">^</b>PY(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(PX, Q) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(PY, OTHER_Y0, G) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(PX, PY, P))&gt](ZERO, OTHER_ZERO)(equal_ZERO)(either_J0);
			either_J0 = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: (<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(ZERO, ZERO) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(A, Q)) <b style="color: red;">|</b> <b style="color: red;">^</b>PX<b style="color: red;">^</b>PY(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(PX, ZERO) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(PY, Q, G) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(PX, PY, P))&gt](Y0, OTHER_Y0)(equal_Y0)(either_J0);
			A_equal_Y0 = <b style="color: green;">branch</b>(either_J0, equal_initial, predecessor_exists){
				ZERO_equal_ZERO, A_equal_Y0 = equal_initial;
				<b style="color: blue;">return</b> A_equal_Y0;
			} <b style="color: green;">or</b> {
				predecessor_PX, PY_related_Y, PX_related_PY = predecessor_exists<b style="color: red;">|</b>PX, PY<b style="color: red;">|</b>;
				PX_in_ZERO = <b style="color: green;">expand</b>(predecessor_PX)(PX)(<b style="color: green;">or</b>(&lt:PX in PX&gt, <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets_reflexive.html';" onmouseover="popup_window(this, 'equal_sets_reflexive | 00_zf');" onmouseout="close_popup();">equal_sets_reflexive</b>(PX)));
				PX_in_EMPTY_SET = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: PX in Q&gt](EMPTY_SET, ZERO)(zero_definition)(PX_in_ZERO);
				absurdity = empty_set_condition(PX)(PX_in_EMPTY_SET);
				<b style="color: blue;">return</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/axiom_absurdity.html';" onmouseover="popup_window(this, 'axiom_absurdity | 00_zf');" onmouseout="close_popup();">axiom_absurdity</b>[&lt:<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(A, Y0)&gt](absurdity);
			};

			other_tuple_J1, either_J1 = <b style="color: green;">expand</b>(recursive_part_P)(J1)(J1_in_P)<b style="color: red;">|</b>OTHER_ZERO_2, OTHER_Y1<b style="color: red;">|</b>;
			equal_ZERO, equal_Y1 = <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/tuple_equal_condition.html';" onmouseover="popup_window(this, 'tuple_equal_condition | 01_sets');" onmouseout="close_popup();">tuple_equal_condition</b>(ZERO, Y1, OTHER_ZERO_2, OTHER_Y1, J1, J1)(tuple_J1, other_tuple_J1, <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets_reflexive.html';" onmouseover="popup_window(this, 'equal_sets_reflexive | 00_zf');" onmouseout="close_popup();">equal_sets_reflexive</b>(J1));
			either_J1 = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: (<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(ZERO, Q) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(A, OTHER_Y1)) <b style="color: red;">|</b> <b style="color: red;">^</b>PX<b style="color: red;">^</b>PY(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(PX, Q) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(PY, OTHER_Y1, G) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(PX, PY, P))&gt](ZERO, OTHER_ZERO_2)(equal_ZERO)(either_J1);
			either_J1 = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: (<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(ZERO, ZERO) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(A, Q)) <b style="color: red;">|</b> <b style="color: red;">^</b>PX<b style="color: red;">^</b>PY(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(PX, ZERO) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(PY, Q, G) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(PX, PY, P))&gt](Y1, OTHER_Y1)(equal_Y1)(either_J1);
			A_equal_Y1 = <b style="color: green;">branch</b>(either_J1, equal_initial, predecessor_exists){
				ZERO_equal_ZERO, A_equal_Y1 = equal_initial;
				<b style="color: blue;">return</b> A_equal_Y1;
			} <b style="color: green;">or</b> {
				predecessor_PX, PY_related_Y, PX_related_PY = predecessor_exists<b style="color: red;">|</b>PX, PY<b style="color: red;">|</b>;
				PX_in_ZERO = <b style="color: green;">expand</b>(predecessor_PX)(PX)(<b style="color: green;">or</b>(&lt:PX in PX&gt, <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets_reflexive.html';" onmouseover="popup_window(this, 'equal_sets_reflexive | 00_zf');" onmouseout="close_popup();">equal_sets_reflexive</b>(PX)));
				PX_in_EMPTY_SET = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: PX in Q&gt](EMPTY_SET, ZERO)(zero_definition)(PX_in_ZERO);
				absurdity = empty_set_condition(PX)(PX_in_EMPTY_SET);
				<b style="color: blue;">return</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/axiom_absurdity.html';" onmouseover="popup_window(this, 'axiom_absurdity | 00_zf');" onmouseout="close_popup();">axiom_absurdity</b>[&lt:<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(A, Y1)&gt](absurdity);
			};

			<b style="color: blue;">return</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets_transitive.html';" onmouseover="popup_window(this, 'equal_sets_transitive | 00_zf');" onmouseout="close_popup();">equal_sets_transitive</b>(Y0, A, Y1)(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets_symmetric.html';" onmouseover="popup_window(this, 'equal_sets_symmetric | 00_zf');" onmouseout="close_popup();">equal_sets_symmetric</b>(A, Y0)(A_equal_Y0), A_equal_Y1);
		}
		ZERO_in_R = R_def(ZERO)(zero_is_natural, ZERO_in_R);

		<b style="color: blue;">prove</b> closure_R: <b style="color: red;">*</b>N<b style="color: red;">*</b>N1(N in R <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(N, N1) <b style="color: red;">-&gt</b> N1 in R){
			<b style="color: blue;">given</b> <b style="color: red;">|</b>N, N1<b style="color: red;">|</b>;
			<b style="color: blue;">implies</b> N_in_R, successor_N1;
			N_in_NATURALS, N_cond = R_def(N)(N_in_R);
			N1_in_NATURALS = closure_naturals(N, N1)(N_in_NATURALS, successor_N1);
			N_in_N1 = <b style="color: green;">expand</b>(successor_N1)(N)(<b style="color: green;">or</b>(&lt:N in N&gt, <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets_reflexive.html';" onmouseover="popup_window(this, 'equal_sets_reflexive | 00_zf');" onmouseout="close_popup();">equal_sets_reflexive</b>(N)));
			<b style="color: blue;">prove</b> N1_cond: <b style="color: red;">*</b>Y0<b style="color: red;">*</b>Y1(<b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(N1, Y0, P) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(N1, Y1, P) <b style="color: red;">-&gt</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(Y0, Y1)){
				<b style="color: blue;">given</b> <b style="color: red;">|</b>Y0, Y1<b style="color: red;">|</b>;
				<b style="color: blue;">implies</b> N1_related_Y0, N1_related_Y1;
				J0_in_P, tuple_J0 = <b style="color: green;">expand</b>(N1_related_Y0)<b style="color: red;">|</b>J0<b style="color: red;">|</b>;
				J1_in_P, tuple_J1 = <b style="color: green;">expand</b>(N1_related_Y1)<b style="color: red;">|</b>J1<b style="color: red;">|</b>;

				other_tuple_J0, either_J0 = <b style="color: green;">expand</b>(recursive_part_P)(J0)(J0_in_P)<b style="color: red;">|</b>OTHER_N1, OTHER_Y0<b style="color: red;">|</b>;
				equal_N1, equal_Y0 = <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/tuple_equal_condition.html';" onmouseover="popup_window(this, 'tuple_equal_condition | 01_sets');" onmouseout="close_popup();">tuple_equal_condition</b>(N1, Y0, OTHER_N1, OTHER_Y0, J0, J0)(tuple_J0, other_tuple_J0, <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets_reflexive.html';" onmouseover="popup_window(this, 'equal_sets_reflexive | 00_zf');" onmouseout="close_popup();">equal_sets_reflexive</b>(J0));
				either_J0 = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: (<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(ZERO, Q) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(A, OTHER_Y0)) <b style="color: red;">|</b> <b style="color: red;">^</b>PX<b style="color: red;">^</b>PY(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(PX, Q) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(PY, OTHER_Y0, G) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(PX, PY, P))&gt](N1, OTHER_N1)(equal_N1)(either_J0);
				either_J0 = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: (<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(ZERO, N1) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(A, Q)) <b style="color: red;">|</b> <b style="color: red;">^</b>PX<b style="color: red;">^</b>PY(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(PX, N1) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(PY, Q, G) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(PX, PY, P))&gt](Y0, OTHER_Y0)(equal_Y0)(either_J0);
				predecessor_J0 = <b style="color: green;">branch</b>(either_J0, J0_initial, predecessor_J0){
					ZERO_equal_N1, A_equal_Y0 = J0_initial;
					N_in_ZERO = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: N in Q&gt](ZERO, N1)(ZERO_equal_N1)(N_in_N1);
					N_in_EMPTY_SET = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: N in Q&gt](EMPTY_SET, ZERO)(zero_definition)(N_in_ZERO);
					absurdity = empty_set_condition(N)(N_in_EMPTY_SET);
					<b style="color: blue;">return</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/axiom_absurdity.html';" onmouseover="popup_window(this, 'axiom_absurdity | 00_zf');" onmouseout="close_popup();">axiom_absurdity</b>[<b style="color: green;">right</b>(either_J0)](absurdity);
				} <b style="color: green;">or</b> {
					<b style="color: blue;">return</b> predecessor_J0;
				};

				other_tuple_J1, either_J1 = <b style="color: green;">expand</b>(recursive_part_P)(J1)(J1_in_P)<b style="color: red;">|</b>OTHER_N1_2, OTHER_Y1<b style="color: red;">|</b>;
				equal_N1, equal_Y1 = <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/tuple_equal_condition.html';" onmouseover="popup_window(this, 'tuple_equal_condition | 01_sets');" onmouseout="close_popup();">tuple_equal_condition</b>(N1, Y1, OTHER_N1_2, OTHER_Y1, J1, J1)(tuple_J1, other_tuple_J1, <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets_reflexive.html';" onmouseover="popup_window(this, 'equal_sets_reflexive | 00_zf');" onmouseout="close_popup();">equal_sets_reflexive</b>(J1));
				either_J1 = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: (<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(ZERO, Q) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(A, OTHER_Y1)) <b style="color: red;">|</b> <b style="color: red;">^</b>PX<b style="color: red;">^</b>PY(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(PX, Q) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(PY, OTHER_Y1, G) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(PX, PY, P))&gt](N1, OTHER_N1_2)(equal_N1)(either_J1);
				either_J1 = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: (<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(ZERO, N1) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(A, Q)) <b style="color: red;">|</b> <b style="color: red;">^</b>PX<b style="color: red;">^</b>PY(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(PX, N1) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(PY, Q, G) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(PX, PY, P))&gt](Y1, OTHER_Y1)(equal_Y1)(either_J1);
				predecessor_J1 = <b style="color: green;">branch</b>(either_J1, J1_initial, predecessor_J1){
					ZERO_equal_N1, A_equal_Y1 = J1_initial;
					N_in_ZERO = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: N in Q&gt](ZERO, N1)(ZERO_equal_N1)(N_in_N1);
					N_in_EMPTY_SET = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: N in Q&gt](EMPTY_SET, ZERO)(zero_definition)(N_in_ZERO);
					absurdity = empty_set_condition(N)(N_in_EMPTY_SET);
					<b style="color: blue;">return</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/axiom_absurdity.html';" onmouseover="popup_window(this, 'axiom_absurdity | 00_zf');" onmouseout="close_popup();">axiom_absurdity</b>[<b style="color: green;">right</b>(either_J1)](absurdity);
				} <b style="color: green;">or</b> {
					<b style="color: blue;">return</b> predecessor_J1;
				};

				predecessor_PX0, predecessor_PY0, PX0_related_PY0 = predecessor_J0<b style="color: red;">|</b>PX0, PY0<b style="color: red;">|</b>;
				predecessor_PX1, predecessor_PY1, PX1_related_PY1 = predecessor_J1<b style="color: red;">|</b>PX1, PY1<b style="color: red;">|</b>;
				PX0_equal_N = <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/predecessor_unique.html';" onmouseover="popup_window(this, 'predecessor_unique | 01_sets');" onmouseout="close_popup();">predecessor_unique</b>(PX0, N, N1)(predecessor_PX0, successor_N1);
				PX1_equal_N = <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/predecessor_unique.html';" onmouseover="popup_window(this, 'predecessor_unique | 01_sets');" onmouseout="close_popup();">predecessor_unique</b>(PX1, N, N1)(predecessor_PX1, successor_N1);
				N_related_PY0 = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(Q, PY0, P)&gt](PX0, N)(PX0_equal_N)(PX0_related_PY0);
				N_related_PY1 = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(Q, PY1, P)&gt](PX1, N)(PX1_equal_N)(PX1_related_PY1);
				PY0_equal_PY1 = N_cond(PY0, PY1)(N_related_PY0, N_related_PY1);
				other_predecessor_PY1 = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(Q, Y1, G)&gt](PY0, PY1)(PY0_equal_PY1)(predecessor_PY1);
				<b style="color: blue;">return</b> <b style="color: green;">expand</b>(function_G)(PY0, Y0, Y1)(predecessor_PY0, other_predecessor_PY1);
			}
			<b style="color: blue;">return</b> R_def(N1)(N1_in_NATURALS, N1_cond);
		}

		NATURALS_subset_R = <b style="cursor: pointer;" onclick="window.location.href = '../03_addition/NATURALS_induction.html';" onmouseover="popup_window(this, 'NATURALS_induction | 03_addition');" onmouseout="close_popup();">NATURALS_induction</b>(R)(ZERO_in_R, closure_R);
		<b style="color: blue;">given</b> <b style="color: red;">|</b>X<b style="color: red;">|</b>;
		<b style="color: blue;">implies</b> X_in_NATURALS;
		X_in_R = <b style="color: green;">expand</b>(NATURALS_subset_R)(X)(X_in_NATURALS);
		X_in_NATURALS, result = R_def(X)(X_in_R);
		<b style="color: blue;">return</b> result;
	}

	<b style="color: blue;">prove</b> F_is_function: <b style="color: red;">*</b>X<b style="color: red;">*</b>Y0<b style="color: red;">*</b>Y1(<b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(X, Y0, F) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(X, Y1, F) <b style="color: red;">-&gt</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(Y0, Y1)){
		<b style="color: blue;">given</b> <b style="color: red;">|</b>X, Y0, Y1<b style="color: red;">|</b>;
		<b style="color: blue;">implies</b> X_related_Y0, X_related_Y1;
		J_in_F, tuple_J = <b style="color: green;">expand</b>(X_related_Y0)<b style="color: red;">|</b>J<b style="color: red;">|</b>;
		P_in_U, J_in_P = F_def(J)(J_in_F)<b style="color: red;">|</b>P<b style="color: red;">|</b>;
		P_in_PNT, P_recursive = U_def(P)(P_in_U);
		P_subset_NT = <b style="color: green;">expand</b>(power_set_PNT)(P)(P_in_PNT);
		J_in_NT = <b style="color: green;">expand</b>(P_subset_NT)(J)(J_in_P);
		OTHER_X_in_NATURALS, OTHER_Y0_in_T, other_tuple_J = <b style="color: green;">expand</b>(cross_product_NT)(J)(J_in_NT)<b style="color: red;">|</b>OTHER_X, OTHER_Y0<b style="color: red;">|</b>;
		equal_X, equal_Y0 = <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/tuple_equal_condition.html';" onmouseover="popup_window(this, 'tuple_equal_condition | 01_sets');" onmouseout="close_popup();">tuple_equal_condition</b>(X, Y0, OTHER_X, OTHER_Y0, J, J)(tuple_J, other_tuple_J, <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets_reflexive.html';" onmouseover="popup_window(this, 'equal_sets_reflexive | 00_zf');" onmouseout="close_popup();">equal_sets_reflexive</b>(J));
		X_in_NATURALS = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: Q in NATURALS&gt](X, OTHER_X)(equal_X)(OTHER_X_in_NATURALS);
		<b style="color: blue;">return</b> recursive_part_is_function(F)(F_recursive_part)(X)(X_in_NATURALS)(Y0, Y1)(X_related_Y0, X_related_Y1);
	}
	F_is_function = #<b style="cursor: pointer;" onclick="window.location.href = '../02_relations/is_function.html';" onmouseover="popup_window(this, 'is_function | 02_relations');" onmouseout="close_popup();">is_function</b>(F)(F_is_function);

	<b style="color: blue;">prove</b> F_recursive: <b style="color: red;">*</b>N<b style="color: red;">*</b>N1<b style="color: red;">*</b>U<b style="color: red;">*</b>V(N in NATURALS <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(N, N1) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(N, U, F) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(N1, V, F) <b style="color: red;">-&gt</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(U, V, G)){
		<b style="color: blue;">given</b> <b style="color: red;">|</b>N, N1, U, V<b style="color: red;">|</b>;
		<b style="color: blue;">implies</b> N_in_NATURALS, successor_N1, N_related_U, N1_related_V;
		N_in_N1 = <b style="color: green;">expand</b>(successor_N1)(N)(<b style="color: green;">or</b>(&lt:N in N&gt, <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets_reflexive.html';" onmouseover="popup_window(this, 'equal_sets_reflexive | 00_zf');" onmouseout="close_popup();">equal_sets_reflexive</b>(N)));
		J1_in_F, tuple_J1 = <b style="color: green;">expand</b>(N1_related_V)<b style="color: red;">|</b>J1<b style="color: red;">|</b>;
		other_tuple_J1, either_J1 = <b style="color: green;">expand</b>(F_recursive_part)(J1)(J1_in_F)<b style="color: red;">|</b>OTHER_N1, OTHER_V<b style="color: red;">|</b>;
		equal_N1, equal_V = <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/tuple_equal_condition.html';" onmouseover="popup_window(this, 'tuple_equal_condition | 01_sets');" onmouseout="close_popup();">tuple_equal_condition</b>(N1, V, OTHER_N1, OTHER_V, J1, J1)(tuple_J1, other_tuple_J1, <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets_reflexive.html';" onmouseover="popup_window(this, 'equal_sets_reflexive | 00_zf');" onmouseout="close_popup();">equal_sets_reflexive</b>(J1));
		either_J1 = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: (<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(ZERO, Q) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(A, OTHER_V)) <b style="color: red;">|</b> <b style="color: red;">^</b>PN<b style="color: red;">^</b>PV(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(PN, Q) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(PV, OTHER_V, G) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(PN, PV, F))&gt](N1, OTHER_N1)(equal_N1)(either_J1);
		either_J1 = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: (<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(ZERO, N1) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(A, Q)) <b style="color: red;">|</b> <b style="color: red;">^</b>PN<b style="color: red;">^</b>PV(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(PN, N1) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(PV, Q, G) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(PN, PV, F))&gt](V, OTHER_V)(equal_V)(either_J1);
		predecessor_J1 = <b style="color: green;">branch</b>(either_J1, initial_J1, predecessor_J1){
			ZERO_equal_N1, A_equal_V = initial_J1;
			N_in_ZERO = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: N in Q&gt](ZERO, N1)(ZERO_equal_N1)(N_in_N1);
			N_in_EMPTY_SET = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: N in Q&gt](EMPTY_SET, ZERO)(zero_definition)(N_in_ZERO);
			absurdity = empty_set_condition(N)(N_in_EMPTY_SET);
			<b style="color: blue;">return</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/axiom_absurdity.html';" onmouseover="popup_window(this, 'axiom_absurdity | 00_zf');" onmouseout="close_popup();">axiom_absurdity</b>[<b style="color: green;">right</b>(either_J1)](absurdity);
		} <b style="color: green;">or</b> {
			<b style="color: blue;">return</b> predecessor_J1;
		};

		predecessor_PN1, predecessor_PV, PN1_related_PV = predecessor_J1<b style="color: red;">|</b>PN1, PV<b style="color: red;">|</b>;
		PN1_equal_N = <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/predecessor_unique.html';" onmouseover="popup_window(this, 'predecessor_unique | 01_sets');" onmouseout="close_popup();">predecessor_unique</b>(PN1, N, N1)(predecessor_PN1, successor_N1);
		N_related_PV = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(Q, PV, F)&gt](PN1, N)(PN1_equal_N)(PN1_related_PV);
		U_equal_PV = <b style="color: green;">expand</b>(F_is_function)(N, U, PV)(N_related_U, N_related_PV);
		<b style="color: blue;">return</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(Q, V, G)&gt](U, PV)(U_equal_PV)(predecessor_PV);
	}

	<b style="color: blue;">prove</b> codomain_T: <b style="color: red;">*</b>X<b style="color: red;">*</b>Y(<b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(X, Y, F) <b style="color: red;">-&gt</b> Y in T){
		<b style="color: blue;">given</b> <b style="color: red;">|</b>X, Y<b style="color: red;">|</b>;
		<b style="color: blue;">implies</b> X_related_Y;
		J_in_F, tuple_J = <b style="color: green;">expand</b>(X_related_Y)<b style="color: red;">|</b>J<b style="color: red;">|</b>;
		P_in_U, J_in_P = F_def(J)(J_in_F)<b style="color: red;">|</b>P<b style="color: red;">|</b>;
		P_in_PNT, P_recursive = U_def(P)(P_in_U);
		P_subset_NT = <b style="color: green;">expand</b>(power_set_PNT)(P)(P_in_PNT);
		J_in_NT = <b style="color: green;">expand</b>(P_subset_NT)(J)(J_in_P);
		OTHER_X_in_NATURALS, OTHER_Y_in_T, other_tuple_J = <b style="color: green;">expand</b>(cross_product_NT)(J)(J_in_NT)<b style="color: red;">|</b>OTHER_X, OTHER_Y<b style="color: red;">|</b>;
		equal_X, equal_Y = <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/tuple_equal_condition.html';" onmouseover="popup_window(this, 'tuple_equal_condition | 01_sets');" onmouseout="close_popup();">tuple_equal_condition</b>(X, Y, OTHER_X, OTHER_Y, J, J)(tuple_J, other_tuple_J, <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets_reflexive.html';" onmouseover="popup_window(this, 'equal_sets_reflexive | 00_zf');" onmouseout="close_popup();">equal_sets_reflexive</b>(J));
		<b style="color: blue;">return</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: Q in T&gt](Y, OTHER_Y)(equal_Y)(OTHER_Y_in_T);
	}
	codomain_T = #<b style="cursor: pointer;" onclick="window.location.href = '../02_relations/is_codomain.html';" onmouseover="popup_window(this, 'is_codomain | 02_relations');" onmouseout="close_popup();">is_codomain</b>(F, T)(codomain_T);

	<b style="color: blue;">return</b> #<b style="cursor: pointer;" onclick="window.location.href = '../03_addition/is_recursively_defined_naturals.html';" onmouseover="popup_window(this, 'is_recursively_defined_naturals | 03_addition');" onmouseout="close_popup();">is_recursively_defined_naturals</b>(T, A, G, F)(F_is_function, domain_NATURALS, codomain_T, ZERO_related_A, F_recursive);
}</code></div></div></body>
<div id="popup" style="display: none; position: absolute; padding: 2px; border: 2px solid black; border-radius: 2px; background: white;"></div>
<script type="text/javascript">
popup = document.getElementById("popup");
function popup_window(dom, text){
	rect = dom.getBoundingClientRect()
	popup.innerHTML = text;
	popup.style.top = rect.bottom + window.scrollY + 5 + "px";
	popup.style.left = rect.left + window.scrollX + "px";
	popup.style.display = "inline-block";
}
function close_popup(){
	popup.style.display = "none";
}
</script>
</html>