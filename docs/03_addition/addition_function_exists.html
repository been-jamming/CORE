<!DOCTYPE html><html><head><title>CORE result</title><link rel="stylesheet" href="../style.css"></link><link rel="stylesheet" href="https://fontlibrary.org/face/pixelated" type="text/css"></link></head><body><h1 style="font-size: 4vw">CORE library</h1><div class="page_body"><div class="card"><b>Result type</b>: proof<br><b>Result name</b>: addition_function_exists<br><b>Description</b>: Prove that addition exists!<br>There are a lot of irrelevant results and definitions that need to be made for this proof<br>So I encapsulated them inside of this very large proof<br>The definition of an "addition function" characterizes the peano axioms of arithmetic<br><br><b>Source</b>:<br><br><code style="white-space: pre-wrap; cursor: default;"><b style="color: blue;">prove</b> <b style="cursor: pointer;" onclick="window.location.href = '../03_addition/addition_function_exists.html';" onmouseover="popup_window(this, 'addition_function_exists | 03_addition');" onmouseout="close_popup();">addition_function_exists</b>: <b style="color: red;">^</b>ADDITION_FUNCTION(<b style="cursor: pointer;" onclick="window.location.href = '../03_addition/is_addition_function.html';" onmouseover="popup_window(this, 'is_addition_function | 03_addition');" onmouseout="close_popup();">is_addition_function</b>(ADDITION_FUNCTION)){
	C_cross_product = <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/cross_product.html';" onmouseover="popup_window(this, 'cross_product | 01_sets');" onmouseout="close_popup();">cross_product</b>(NATURALS, NATURALS)<b style="color: red;">|</b>C<b style="color: red;">|</b>;
	C_def = <b style="color: green;">expand</b>(C_cross_product);
	empty_in_naturals, closure_naturals = <b style="color: green;">expand</b>(<b style="cursor: pointer;" onclick="window.location.href = '../03_addition/NATURALS_inductive.html';" onmouseover="popup_window(this, 'NATURALS_inductive | 03_addition');" onmouseout="close_popup();">NATURALS_inductive</b>);
	
	//We <b style="color: blue;">define</b> an "addition class" to be the inverse image of the addition function for some N.
	//However, we construct it in an alternative way, which allows us to <b style="color: blue;">define</b> addition
	//Despite the recursive definition of an addition function.

	//When A is the addition class for a natural number N
	<b style="color: blue;">define</b> is_addition_class(N, A): <b style="color: red;">*</b>B(B in A <b style="color: red;">&lt-&gt</b> <b style="color: red;">^</b>C<b style="color: red;">^</b>D(<b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(C, D, B) <b style="color: red;">&</b> ((<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(C, ZERO) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(D, N)) <b style="color: red;">|</b> <b style="color: red;">^</b>P<b style="color: red;">^</b>S<b style="color: red;">^</b>T(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(P, C) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(D, S) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(P, S, T) <b style="color: red;">&</b> T in A))));

	//The second lemma for this theorem is that the addition classes exist for all natural numbers
	<b style="color: blue;">prove</b> addition_classes_exist: <b style="color: red;">*</b>N(N in NATURALS <b style="color: red;">-&gt</b> <b style="color: red;">^</b>A(is_addition_class(N, A) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_subset.html';" onmouseover="popup_window(this, 'is_subset | 00_zf');" onmouseout="close_popup();">is_subset</b>(A, C))){
		//We proceed by induction
		R_def = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/axiom_specify.html';" onmouseover="popup_window(this, 'axiom_specify | 00_zf');" onmouseout="close_popup();">axiom_specify</b>[&ltN: <b style="color: red;">^</b>A(is_addition_class(N, A) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_subset.html';" onmouseover="popup_window(this, 'is_subset | 00_zf');" onmouseout="close_popup();">is_subset</b>(A, C))&gt](NATURALS)<b style="color: red;">|</b>R<b style="color: red;">|</b>;
		//Base case
		<b style="color: blue;">prove</b> ZERO_in_R: <b style="color: red;">^</b>A(is_addition_class(ZERO, A) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_subset.html';" onmouseover="popup_window(this, 'is_subset | 00_zf');" onmouseout="close_popup();">is_subset</b>(A, C)){
			A_def = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/axiom_specify.html';" onmouseover="popup_window(this, 'axiom_specify | 00_zf');" onmouseout="close_popup();">axiom_specify</b>[&ltS: <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(ZERO, ZERO, S)&gt](C)<b style="color: red;">|</b>A<b style="color: red;">|</b>;
			<b style="color: blue;">choose</b> A;
			<b style="color: blue;">prove</b> addition_class_def: <b style="color: red;">*</b>B(B in A <b style="color: red;">&lt-&gt</b> <b style="color: red;">^</b>C<b style="color: red;">^</b>D(<b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(C, D, B) <b style="color: red;">&</b> ((<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(C, ZERO) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(D, ZERO)) <b style="color: red;">|</b> <b style="color: red;">^</b>P<b style="color: red;">^</b>S<b style="color: red;">^</b>T(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(P, C) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(D, S) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(P, S, T) <b style="color: red;">&</b> T in A)))){
				<b style="color: blue;">given</b> <b style="color: red;">|</b>B<b style="color: red;">|</b>;
				<b style="color: blue;">prove</b> lemma0: B in A <b style="color: red;">-&gt</b> <b style="color: red;">^</b>C<b style="color: red;">^</b>D(<b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(C, D, B) <b style="color: red;">&</b> ((<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(C, ZERO) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(D, ZERO)) <b style="color: red;">|</b> <b style="color: red;">^</b>P<b style="color: red;">^</b>S<b style="color: red;">^</b>T(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(P, C) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(D, S) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(P, S, T) <b style="color: red;">&</b> T in A))){
					<b style="color: blue;">implies</b> B_in_A;
					B_in_C, B_tuple_ZERO_ZERO = A_def(B)(B_in_A);
					<b style="color: blue;">choose</b> ZERO, ZERO;
					condition = <b style="color: green;">or</b>(<b style="color: green;">and</b>(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets_reflexive.html';" onmouseover="popup_window(this, 'equal_sets_reflexive | 00_zf');" onmouseout="close_popup();">equal_sets_reflexive</b>(ZERO), <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets_reflexive.html';" onmouseover="popup_window(this, 'equal_sets_reflexive | 00_zf');" onmouseout="close_popup();">equal_sets_reflexive</b>(ZERO)), &lt:<b style="color: red;">^</b>P<b style="color: red;">^</b>S<b style="color: red;">^</b>T(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(P, ZERO) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(ZERO, S) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(P, S, T) <b style="color: red;">&</b> T in A)&gt);
					<b style="color: blue;">return</b> B_tuple_ZERO_ZERO, condition;
				}
				<b style="color: blue;">prove</b> lemma1: <b style="color: red;">^</b>C<b style="color: red;">^</b>D(<b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(C, D, B) <b style="color: red;">&</b> ((<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(C, ZERO) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(D, ZERO)) <b style="color: red;">|</b> <b style="color: red;">^</b>P<b style="color: red;">^</b>S<b style="color: red;">^</b>T(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(P, C) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(D, S) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(P, S, T) <b style="color: red;">&</b> T in A))) <b style="color: red;">-&gt</b> B in A{
					<b style="color: blue;">implies</b> premise;
					tuple_B, either_condition = premise<b style="color: red;">|</b>C, D<b style="color: red;">|</b>;
					<b style="color: blue;">return</b> <b style="color: green;">branch</b>(either_condition, equal_ZERO, predecessor){
						C_equal_ZERO, D_equal_ZERO = equal_ZERO;
						B_tuple_ZERO_D = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltS: <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(S, D, B)&gt](C, ZERO)(C_equal_ZERO)(tuple_B);
						B_tuple_ZERO_ZERO = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltS: <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(ZERO, S, B)&gt](D, ZERO)(D_equal_ZERO)(B_tuple_ZERO_D);
						<b style="color: blue;">prove</b> cross_product_condition: <b style="color: red;">^</b>E<b style="color: red;">^</b>F(E in NATURALS <b style="color: red;">&</b> F in NATURALS <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(E, F, B)){
							<b style="color: blue;">choose</b> ZERO, ZERO;
							<b style="color: blue;">return</b> zero_is_natural, zero_is_natural, B_tuple_ZERO_ZERO;
						}
						B_in_C = C_def(B)(cross_product_condition);
						<b style="color: blue;">return</b> A_def(B)(B_in_C, B_tuple_ZERO_ZERO);
					} <b style="color: green;">or</b> {
						predecessor_P, successor_S, tuple_T, T_in_A = predecessor<b style="color: red;">|</b>P, S, T<b style="color: red;">|</b>;
						D_in_S = <b style="color: green;">expand</b>(successor_S)(D)(<b style="color: green;">or</b>(&lt:D in D&gt, <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets_reflexive.html';" onmouseover="popup_window(this, 'equal_sets_reflexive | 00_zf');" onmouseout="close_popup();">equal_sets_reflexive</b>(D)));
						T_in_C, tuple_ZERO_ZERO = A_def(T)(T_in_A);
						T_equal_T = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets_reflexive.html';" onmouseover="popup_window(this, 'equal_sets_reflexive | 00_zf');" onmouseout="close_popup();">equal_sets_reflexive</b>(T);
						equal_P_ZERO, equal_S_ZERO = <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/tuple_equal_condition.html';" onmouseover="popup_window(this, 'tuple_equal_condition | 01_sets');" onmouseout="close_popup();">tuple_equal_condition</b>(P, S, ZERO, ZERO, T, T)(tuple_T, tuple_ZERO_ZERO, T_equal_T);
						equal_S_EMPTY_SET = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets_transitive.html';" onmouseover="popup_window(this, 'equal_sets_transitive | 00_zf');" onmouseout="close_popup();">equal_sets_transitive</b>(S, ZERO, EMPTY_SET)(equal_S_ZERO, <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets_symmetric.html';" onmouseover="popup_window(this, 'equal_sets_symmetric | 00_zf');" onmouseout="close_popup();">equal_sets_symmetric</b>(EMPTY_SET, ZERO)(zero_definition));
						D_in_EMPTY_SET = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltU: D in U&gt](S, EMPTY_SET)(equal_S_EMPTY_SET)(D_in_S);
						absurdity = empty_set_condition(D)(D_in_EMPTY_SET);
						<b style="color: blue;">return</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/axiom_absurdity.html';" onmouseover="popup_window(this, 'axiom_absurdity | 00_zf');" onmouseout="close_popup();">axiom_absurdity</b>[goal](absurdity);
					};
				}
				<b style="color: blue;">return</b> <b style="color: green;">iff</b>(lemma0, lemma1);
			}
			addition_class = #is_addition_class(ZERO, A)(addition_class_def);
			<b style="color: blue;">prove</b> subset_def: <b style="color: red;">*</b>X(X in A <b style="color: red;">-&gt</b> X in C){
				<b style="color: blue;">given</b> <b style="color: red;">|</b>X<b style="color: red;">|</b>;
				<b style="color: blue;">implies</b> X_in_A;
				X_in_C, tuple_X = A_def(X)(X_in_A);
				<b style="color: blue;">return</b> X_in_C;
			}
			A_subset_C = #<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_subset.html';" onmouseover="popup_window(this, 'is_subset | 00_zf');" onmouseout="close_popup();">is_subset</b>(A, C)(subset_def);
			<b style="color: blue;">return</b> addition_class, A_subset_C;
		}
		ZERO_in_R = R_def(ZERO)(zero_is_natural, ZERO_in_R);
		//Inductive step
		<b style="color: blue;">prove</b> closure_R: <b style="color: red;">*</b>Y<b style="color: red;">*</b>Z(Y in R <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(Y, Z) <b style="color: red;">-&gt</b> Z in R){
			<b style="color: blue;">given</b> <b style="color: red;">|</b>Y, Y_1<b style="color: red;">|</b>;
			<b style="color: blue;">implies</b> Y_in_R, successor_Y_1;
			Y_in_NATURALS, both = R_def(Y)(Y_in_R);
			Y_1_in_NATURALS = closure_naturals(Y, Y_1)(Y_in_NATURALS, successor_Y_1);
			addition_class, F_subset_C = both<b style="color: red;">|</b>F<b style="color: red;">|</b>;
			F_addition_class = <b style="color: green;">expand</b>(addition_class);
			G_def = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/axiom_specify.html';" onmouseover="popup_window(this, 'axiom_specify | 00_zf');" onmouseout="close_popup();">axiom_specify</b>[&ltQ: <b style="color: red;">^</b>C<b style="color: red;">^</b>D(<b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(C, D, Q) <b style="color: red;">&</b> ((<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(C, ZERO) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(D, Y_1)) <b style="color: red;">|</b> <b style="color: red;">^</b>C_NEG1<b style="color: red;">^</b>T(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(C_NEG1, C) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(C_NEG1, D, T) <b style="color: red;">&</b> T in F)))&gt](C)<b style="color: red;">|</b>G<b style="color: red;">|</b>;
			<b style="color: blue;">prove</b> G_addition_class: <b style="color: red;">*</b>B(B in G <b style="color: red;">&lt-&gt</b> <b style="color: red;">^</b>C<b style="color: red;">^</b>D(<b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(C, D, B) <b style="color: red;">&</b> ((<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(C, ZERO) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(D, Y_1)) <b style="color: red;">|</b> <b style="color: red;">^</b>C_NEG1<b style="color: red;">^</b>D_1<b style="color: red;">^</b>T(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(C_NEG1, C) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(D, D_1) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(C_NEG1, D_1, T) <b style="color: red;">&</b> T in G)))){
				<b style="color: blue;">given</b> <b style="color: red;">|</b>B<b style="color: red;">|</b>;
				<b style="color: blue;">prove</b> lemma0: B in G <b style="color: red;">-&gt</b> <b style="color: red;">^</b>C<b style="color: red;">^</b>D(<b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(C, D, B) <b style="color: red;">&</b> ((<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(C, ZERO) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(D, Y_1)) <b style="color: red;">|</b> <b style="color: red;">^</b>C_NEG1<b style="color: red;">^</b>D_1<b style="color: red;">^</b>T(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(C_NEG1, C) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(D, D_1) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(C_NEG1, D_1, T) <b style="color: red;">&</b> T in G))){
					<b style="color: blue;">implies</b> B_in_G;
					B_in_C, B_condition = G_def(B)(B_in_G);
					tuple_B, either_B = B_condition<b style="color: red;">|</b>C, D<b style="color: red;">|</b>;
					C_OTHER_in_NATURALS, D_OTHER_in_NATURALS, tuple_B_other = C_def(B)(B_in_C)<b style="color: red;">|</b>C_OTHER, D_OTHER<b style="color: red;">|</b>;
					C_equal, D_equal = <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/tuple_equal_condition.html';" onmouseover="popup_window(this, 'tuple_equal_condition | 01_sets');" onmouseout="close_popup();">tuple_equal_condition</b>(C, D, C_OTHER, D_OTHER, B, B)(tuple_B, tuple_B_other, <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets_reflexive.html';" onmouseover="popup_window(this, 'equal_sets_reflexive | 00_zf');" onmouseout="close_popup();">equal_sets_reflexive</b>(B));
					C_in_NATURALS = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: Q in NATURALS&gt](C, C_OTHER)(C_equal)(C_OTHER_in_NATURALS);
					D_in_NATURALS = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: Q in NATURALS&gt](D, D_OTHER)(D_equal)(D_OTHER_in_NATURALS);
					<b style="color: blue;">choose</b> C, D;
					<b style="color: blue;">return</b> <b style="color: green;">branch</b>(either_B, equal_initial, predecessor_exists){
						<b style="color: blue;">return</b> tuple_B, <b style="color: green;">or</b>(equal_initial, &lt:<b style="color: red;">^</b>C_NEG1<b style="color: red;">^</b>D_1<b style="color: red;">^</b>T(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(C_NEG1, C) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(D, D_1) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(C_NEG1, D_1, T) <b style="color: red;">&</b> T in G)&gt);
					} <b style="color: green;">or</b> {
						predecessor_C_NEG1, tuple_T0, T0_in_F = predecessor_exists<b style="color: red;">|</b>C_NEG1, T0<b style="color: red;">|</b>;
						tuple_T0_other, either_T0 = F_addition_class(T0)(T0_in_F)<b style="color: red;">|</b>C_NEG1_OTHER, D_OTHER<b style="color: red;">|</b>;
						equal_C_NEG1, equal_D = <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/tuple_equal_condition.html';" onmouseover="popup_window(this, 'tuple_equal_condition | 01_sets');" onmouseout="close_popup();">tuple_equal_condition</b>(C_NEG1, D, C_NEG1_OTHER, D_OTHER, T0, T0)(tuple_T0, tuple_T0_other, <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets_reflexive.html';" onmouseover="popup_window(this, 'equal_sets_reflexive | 00_zf');" onmouseout="close_popup();">equal_sets_reflexive</b>(T0));
						//D_OTHER is a different object, so I overwrite this variable in this scope because I use it later
						D_OTHER_in_NATURALS = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: Q in NATURALS&gt](D, D_OTHER)(equal_D)(D_in_NATURALS);
						<b style="color: blue;">return</b> <b style="color: green;">branch</b>(either_T0, equal_initial, predecessor_exists){
							equal_C_NEG1_OTHER_ZERO, equal_D_OTHER_Y = equal_initial;
							equal_C_NEG1_ZERO = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets_transitive.html';" onmouseover="popup_window(this, 'equal_sets_transitive | 00_zf');" onmouseout="close_popup();">equal_sets_transitive</b>(C_NEG1, C_NEG1_OTHER, ZERO)(equal_C_NEG1, equal_C_NEG1_OTHER_ZERO);
							equal_D_Y = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets_transitive.html';" onmouseover="popup_window(this, 'equal_sets_transitive | 00_zf');" onmouseout="close_popup();">equal_sets_transitive</b>(D, D_OTHER, Y)(equal_D, equal_D_OTHER_Y);
							successor_D_1 = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/successor.html';" onmouseover="popup_window(this, 'successor | 00_zf');" onmouseout="close_popup();">successor</b>(D)<b style="color: red;">|</b>D_1<b style="color: red;">|</b>;
							successor_D_1_Y = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(Q, D_1)&gt](D, Y)(equal_D_Y)(successor_D_1);
							equal_D_1_Y_1 = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/successor_unique.html';" onmouseover="popup_window(this, 'successor_unique | 00_zf');" onmouseout="close_popup();">successor_unique</b>(Y, D_1, Y_1)(successor_D_1_Y, successor_Y_1);
							tuple_T = <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/tuple.html';" onmouseover="popup_window(this, 'tuple | 01_sets');" onmouseout="close_popup();">tuple</b>(C_NEG1, D_1)<b style="color: red;">|</b>T<b style="color: red;">|</b>;
							C_NEG1_in_NATURALS = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: Q in NATURALS&gt](C_NEG1, ZERO)(equal_C_NEG1_ZERO)(zero_is_natural);
							D_1_in_NATURALS = closure_naturals(Y, D_1)(Y_in_NATURALS, successor_D_1_Y);
							<b style="color: blue;">prove</b> T_in_G: <b style="color: red;">^</b>C<b style="color: red;">^</b>D(<b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(C, D, T) <b style="color: red;">&</b> ((<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(C, ZERO) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(D, Y_1)) <b style="color: red;">|</b> <b style="color: red;">^</b>C_NEG1<b style="color: red;">^</b>T(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(C_NEG1, C) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(C_NEG1, D, T) <b style="color: red;">&</b> T in F))){
								<b style="color: blue;">choose</b> C_NEG1, D_1;
								<b style="color: blue;">return</b> tuple_T, <b style="color: green;">or</b>(<b style="color: green;">and</b>(equal_C_NEG1_ZERO, equal_D_1_Y_1), &lt:<b style="color: red;">^</b>C_NEG2<b style="color: red;">^</b>T(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(C_NEG2, C_NEG1) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(C_NEG2, D_1, T) <b style="color: red;">&</b> T in F)&gt);
							}
							<b style="color: blue;">prove</b> T_in_C: <b style="color: red;">^</b>C<b style="color: red;">^</b>D(C in NATURALS <b style="color: red;">&</b> D in NATURALS <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(C, D, T)){
								<b style="color: blue;">choose</b> C_NEG1, D_1;
								<b style="color: blue;">return</b> C_NEG1_in_NATURALS, D_1_in_NATURALS, tuple_T;
							}
							T_in_C = C_def(T)(T_in_C);
							T_in_G = G_def(T)(T_in_C, T_in_G);
							<b style="color: blue;">prove</b> condition: <b style="color: red;">^</b>C_NEG1<b style="color: red;">^</b>D_1<b style="color: red;">^</b>T(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(C_NEG1, C) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(D, D_1) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(C_NEG1, D_1, T) <b style="color: red;">&</b> T in G){
								<b style="color: blue;">choose</b> C_NEG1, D_1, T;
								<b style="color: blue;">return</b> predecessor_C_NEG1, successor_D_1, tuple_T, T_in_G;
							}
							<b style="color: blue;">return</b> tuple_B, <b style="color: green;">or</b>(&lt:<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(C, ZERO) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(D, Y_1)&gt, condition);
						} <b style="color: green;">or</b> {
							predecessor_C_NEG2, successor_D_1, tuple_T1, T1_in_F = predecessor_exists<b style="color: red;">|</b>C_NEG2, D_1, T1<b style="color: red;">|</b>;
							predecessor_C_NEG2 = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(C_NEG2, Q)&gt](C_NEG1, C_NEG1_OTHER)(equal_C_NEG1)(predecessor_C_NEG2);
							tuple_T2 = <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/tuple.html';" onmouseover="popup_window(this, 'tuple | 01_sets');" onmouseout="close_popup();">tuple</b>(C_NEG1, D_1)<b style="color: red;">|</b>T2<b style="color: red;">|</b>;
							D_1_in_NATURALS = closure_naturals(D_OTHER, D_1)(D_OTHER_in_NATURALS, successor_D_1);
							successor_D_1 = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(Q, D_1)&gt](D, D_OTHER)(equal_D)(successor_D_1);
							<b style="color: blue;">prove</b> T2_in_C: <b style="color: red;">^</b>C_NEG1<b style="color: red;">^</b>D_1(C_NEG1 in NATURALS <b style="color: red;">&</b> D_1 in NATURALS <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(C_NEG1, D_1, T2)){
								<b style="color: blue;">choose</b> C_NEG1, D_1;
								C_NEG1_in_NATURALS = <b style="cursor: pointer;" onclick="window.location.href = '../03_addition/NATURALS_predecessor_closure.html';" onmouseover="popup_window(this, 'NATURALS_predecessor_closure | 03_addition');" onmouseout="close_popup();">NATURALS_predecessor_closure</b>(C, C_NEG1)(C_in_NATURALS, predecessor_C_NEG1);
								<b style="color: blue;">return</b> C_NEG1_in_NATURALS, D_1_in_NATURALS, tuple_T2;
							}
							T2_in_C = C_def(T2)(T2_in_C);
							<b style="color: blue;">prove</b> condition: <b style="color: red;">^</b>C_NEG1<b style="color: red;">^</b>D_1(<b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(C_NEG1, D_1, T2) <b style="color: red;">&</b> ((<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(C_NEG1, ZERO) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(D_1, Y_1)) <b style="color: red;">|</b> <b style="color: red;">^</b>C_NEG2<b style="color: red;">^</b>T1(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(C_NEG2, C_NEG1) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(C_NEG2, D_1, T1) <b style="color: red;">&</b> T1 in F))){
								<b style="color: blue;">choose</b> C_NEG1, D_1;
								<b style="color: blue;">prove</b> condition: <b style="color: red;">^</b>C_NEG2<b style="color: red;">^</b>T1(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(C_NEG2, C_NEG1) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(C_NEG2, D_1, T1) <b style="color: red;">&</b> T1 in F){
									<b style="color: blue;">choose</b> C_NEG2, T1;
									<b style="color: blue;">return</b> predecessor_C_NEG2, tuple_T1, T1_in_F;
								}
								<b style="color: blue;">return</b> tuple_T2, <b style="color: green;">or</b>(&lt:<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(C_NEG1, ZERO) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(D_1, Y_1)&gt, condition);
							}
							T2_in_G = G_def(T2)(T2_in_C, condition);
							<b style="color: blue;">prove</b> condition: <b style="color: red;">^</b>C_NEG1<b style="color: red;">^</b>D_1<b style="color: red;">^</b>T2(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(C_NEG1, C) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(D, D_1) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(C_NEG1, D_1, T2) <b style="color: red;">&</b> T2 in G){
								<b style="color: blue;">choose</b> C_NEG1, D_1, T2;
								<b style="color: blue;">return</b> predecessor_C_NEG1, successor_D_1, tuple_T2, T2_in_G;
							}
							<b style="color: blue;">return</b> tuple_B, <b style="color: green;">or</b>(&lt:<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(C, ZERO) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(D, Y_1)&gt, condition);
						};
					};
				}
				<b style="color: blue;">prove</b> lemma1: <b style="color: red;">^</b>C<b style="color: red;">^</b>D(<b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(C, D, B) <b style="color: red;">&</b> ((<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(C, ZERO) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(D, Y_1)) <b style="color: red;">|</b> <b style="color: red;">^</b>C_NEG1<b style="color: red;">^</b>D_1<b style="color: red;">^</b>T(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(C_NEG1, C) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(D, D_1) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(C_NEG1, D_1, T) <b style="color: red;">&</b> T in G))) <b style="color: red;">-&gt</b> B in G{
					<b style="color: blue;">implies</b> premise;
					tuple_B, either_B = premise<b style="color: red;">|</b>C, D<b style="color: red;">|</b>;
					<b style="color: blue;">return</b> <b style="color: green;">branch</b>(either_B, equal_both, G_condition){
						equal_C_ZERO, equal_D_Y_1 = equal_both;
						<b style="color: blue;">prove</b> condition: <b style="color: red;">^</b>C<b style="color: red;">^</b>D(<b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(C, D, B) <b style="color: red;">&</b> ((<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(C, ZERO) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(D, Y_1)) <b style="color: red;">|</b> <b style="color: red;">^</b>C_NEG1<b style="color: red;">^</b>T(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(C_NEG1, C) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(C_NEG1, D, T) <b style="color: red;">&</b> T in F))){
							<b style="color: blue;">choose</b> C, D;
							<b style="color: blue;">return</b> tuple_B, <b style="color: green;">or</b>(equal_both, &lt:<b style="color: red;">^</b>C_NEG1<b style="color: red;">^</b>T(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(C_NEG1, C) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(C_NEG1, D, T) <b style="color: red;">&</b> T in F)&gt);
						}
						<b style="color: blue;">prove</b> B_in_C: <b style="color: red;">^</b>C<b style="color: red;">^</b>D(C in NATURALS <b style="color: red;">&</b> D in NATURALS <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(C, D, B)){
							<b style="color: blue;">choose</b> C, D;
							C_in_NATURALS = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: Q in NATURALS&gt](C, ZERO)(equal_C_ZERO)(zero_is_natural);
							D_in_NATURALS = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: Q in NATURALS&gt](D, Y_1)(equal_D_Y_1)(Y_1_in_NATURALS);
							<b style="color: blue;">return</b> C_in_NATURALS, D_in_NATURALS, tuple_B;
						}
						B_in_C = C_def(B)(B_in_C);
						<b style="color: blue;">return</b> G_def(B)(B_in_C, condition);
					} <b style="color: green;">or</b> {
						predecessor_C_NEG1, successor_D_1, tuple_T, T_in_G = G_condition<b style="color: red;">|</b>C_NEG1, D_1, T<b style="color: red;">|</b>;
						T_in_C, T_condition = G_def(T)(T_in_G);
						tuple_T_other, either_T = T_condition<b style="color: red;">|</b>C_NEG1_OTHER, D_1_OTHER<b style="color: red;">|</b>;
						equal_C_NEG1, equal_D_1 = <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/tuple_equal_condition.html';" onmouseover="popup_window(this, 'tuple_equal_condition | 01_sets');" onmouseout="close_popup();">tuple_equal_condition</b>(C_NEG1, D_1, C_NEG1_OTHER, D_1_OTHER, T, T)(tuple_T, tuple_T_other, <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets_reflexive.html';" onmouseover="popup_window(this, 'equal_sets_reflexive | 00_zf');" onmouseout="close_popup();">equal_sets_reflexive</b>(T));
						<b style="color: blue;">return</b> <b style="color: green;">branch</b>(either_T, equal_initial, F_condition){
							equal_C_NEG1_ZERO, equal_D_1_Y_1 = equal_initial;
							equal_C_NEG1_ZERO = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(Q, ZERO)&gt](C_NEG1, C_NEG1_OTHER)(equal_C_NEG1)(equal_C_NEG1_ZERO);
							equal_D_1_Y_1 = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(Q, Y_1)&gt](D_1, D_1_OTHER)(equal_D_1)(equal_D_1_Y_1);
							successor_D_1_Y = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(Y, Q)&gt](D_1, Y_1)(equal_D_1_Y_1)(successor_Y_1);
							equal_D_Y = <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/predecessor_unique.html';" onmouseover="popup_window(this, 'predecessor_unique | 01_sets');" onmouseout="close_popup();">predecessor_unique</b>(D, Y, D_1)(successor_D_1, successor_D_1_Y);
							tuple_T0 = <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/tuple.html';" onmouseover="popup_window(this, 'tuple | 01_sets');" onmouseout="close_popup();">tuple</b>(C_NEG1, D)<b style="color: red;">|</b>T0<b style="color: red;">|</b>;
							<b style="color: blue;">prove</b> T0_in_F: <b style="color: red;">^</b>C_NEG1<b style="color: red;">^</b>D(<b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(C_NEG1, D, T0) <b style="color: red;">&</b> ((<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(C_NEG1, ZERO) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(D, Y)) <b style="color: red;">|</b> <b style="color: red;">^</b>P<b style="color: red;">^</b>S<b style="color: red;">^</b>T(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(P, C_NEG1) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(D, S) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(P, S, T) <b style="color: red;">&</b> T in F))){
								<b style="color: blue;">choose</b> C_NEG1, D;
								<b style="color: blue;">return</b> tuple_T0, <b style="color: green;">or</b>(<b style="color: green;">and</b>(equal_C_NEG1_ZERO, equal_D_Y), &lt:<b style="color: red;">^</b>P<b style="color: red;">^</b>S<b style="color: red;">^</b>T(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(P, C_NEG1) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(D, S) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(P, S, T) <b style="color: red;">&</b> T in F)&gt);
							}
							T0_in_F = F_addition_class(T0)(T0_in_F);
							<b style="color: blue;">prove</b> condition: <b style="color: red;">^</b>C_NEG1<b style="color: red;">^</b>T0(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(C_NEG1, C) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(C_NEG1, D, T0) <b style="color: red;">&</b> T0 in F){
								<b style="color: blue;">choose</b> C_NEG1, T0;
								<b style="color: blue;">return</b> predecessor_C_NEG1, tuple_T0, T0_in_F;
							}
							<b style="color: blue;">prove</b> condition: <b style="color: red;">^</b>C<b style="color: red;">^</b>D(<b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(C, D, B) <b style="color: red;">&</b> ((<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(C, ZERO) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(D, Y_1)) <b style="color: red;">|</b> <b style="color: red;">^</b>C_NEG1<b style="color: red;">^</b>T0(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(C_NEG1, C) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(C_NEG1, D, T0) <b style="color: red;">&</b> T0 in F))){
								<b style="color: blue;">choose</b> C, D;
								<b style="color: blue;">return</b> tuple_B, <b style="color: green;">or</b>(&lt:<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(C, ZERO) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(D, Y_1)&gt, condition);
							}
							<b style="color: blue;">prove</b> B_in_C: <b style="color: red;">^</b>C<b style="color: red;">^</b>D(C in NATURALS <b style="color: red;">&</b> D in NATURALS <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(C, D, B)){
								<b style="color: blue;">choose</b> C, D;
								C_NEG1_in_NATURALS = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: Q in NATURALS&gt](C_NEG1, ZERO)(equal_C_NEG1_ZERO)(zero_is_natural);
								C_in_NATURALS = closure_naturals(C_NEG1, C)(C_NEG1_in_NATURALS, predecessor_C_NEG1);
								D_in_NATURALS = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: Q in NATURALS&gt](D, Y)(equal_D_Y)(Y_in_NATURALS);
								<b style="color: blue;">return</b> C_in_NATURALS, D_in_NATURALS, tuple_B;
							}
							B_in_C = C_def(B)(B_in_C);
							<b style="color: blue;">return</b> G_def(B)(B_in_C, condition);
						} <b style="color: green;">or</b> {
							predecessor_C_NEG2, tuple_T0, T0_in_F = F_condition<b style="color: red;">|</b>C_NEG2, T0<b style="color: red;">|</b>;
							predecessor_C_NEG2 = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(C_NEG2, Q)&gt](C_NEG1, C_NEG1_OTHER)(equal_C_NEG1)(predecessor_C_NEG2);
							tuple_T0 = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(C_NEG2, Q, T0)&gt](D_1, D_1_OTHER)(equal_D_1)(tuple_T0);
							tuple_T1 = <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/tuple.html';" onmouseover="popup_window(this, 'tuple | 01_sets');" onmouseout="close_popup();">tuple</b>(C_NEG1, D)<b style="color: red;">|</b>T1<b style="color: red;">|</b>;
							<b style="color: blue;">prove</b> T1_in_F: <b style="color: red;">^</b>C_NEG2<b style="color: red;">^</b>D_1<b style="color: red;">^</b>T0(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(C_NEG2, C_NEG1) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(D, D_1) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(C_NEG2, D_1, T0) <b style="color: red;">&</b> T0 in F){
								<b style="color: blue;">choose</b> C_NEG2, D_1, T0;
								<b style="color: blue;">return</b> predecessor_C_NEG2, successor_D_1, tuple_T0, T0_in_F;
							}
							<b style="color: blue;">prove</b> T1_in_F: <b style="color: red;">^</b>C_NEG1<b style="color: red;">^</b>D(<b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(C_NEG1, D, T1) <b style="color: red;">&</b> ((<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(C_NEG1, ZERO) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(D, Y)) <b style="color: red;">|</b> <b style="color: red;">^</b>C_NEG2<b style="color: red;">^</b>D_1<b style="color: red;">^</b>T0(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(C_NEG2, C_NEG1) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(D, D_1) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(C_NEG2, D_1, T0) <b style="color: red;">&</b> T0 in F))){
								<b style="color: blue;">choose</b> C_NEG1, D;
								<b style="color: blue;">return</b> tuple_T1, <b style="color: green;">or</b>(&lt:<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(C_NEG1, ZERO) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(D, Y)&gt, T1_in_F);
							}
							T1_in_F = F_addition_class(T1)(T1_in_F);
							//Here is where we use the stronger condition
							T1_in_C = <b style="color: green;">expand</b>(F_subset_C)(T1)(T1_in_F);
							C_NEG1_OTHER_in_NATURALS, D_OTHER_in_NATURALS, tuple_T1_other = C_def(T1)(T1_in_C)<b style="color: red;">|</b>C_NEG1_OTHER, D_OTHER<b style="color: red;">|</b>;
							equal_C_NEG1, equal_D = <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/tuple_equal_condition.html';" onmouseover="popup_window(this, 'tuple_equal_condition | 01_sets');" onmouseout="close_popup();">tuple_equal_condition</b>(C_NEG1, D, C_NEG1_OTHER, D_OTHER, T1, T1)(tuple_T1, tuple_T1_other, <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets_reflexive.html';" onmouseover="popup_window(this, 'equal_sets_reflexive | 00_zf');" onmouseout="close_popup();">equal_sets_reflexive</b>(T1));
							C_NEG1_in_NATURALS = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: Q in NATURALS&gt](C_NEG1, C_NEG1_OTHER)(equal_C_NEG1)(C_NEG1_OTHER_in_NATURALS);
							D_in_NATURALS = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: Q in NATURALS&gt](D, D_OTHER)(equal_D)(D_OTHER_in_NATURALS);
							C_in_NATURALS = closure_naturals(C_NEG1, C)(C_NEG1_in_NATURALS, predecessor_C_NEG1);
							<b style="color: blue;">prove</b> condition: <b style="color: red;">^</b>C_NEG1<b style="color: red;">^</b>T1(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(C_NEG1, C) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(C_NEG1, D, T1) <b style="color: red;">&</b> T1 in F){
								<b style="color: blue;">choose</b> C_NEG1, T1;
								<b style="color: blue;">return</b> predecessor_C_NEG1, tuple_T1, T1_in_F;
							}
							<b style="color: blue;">prove</b> condition: <b style="color: red;">^</b>C<b style="color: red;">^</b>D(<b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(C, D, B) <b style="color: red;">&</b> ((<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(C, ZERO) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(D, Y_1)) <b style="color: red;">|</b> <b style="color: red;">^</b>C_NEG1<b style="color: red;">^</b>T1(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(C_NEG1, C) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(C_NEG1, D, T1) <b style="color: red;">&</b> T1 in F))){
								<b style="color: blue;">choose</b> C, D;
								<b style="color: blue;">return</b> tuple_B, <b style="color: green;">or</b>(&lt:<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(C, ZERO) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(D, Y_1)&gt, condition);
							}
							<b style="color: blue;">prove</b> B_in_C: <b style="color: red;">^</b>C<b style="color: red;">^</b>D(C in NATURALS <b style="color: red;">&</b> D in NATURALS <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(C, D, B)){
								<b style="color: blue;">choose</b> C, D;
								<b style="color: blue;">return</b> C_in_NATURALS, D_in_NATURALS, tuple_B;
							}
							B_in_C = C_def(B)(B_in_C);
							<b style="color: blue;">return</b> G_def(B)(B_in_C, condition);
						};
					};
				}
				<b style="color: blue;">return</b> <b style="color: green;">iff</b>(lemma0, lemma1);
			}
			G_addition_class = #is_addition_class(Y_1, G)(G_addition_class);
			<b style="color: blue;">prove</b> subset_def: <b style="color: red;">*</b>X(X in G <b style="color: red;">-&gt</b> X in C){
				<b style="color: blue;">given</b> <b style="color: red;">|</b>X<b style="color: red;">|</b>;
				<b style="color: blue;">implies</b> X_in_G;
				X_in_C, G_condition = G_def(X)(X_in_G);
				<b style="color: blue;">return</b> X_in_C;
			}
			G_subset_C = #<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_subset.html';" onmouseover="popup_window(this, 'is_subset | 00_zf');" onmouseout="close_popup();">is_subset</b>(G, C)(subset_def);
			<b style="color: blue;">prove</b> Y_1_in_R: <b style="color: red;">^</b>G(is_addition_class(Y_1, G) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_subset.html';" onmouseover="popup_window(this, 'is_subset | 00_zf');" onmouseout="close_popup();">is_subset</b>(G, C)){
				<b style="color: blue;">choose</b> G;
				<b style="color: blue;">return</b> G_addition_class, G_subset_C;
			}
			<b style="color: blue;">return</b> R_def(Y_1)(Y_1_in_NATURALS, Y_1_in_R);
		}
		NATURALS_subset_R = <b style="color: green;">expand</b>(<b style="cursor: pointer;" onclick="window.location.href = '../03_addition/NATURALS_induction.html';" onmouseover="popup_window(this, 'NATURALS_induction | 03_addition');" onmouseout="close_popup();">NATURALS_induction</b>(R)(ZERO_in_R, closure_R));
		<b style="color: blue;">given</b> <b style="color: red;">|</b>N<b style="color: red;">|</b>;
		<b style="color: blue;">implies</b> N_in_NATURALS;
		N_in_R = NATURALS_subset_R(N)(N_in_NATURALS);
		N_in_NATURALS, addition_class_exists = R_def(N)(N_in_R);
		result = addition_class_exists<b style="color: red;">|</b>A<b style="color: red;">|</b>;
		<b style="color: blue;">choose</b> A;
		<b style="color: blue;">return</b> result;
	}

	//Phew! That was the most important result of the proof. Next we need to <b style="color: blue;">prove</b> that these addition classes cover all <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/pairs.html';" onmouseover="popup_window(this, 'pairs | 01_sets');" onmouseout="close_popup();">pairs</b> of natural numbers.

	//This lemma shows that (0, x) belongs to an addition class of N if <b style="color: green;">and</b> only if x = N
	<b style="color: blue;">prove</b> addition_class_initial_unique: <b style="color: red;">*</b>A<b style="color: red;">*</b>T<b style="color: red;">*</b>F<b style="color: red;">*</b>N(is_addition_class(N, F) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(ZERO, A, T) <b style="color: red;">-&gt</b> (T in F <b style="color: red;">&lt-&gt</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(A, N))){
		<b style="color: blue;">given</b> <b style="color: red;">|</b>A, T, F, N<b style="color: red;">|</b>;
		<b style="color: blue;">implies</b> addition_class_F, tuple_T;
		<b style="color: blue;">prove</b> lemma0: T in F <b style="color: red;">-&gt</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(A, N){
			<b style="color: blue;">implies</b> T_in_F;
			tuple_T_other, either = <b style="color: green;">expand</b>(addition_class_F)(T)(T_in_F)<b style="color: red;">|</b>OTHER_ZERO, OTHER_A<b style="color: red;">|</b>;
			equal_ZERO, equal_A = <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/tuple_equal_condition.html';" onmouseover="popup_window(this, 'tuple_equal_condition | 01_sets');" onmouseout="close_popup();">tuple_equal_condition</b>(ZERO, A, OTHER_ZERO, OTHER_A, T, T)(tuple_T, tuple_T_other, <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets_reflexive.html';" onmouseover="popup_window(this, 'equal_sets_reflexive | 00_zf');" onmouseout="close_popup();">equal_sets_reflexive</b>(T));
			<b style="color: blue;">return</b> <b style="color: green;">branch</b>(either, equal_both, predecessors){
				equal_ZERO, equal_OTHER_A_N = equal_both;
				<b style="color: blue;">return</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets_transitive.html';" onmouseover="popup_window(this, 'equal_sets_transitive | 00_zf');" onmouseout="close_popup();">equal_sets_transitive</b>(A, OTHER_A, N)(equal_A, equal_OTHER_A_N);
			} <b style="color: green;">or</b> {
				predecessor_C, successor_D, tuple_T0, T0_in_F = predecessors<b style="color: red;">|</b>C, D, T0<b style="color: red;">|</b>;
				not_zero = <b style="cursor: pointer;" onclick="window.location.href = '../03_addition/NATURAL_successor_nonzero.html';" onmouseover="popup_window(this, 'NATURAL_successor_nonzero | 03_addition');" onmouseout="close_popup();">NATURAL_successor_nonzero</b>(C, OTHER_ZERO)(predecessor_C);
				equal_OTHER_ZERO_ZERO = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets_symmetric.html';" onmouseover="popup_window(this, 'equal_sets_symmetric | 00_zf');" onmouseout="close_popup();">equal_sets_symmetric</b>(ZERO, OTHER_ZERO)(equal_ZERO);
				absurdity = not_zero(equal_OTHER_ZERO_ZERO);
				<b style="color: blue;">return</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/axiom_absurdity.html';" onmouseover="popup_window(this, 'axiom_absurdity | 00_zf');" onmouseout="close_popup();">axiom_absurdity</b>[goal](absurdity);
			};
		}
		<b style="color: blue;">prove</b> lemma1: <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(A, N) <b style="color: red;">-&gt</b> T in F{
			<b style="color: blue;">implies</b> equal_A_N;
			<b style="color: blue;">prove</b> condition: <b style="color: red;">^</b>C<b style="color: red;">^</b>D(<b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(C, D, T) <b style="color: red;">&</b> ((<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(C, ZERO) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(D, N)) <b style="color: red;">|</b> <b style="color: red;">^</b>P<b style="color: red;">^</b>S<b style="color: red;">^</b>T(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(P, C) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(D, S) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(P, S, T) <b style="color: red;">&</b> T in F))){
				<b style="color: blue;">choose</b> ZERO, A;
				<b style="color: blue;">return</b> tuple_T, <b style="color: green;">or</b>(<b style="color: green;">and</b>(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets_reflexive.html';" onmouseover="popup_window(this, 'equal_sets_reflexive | 00_zf');" onmouseout="close_popup();">equal_sets_reflexive</b>(ZERO), equal_A_N), &lt:<b style="color: red;">^</b>P<b style="color: red;">^</b>S<b style="color: red;">^</b>T(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(P, ZERO) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(A, S) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(P, S, T) <b style="color: red;">&</b> T in F)&gt);
			}
			<b style="color: blue;">return</b> <b style="color: green;">expand</b>(addition_class_F)(T)(condition);
		}
		<b style="color: blue;">return</b> <b style="color: green;">iff</b>(lemma0, lemma1);
	}

	//Next we <b style="color: blue;">prove</b> a crucial lemma to the next important result, again using induction
	//This result also shows the recursive peano <b style="color: blue;">axiom</b> for addition
	<b style="color: blue;">prove</b> addition_classes_cover_lemma: <b style="color: red;">*</b>A(A in NATURALS <b style="color: red;">-&gt</b> <b style="color: red;">*</b>B<b style="color: red;">*</b>T<b style="color: red;">*</b>F<b style="color: red;">*</b>N(N in NATURALS <b style="color: red;">&</b> is_addition_class(N, F) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(A, B, T) <b style="color: red;">&</b> T in F <b style="color: red;">-&gt</b> <b style="color: red;">^</b>S<b style="color: red;">^</b>T1<b style="color: red;">^</b>N1<b style="color: red;">^</b>F1(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(A, S) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(N, N1) <b style="color: red;">&</b> is_addition_class(N1, F1) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(S, B, T1) <b style="color: red;">&</b> T1 in F1))){
		//Again, we use induction!
		R_def = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/axiom_specify.html';" onmouseover="popup_window(this, 'axiom_specify | 00_zf');" onmouseout="close_popup();">axiom_specify</b>[&ltQ: <b style="color: red;">*</b>B<b style="color: red;">*</b>T<b style="color: red;">*</b>F<b style="color: red;">*</b>N(N in NATURALS <b style="color: red;">&</b> is_addition_class(N, F) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(Q, B, T) <b style="color: red;">&</b> T in F <b style="color: red;">-&gt</b> <b style="color: red;">^</b>S<b style="color: red;">^</b>T1<b style="color: red;">^</b>N1<b style="color: red;">^</b>F1(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(Q, S) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(N, N1) <b style="color: red;">&</b> is_addition_class(N1, F1) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(S, B, T1) <b style="color: red;">&</b> T1 in F1))&gt](NATURALS)<b style="color: red;">|</b>R<b style="color: red;">|</b>;
		//Base step
		<b style="color: blue;">prove</b> ZERO_in_R: <b style="color: red;">*</b>B<b style="color: red;">*</b>T<b style="color: red;">*</b>F<b style="color: red;">*</b>N(N in NATURALS <b style="color: red;">&</b> is_addition_class(N, F) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(ZERO, B, T) <b style="color: red;">&</b> T in F <b style="color: red;">-&gt</b> <b style="color: red;">^</b>S<b style="color: red;">^</b>T1<b style="color: red;">^</b>N1<b style="color: red;">^</b>F1(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(ZERO, S) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(N, N1) <b style="color: red;">&</b> is_addition_class(N1, F1) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(S, B, T1) <b style="color: red;">&</b> T1 in F1)){
			<b style="color: blue;">given</b> <b style="color: red;">|</b>B, T, F, N<b style="color: red;">|</b>;
			<b style="color: blue;">implies</b> N_in_NATURALS, addition_class_F, tuple_T, T_in_F;
			equal_B_N = addition_class_initial_unique(B, T, F, N)(addition_class_F, tuple_T)(T_in_F);
			successor_N1 = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/successor.html';" onmouseover="popup_window(this, 'successor | 00_zf');" onmouseout="close_popup();">successor</b>(N)<b style="color: red;">|</b>N1<b style="color: red;">|</b>;
			N1_in_NATURALS = closure_naturals(N, N1)(N_in_NATURALS, successor_N1);
			tuple_T0 = <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/tuple.html';" onmouseover="popup_window(this, 'tuple | 01_sets');" onmouseout="close_popup();">tuple</b>(ZERO, N1)<b style="color: red;">|</b>T0<b style="color: red;">|</b>;
			addition_class_F1, F1_subset_C = addition_classes_exist(N1)(N1_in_NATURALS)<b style="color: red;">|</b>F1<b style="color: red;">|</b>;
			T0_in_F1 = addition_class_initial_unique(N1, T0, F1, N1)(addition_class_F1, tuple_T0)(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets_reflexive.html';" onmouseover="popup_window(this, 'equal_sets_reflexive | 00_zf');" onmouseout="close_popup();">equal_sets_reflexive</b>(N1));
			tuple_T1 = <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/tuple.html';" onmouseover="popup_window(this, 'tuple | 01_sets');" onmouseout="close_popup();">tuple</b>(ONE, N)<b style="color: red;">|</b>T1<b style="color: red;">|</b>;
			<b style="color: blue;">prove</b> T1_in_F1: <b style="color: red;">^</b>ONE<b style="color: red;">^</b>N(<b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(ONE, N, T1) <b style="color: red;">&</b> ((<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(ONE, ZERO) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(N, N1)) <b style="color: red;">|</b> <b style="color: red;">^</b>ZERO<b style="color: red;">^</b>N1<b style="color: red;">^</b>T0(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(ZERO, ONE) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(N, N1) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(ZERO, N1, T0) <b style="color: red;">&</b> T0 in F1))){
				<b style="color: blue;">choose</b> ONE, N;
				<b style="color: blue;">prove</b> condition: <b style="color: red;">^</b>ZERO<b style="color: red;">^</b>N1<b style="color: red;">^</b>T0(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(ZERO, ONE) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(N, N1) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(ZERO, N1, T0) <b style="color: red;">&</b> T0 in F1){
					<b style="color: blue;">choose</b> ZERO, N1, T0;
					<b style="color: blue;">return</b> one_definition, successor_N1, tuple_T0, T0_in_F1;
				}
				<b style="color: blue;">return</b> tuple_T1, <b style="color: green;">or</b>(&lt:<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(ONE, ZERO) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(N, N1)&gt, condition);
			}
			T1_in_F1 = <b style="color: green;">expand</b>(addition_class_F1)(T1)(T1_in_F1);
			tuple_T1 = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltQ: <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(ONE, Q, T1)&gt](B, N)(equal_B_N)(tuple_T1);
			<b style="color: blue;">choose</b> ONE, T1, N1, F1;
			<b style="color: blue;">return</b> one_definition, successor_N1, addition_class_F1, tuple_T1, T1_in_F1;
		}
		ZERO_in_R = R_def(ZERO)(zero_is_natural, ZERO_in_R);
		//Inductive step
		<b style="color: blue;">prove</b> closure_R: <b style="color: red;">*</b>Y<b style="color: red;">*</b>Z(Y in R <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(Y, Z) <b style="color: red;">-&gt</b> Z in R){
			<b style="color: blue;">given</b> <b style="color: red;">|</b>Y, Y1<b style="color: red;">|</b>;
			<b style="color: blue;">implies</b> Y_in_R, successor_Y1;
			Y1_not_ZERO = <b style="cursor: pointer;" onclick="window.location.href = '../03_addition/NATURAL_successor_nonzero.html';" onmouseover="popup_window(this, 'NATURAL_successor_nonzero | 03_addition');" onmouseout="close_popup();">NATURAL_successor_nonzero</b>(Y, Y1)(successor_Y1);
			Y_in_NATURALS, Y_condition = R_def(Y)(Y_in_R);
			successor_Y2 = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/successor.html';" onmouseover="popup_window(this, 'successor | 00_zf');" onmouseout="close_popup();">successor</b>(Y1)<b style="color: red;">|</b>Y2<b style="color: red;">|</b>;
			Y2_not_ZERO = <b style="cursor: pointer;" onclick="window.location.href = '../03_addition/NATURAL_successor_nonzero.html';" onmouseover="popup_window(this, 'NATURAL_successor_nonzero | 03_addition');" onmouseout="close_popup();">NATURAL_successor_nonzero</b>(Y1, Y2)(successor_Y2);
			Y1_in_NATURALS = closure_naturals(Y, Y1)(Y_in_NATURALS, successor_Y1);
			<b style="color: blue;">prove</b> Y1_in_R: <b style="color: red;">*</b>B<b style="color: red;">*</b>T<b style="color: red;">*</b>F<b style="color: red;">*</b>N(N in NATURALS <b style="color: red;">&</b> is_addition_class(N, F) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(Y1, B, T) <b style="color: red;">&</b> T in F <b style="color: red;">-&gt</b> <b style="color: red;">^</b>Y2<b style="color: red;">^</b>T1<b style="color: red;">^</b>N1<b style="color: red;">^</b>F1(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(Y1, Y2) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(N, N1) <b style="color: red;">&</b> is_addition_class(N1, F1) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(Y2, B, T1) <b style="color: red;">&</b> T1 in F1)){
				<b style="color: blue;">given</b> <b style="color: red;">|</b>B, T, F, N<b style="color: red;">|</b>;
				<b style="color: blue;">implies</b> N_in_NATURALS, addition_class_F, tuple_T, T_in_F;
				other_tuple_T, either_T = <b style="color: green;">expand</b>(addition_class_F)(T)(T_in_F)<b style="color: red;">|</b>OTHER_Y1, OTHER_B<b style="color: red;">|</b>;
				equal_Y1, equal_B = <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/tuple_equal_condition.html';" onmouseover="popup_window(this, 'tuple_equal_condition | 01_sets');" onmouseout="close_popup();">tuple_equal_condition</b>(Y1, B, OTHER_Y1, OTHER_B, T, T)(tuple_T, other_tuple_T, <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets_reflexive.html';" onmouseover="popup_window(this, 'equal_sets_reflexive | 00_zf');" onmouseout="close_popup();">equal_sets_reflexive</b>(T));
				predecessor_exists_T = <b style="color: green;">branch</b>(either_T, equal_initial_T, predecessor_exists_T){
					equal_OTHER_Y1_ZERO, equal_OTHER_B_N = equal_initial_T;
					equal_Y1_ZERO = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltS: <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(S, ZERO)&gt](Y1, OTHER_Y1)(equal_Y1)(equal_OTHER_Y1_ZERO);
					absurdity = Y1_not_ZERO(equal_Y1_ZERO);
					<b style="color: blue;">return</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/axiom_absurdity.html';" onmouseover="popup_window(this, 'axiom_absurdity | 00_zf');" onmouseout="close_popup();">axiom_absurdity</b>[&lt:<b style="color: red;">^</b>Y<b style="color: red;">^</b>B1<b style="color: red;">^</b>T0(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(Y, OTHER_Y1) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(OTHER_B, B1) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(Y, B1, T0) <b style="color: red;">&</b> T0 in F)&gt](absurdity);
				} <b style="color: green;">or</b> {
					<b style="color: blue;">return</b> predecessor_exists_T;
				};
				successor_OTHER_Y1, successor_B1, tuple_T0, T0_in_F = predecessor_exists_T<b style="color: red;">|</b>OTHER_Y, B1, T0<b style="color: red;">|</b>;
				successor_Y1_OTHER_Y = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltS: <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(OTHER_Y, S)&gt](Y1, OTHER_Y1)(equal_Y1)(successor_OTHER_Y1);
				equal_Y = <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/predecessor_unique.html';" onmouseover="popup_window(this, 'predecessor_unique | 01_sets');" onmouseout="close_popup();">predecessor_unique</b>(Y, OTHER_Y, Y1)(successor_Y1, successor_Y1_OTHER_Y);
				tuple_T0 = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltS: <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(S, B1, T0)&gt](Y, OTHER_Y)(equal_Y)(tuple_T0);
				existence_in_F1 = Y_condition(B1, T0, F, N)(N_in_NATURALS, addition_class_F, tuple_T0, T0_in_F);

				//I want to overwrite OTHER_Y1 because I no longer need the older "version" of this object
				//So I must overwrite the other statements which refer to this old object
				other_tuple_T = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/axiom_true.html';" onmouseover="popup_window(this, 'axiom_true | 00_zf');" onmouseout="close_popup();">axiom_true</b>;
				either_T = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/axiom_true.html';" onmouseover="popup_window(this, 'axiom_true | 00_zf');" onmouseout="close_popup();">axiom_true</b>;
				equal_Y1 = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/axiom_true.html';" onmouseover="popup_window(this, 'axiom_true | 00_zf');" onmouseout="close_popup();">axiom_true</b>;
				predecessor_exists_T = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/axiom_true.html';" onmouseover="popup_window(this, 'axiom_true | 00_zf');" onmouseout="close_popup();">axiom_true</b>;
				successor_OTHER_Y1 = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/axiom_true.html';" onmouseover="popup_window(this, 'axiom_true | 00_zf');" onmouseout="close_popup();">axiom_true</b>;

				successor_OTHER_Y1, successor_N1, addition_class_F1, tuple_T1_PRED, T1_PRED_in_F1 = existence_in_F1<b style="color: red;">|</b>OTHER_Y1, T1_PRED, N1, F1<b style="color: red;">|</b>;
				equal_Y1 = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/successor_unique.html';" onmouseover="popup_window(this, 'successor_unique | 00_zf');" onmouseout="close_popup();">successor_unique</b>(Y, Y1, OTHER_Y1)(successor_Y1, successor_OTHER_Y1);
				successor_B1 = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltS: <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(S, B1)&gt](B, OTHER_B)(equal_B)(successor_B1);
				tuple_T1_PRED = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltS: <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(S, B1, T1_PRED)&gt](Y1, OTHER_Y1)(equal_Y1)(tuple_T1_PRED);
				successor_Y2 = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/successor.html';" onmouseover="popup_window(this, 'successor | 00_zf');" onmouseout="close_popup();">successor</b>(Y1)<b style="color: red;">|</b>Y2<b style="color: red;">|</b>;
				tuple_T1 = <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/tuple.html';" onmouseover="popup_window(this, 'tuple | 01_sets');" onmouseout="close_popup();">tuple</b>(Y2, B)<b style="color: red;">|</b>T1<b style="color: red;">|</b>;
				<b style="color: blue;">choose</b> Y2, T1, N1, F1;
				<b style="color: blue;">prove</b> condition: <b style="color: red;">^</b>P<b style="color: red;">^</b>S<b style="color: red;">^</b>T(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(P, Y2) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(B, S) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(P, S, T) <b style="color: red;">&</b> T in F1){
					<b style="color: blue;">choose</b> Y1, B1, T1_PRED;
					<b style="color: blue;">return</b> successor_Y2, successor_B1, tuple_T1_PRED, T1_PRED_in_F1;
				}
				<b style="color: blue;">prove</b> T1_in_F1: <b style="color: red;">^</b>Y2<b style="color: red;">^</b>B(<b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(Y2, B, T1) <b style="color: red;">&</b> ((<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(Y2, ZERO) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(B, N1)) <b style="color: red;">|</b> <b style="color: red;">^</b>P<b style="color: red;">^</b>S<b style="color: red;">^</b>T(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(P, Y2) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(B, S) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(P, S, T) <b style="color: red;">&</b> T in F1))){
					<b style="color: blue;">choose</b> Y2, B;
					<b style="color: blue;">return</b> tuple_T1, <b style="color: green;">or</b>(&lt:<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(Y2, ZERO) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(B, N1)&gt, condition);
				}
				T1_in_F1 = <b style="color: green;">expand</b>(addition_class_F1)(T1)(T1_in_F1);
				<b style="color: blue;">return</b> successor_Y2, successor_N1, addition_class_F1, tuple_T1, T1_in_F1;
			}
			<b style="color: blue;">return</b> R_def(Y1)(Y1_in_NATURALS, Y1_in_R);
		}
		NATURALS_subset_R = <b style="cursor: pointer;" onclick="window.location.href = '../03_addition/NATURALS_induction.html';" onmouseover="popup_window(this, 'NATURALS_induction | 03_addition');" onmouseout="close_popup();">NATURALS_induction</b>(R)(ZERO_in_R, closure_R);
		<b style="color: blue;">given</b> <b style="color: red;">|</b>A<b style="color: red;">|</b>;
		<b style="color: blue;">implies</b> A_in_NATURALS;
		A_in_R = <b style="color: green;">expand</b>(NATURALS_subset_R)(A)(A_in_NATURALS);
		A_in_NATURALS, result = R_def(A)(A_in_R);

		<b style="color: blue;">return</b> result;
	}

	//Now we <b style="color: blue;">prove</b> that the addition classes "cover" the tuples of natural numbers
	<b style="color: blue;">prove</b> addition_classes_cover: <b style="color: red;">*</b>A<b style="color: red;">*</b>B(A in NATURALS <b style="color: red;">&</b> B in NATURALS <b style="color: red;">-&gt</b> <b style="color: red;">^</b>T<b style="color: red;">^</b>N<b style="color: red;">^</b>F(<b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(B, A, T) <b style="color: red;">&</b> N in NATURALS <b style="color: red;">&</b> is_addition_class(N, F) <b style="color: red;">&</b> T in F)){
		<b style="color: blue;">given</b> <b style="color: red;">|</b>A, B<b style="color: red;">|</b>;
		<b style="color: blue;">implies</b> A_in_NATURALS, B_in_NATURALS;
		R_def = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/axiom_specify.html';" onmouseover="popup_window(this, 'axiom_specify | 00_zf');" onmouseout="close_popup();">axiom_specify</b>[&ltS: <b style="color: red;">^</b>T<b style="color: red;">^</b>N<b style="color: red;">^</b>F(<b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(S, A, T) <b style="color: red;">&</b> N in NATURALS <b style="color: red;">&</b> is_addition_class(N, F) <b style="color: red;">&</b> T in F)&gt](NATURALS)<b style="color: red;">|</b>R<b style="color: red;">|</b>;
		<b style="color: blue;">prove</b> ZERO_in_R: <b style="color: red;">^</b>T<b style="color: red;">^</b>N<b style="color: red;">^</b>F(<b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(ZERO, A, T) <b style="color: red;">&</b> N in NATURALS <b style="color: red;">&</b> is_addition_class(N, F) <b style="color: red;">&</b> T in F){
			tuple_T = <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/tuple.html';" onmouseover="popup_window(this, 'tuple | 01_sets');" onmouseout="close_popup();">tuple</b>(ZERO, A)<b style="color: red;">|</b>T<b style="color: red;">|</b>;
			addition_class_F, F_subset_C = addition_classes_exist(A)(A_in_NATURALS)<b style="color: red;">|</b>F<b style="color: red;">|</b>;
			T_in_F = addition_class_initial_unique(A, T, F, A)(addition_class_F, tuple_T)(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets_reflexive.html';" onmouseover="popup_window(this, 'equal_sets_reflexive | 00_zf');" onmouseout="close_popup();">equal_sets_reflexive</b>(A));
			<b style="color: blue;">choose</b> T, A, F;
			<b style="color: blue;">return</b> tuple_T, A_in_NATURALS, addition_class_F, T_in_F;
		}
		ZERO_in_R = R_def(ZERO)(zero_is_natural, ZERO_in_R);
		<b style="color: blue;">prove</b> closure_R: <b style="color: red;">*</b>Y<b style="color: red;">*</b>Y1(Y in R <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(Y, Y1) <b style="color: red;">-&gt</b> Y1 in R){
			<b style="color: blue;">given</b> <b style="color: red;">|</b>Y, Y1<b style="color: red;">|</b>;
			<b style="color: blue;">implies</b> Y_in_R, successor_Y1;
			Y_in_NATURALS, Y_condition = R_def(Y)(Y_in_R);
			tuple_T, N_in_NATURALS, addition_class_F, T_in_F = Y_condition<b style="color: red;">|</b>T, N, F<b style="color: red;">|</b>;
			next_exists = addition_classes_cover_lemma(Y)(Y_in_NATURALS)(A, T, F, N)(N_in_NATURALS, addition_class_F, tuple_T, T_in_F);
			successor_OTHER_Y1, successor_N1, addition_class_F1, tuple_T1, T1_in_F1 = next_exists<b style="color: red;">|</b>OTHER_Y1, T1, N1, F1<b style="color: red;">|</b>;
			equal_Y1 = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/successor_unique.html';" onmouseover="popup_window(this, 'successor_unique | 00_zf');" onmouseout="close_popup();">successor_unique</b>(Y, Y1, OTHER_Y1)(successor_Y1, successor_OTHER_Y1);
			tuple_T1 = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltS: <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(S, A, T1)&gt](Y1, OTHER_Y1)(equal_Y1)(tuple_T1);
			N1_in_NATURALS = closure_naturals(N, N1)(N_in_NATURALS, successor_N1);
			Y1_in_NATURALS = closure_naturals(Y, Y1)(Y_in_NATURALS, successor_Y1);
			<b style="color: blue;">prove</b> Y1_in_R: <b style="color: red;">^</b>T1<b style="color: red;">^</b>N1<b style="color: red;">^</b>F1(<b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(Y1, A, T1) <b style="color: red;">&</b> N1 in NATURALS <b style="color: red;">&</b> is_addition_class(N1, F1) <b style="color: red;">&</b> T1 in F1){
				<b style="color: blue;">choose</b> T1, N1, F1;
				<b style="color: blue;">return</b> tuple_T1, N1_in_NATURALS, addition_class_F1, T1_in_F1;
			}
			<b style="color: blue;">return</b> R_def(Y1)(Y1_in_NATURALS, Y1_in_R);
		}
		NATURALS_subset_R = <b style="cursor: pointer;" onclick="window.location.href = '../03_addition/NATURALS_induction.html';" onmouseover="popup_window(this, 'NATURALS_induction | 03_addition');" onmouseout="close_popup();">NATURALS_induction</b>(R)(ZERO_in_R, closure_R);
		B_in_R = <b style="color: green;">expand</b>(NATURALS_subset_R)(B)(B_in_NATURALS);
		B_in_NATURALS, result = R_def(B)(B_in_R);
		
		<b style="color: blue;">return</b> result;
	}

	//Here we <b style="color: blue;">prove</b> that (A, B) can belong to at most one addition class
	<b style="color: blue;">prove</b> addition_classes_unique: <b style="color: red;">*</b>A<b style="color: red;">*</b>B<b style="color: red;">*</b>N<b style="color: red;">*</b>M<b style="color: red;">*</b>FN<b style="color: red;">*</b>FM(A in NATURALS <b style="color: red;">&</b> B in NATURALS <b style="color: red;">&</b> is_addition_class(N, FN) <b style="color: red;">&</b> is_addition_class(M, FM) <b style="color: red;">&</b> <b style="color: red;">^</b>T(<b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(A, B, T) <b style="color: red;">&</b> T in FN <b style="color: red;">&</b> T in FM) <b style="color: red;">-&gt</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(N, M)){
		R_def = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/axiom_specify.html';" onmouseover="popup_window(this, 'axiom_specify | 00_zf');" onmouseout="close_popup();">axiom_specify</b>[&ltS: <b style="color: red;">*</b>B<b style="color: red;">*</b>N<b style="color: red;">*</b>M<b style="color: red;">*</b>FN<b style="color: red;">*</b>FM(S in NATURALS <b style="color: red;">&</b> B in NATURALS <b style="color: red;">&</b> is_addition_class(N, FN) <b style="color: red;">&</b> is_addition_class(M, FM) <b style="color: red;">&</b> <b style="color: red;">^</b>T(<b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(S, B, T) <b style="color: red;">&</b> T in FN <b style="color: red;">&</b> T in FM) <b style="color: red;">-&gt</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(N, M))&gt](NATURALS)<b style="color: red;">|</b>R<b style="color: red;">|</b>;
		<b style="color: blue;">prove</b> ZERO_in_R: <b style="color: red;">*</b>B<b style="color: red;">*</b>N<b style="color: red;">*</b>M<b style="color: red;">*</b>FN<b style="color: red;">*</b>FM(ZERO in NATURALS <b style="color: red;">&</b> B in NATURALS <b style="color: red;">&</b> is_addition_class(N, FN) <b style="color: red;">&</b> is_addition_class(M, FM) <b style="color: red;">&</b> <b style="color: red;">^</b>T(<b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(ZERO, B, T) <b style="color: red;">&</b> T in FN <b style="color: red;">&</b> T in FM) <b style="color: red;">-&gt</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(N, M)){
			<b style="color: blue;">given</b> <b style="color: red;">|</b>B, N, M, FN, FM<b style="color: red;">|</b>;
			<b style="color: blue;">implies</b> ZERO_in_NATURALS, B_in_NATURALS, addition_class_FN, addition_class_FM, T_exists;
			tuple_T, T_in_FN, T_in_FM = T_exists<b style="color: red;">|</b>T<b style="color: red;">|</b>;
			equal_B_N = addition_class_initial_unique(B, T, FN, N)(addition_class_FN, tuple_T)(T_in_FN);
			equal_B_M = addition_class_initial_unique(B, T, FM, M)(addition_class_FM, tuple_T)(T_in_FM);
			<b style="color: blue;">return</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltS: <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(S, M)&gt](B, N)(equal_B_N)(equal_B_M);
		}
		ZERO_in_R = R_def(ZERO)(zero_is_natural, ZERO_in_R);
		<b style="color: blue;">prove</b> closure_R: <b style="color: red;">*</b>Y<b style="color: red;">*</b>Y1(Y in R <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(Y, Y1) <b style="color: red;">-&gt</b> Y1 in R){
			<b style="color: blue;">given</b> <b style="color: red;">|</b>Y, Y1<b style="color: red;">|</b>;
			<b style="color: blue;">implies</b> Y_in_R, successor_Y1;
			Y_in_NATURALS, Y_condition = R_def(Y)(Y_in_R);
			Y1_in_NATURALS = closure_naturals(Y, Y1)(Y_in_NATURALS, successor_Y1);
			<b style="color: blue;">prove</b> Y1_in_R: <b style="color: red;">*</b>B<b style="color: red;">*</b>N<b style="color: red;">*</b>M<b style="color: red;">*</b>FN<b style="color: red;">*</b>FM(Y1 in NATURALS <b style="color: red;">&</b> B in NATURALS <b style="color: red;">&</b> is_addition_class(N, FN) <b style="color: red;">&</b> is_addition_class(M, FM) <b style="color: red;">&</b> <b style="color: red;">^</b>T(<b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(Y1, B, T) <b style="color: red;">&</b> T in FN <b style="color: red;">&</b> T in FM) <b style="color: red;">-&gt</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(N, M)){
				<b style="color: blue;">given</b> <b style="color: red;">|</b>B, N, M, FN, FM<b style="color: red;">|</b>;
				<b style="color: blue;">implies</b> Y1_in_NATURALS, B_in_NATURALS, addition_class_FN, addition_class_FM, T_exists;
				tuple_T, T_in_FN, T_in_FM = T_exists<b style="color: red;">|</b>T<b style="color: red;">|</b>;
				
				//First for FN
				other_tuple_T, either_T = <b style="color: green;">expand</b>(addition_class_FN)(T)(T_in_FN)<b style="color: red;">|</b>OTHER_Y1, OTHER_B<b style="color: red;">|</b>;
				equal_Y1, equal_B = <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/tuple_equal_condition.html';" onmouseover="popup_window(this, 'tuple_equal_condition | 01_sets');" onmouseout="close_popup();">tuple_equal_condition</b>(Y1, B, OTHER_Y1, OTHER_B, T, T)(tuple_T, other_tuple_T, <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets_reflexive.html';" onmouseover="popup_window(this, 'equal_sets_reflexive | 00_zf');" onmouseout="close_popup();">equal_sets_reflexive</b>(T));
				T_PRED_exists = <b style="color: green;">branch</b>(either_T, initial_T, T_PRED_exists){
					equal_OTHER_Y1_ZERO, equal_B_N = initial_T;
					equal_Y1_ZERO = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltS: <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(S, ZERO)&gt](Y1, OTHER_Y1)(equal_Y1)(equal_OTHER_Y1_ZERO);
					not_equal_Y1_ZERO = <b style="cursor: pointer;" onclick="window.location.href = '../03_addition/NATURAL_successor_nonzero.html';" onmouseover="popup_window(this, 'NATURAL_successor_nonzero | 03_addition');" onmouseout="close_popup();">NATURAL_successor_nonzero</b>(Y, Y1)(successor_Y1);
					absurdity = not_equal_Y1_ZERO(equal_Y1_ZERO);
					<b style="color: blue;">return</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/axiom_absurdity.html';" onmouseover="popup_window(this, 'axiom_absurdity | 00_zf');" onmouseout="close_popup();">axiom_absurdity</b>[&lt:<b style="color: red;">^</b>Y<b style="color: red;">^</b>B1<b style="color: red;">^</b>T1(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(Y, OTHER_Y1) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(OTHER_B, B1) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(Y, B1, T1) <b style="color: red;">&</b> T1 in FN)&gt](absurdity);
				} <b style="color: green;">or</b> {
					<b style="color: blue;">return</b> T_PRED_exists;
				};
				other_successor_Y1, successor_B1, tuple_T1, T1_in_FN = T_PRED_exists<b style="color: red;">|</b>OTHER_Y, B1, T1<b style="color: red;">|</b>;
				other_successor_Y1 = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltS: <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(OTHER_Y, S)&gt](Y1, OTHER_Y1)(equal_Y1)(other_successor_Y1);
				equal_Y = <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/predecessor_unique.html';" onmouseover="popup_window(this, 'predecessor_unique | 01_sets');" onmouseout="close_popup();">predecessor_unique</b>(Y, OTHER_Y, Y1)(successor_Y1, other_successor_Y1);
				tuple_T1 = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltS: <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(S, B1, T1)&gt](Y, OTHER_Y)(equal_Y)(tuple_T1);
				successor_B1 = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltS: <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(S, B1)&gt](B, OTHER_B)(equal_B)(successor_B1);

				//Now the same for FM
				other_tuple_T, either_T = <b style="color: green;">expand</b>(addition_class_FM)(T)(T_in_FM)<b style="color: red;">|</b>M_OTHER_Y1, M_OTHER_B<b style="color: red;">|</b>;
				equal_Y1, equal_B = <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/tuple_equal_condition.html';" onmouseover="popup_window(this, 'tuple_equal_condition | 01_sets');" onmouseout="close_popup();">tuple_equal_condition</b>(Y1, B, M_OTHER_Y1, M_OTHER_B, T, T)(tuple_T, other_tuple_T, <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets_reflexive.html';" onmouseover="popup_window(this, 'equal_sets_reflexive | 00_zf');" onmouseout="close_popup();">equal_sets_reflexive</b>(T));
				T_PRED_exists = <b style="color: green;">branch</b>(either_T, initial_T, T_PRED_exists){
					equal_M_OTHER_Y1_ZERO, equal_B_N = initial_T;
					equal_Y1_ZERO = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltS: <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(S, ZERO)&gt](Y1, M_OTHER_Y1)(equal_Y1)(equal_M_OTHER_Y1_ZERO);
					not_equal_Y1_ZERO = <b style="cursor: pointer;" onclick="window.location.href = '../03_addition/NATURAL_successor_nonzero.html';" onmouseover="popup_window(this, 'NATURAL_successor_nonzero | 03_addition');" onmouseout="close_popup();">NATURAL_successor_nonzero</b>(Y, Y1)(successor_Y1);
					absurdity = not_equal_Y1_ZERO(equal_Y1_ZERO);
					<b style="color: blue;">return</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/axiom_absurdity.html';" onmouseover="popup_window(this, 'axiom_absurdity | 00_zf');" onmouseout="close_popup();">axiom_absurdity</b>[&lt:<b style="color: red;">^</b>Y<b style="color: red;">^</b>B1<b style="color: red;">^</b>T1(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(Y, M_OTHER_Y1) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(M_OTHER_B, B1) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(Y, B1, T1) <b style="color: red;">&</b> T1 in FM)&gt](absurdity);
				} <b style="color: green;">or</b> {
					<b style="color: blue;">return</b> T_PRED_exists;
				};
				other_successor_Y1, M_successor_B1, tuple_M_T1, M_T1_in_FM = T_PRED_exists<b style="color: red;">|</b>M_OTHER_Y, M_B1, M_T1<b style="color: red;">|</b>;
				other_successor_Y1 = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltS: <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(M_OTHER_Y, S)&gt](Y1, M_OTHER_Y1)(equal_Y1)(other_successor_Y1);
				equal_Y = <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/predecessor_unique.html';" onmouseover="popup_window(this, 'predecessor_unique | 01_sets');" onmouseout="close_popup();">predecessor_unique</b>(Y, M_OTHER_Y, Y1)(successor_Y1, other_successor_Y1);
				tuple_M_T1 = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltS: <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(S, M_B1, M_T1)&gt](Y, M_OTHER_Y)(equal_Y)(tuple_M_T1);
				M_successor_B1 = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltS: <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(S, M_B1)&gt](B, M_OTHER_B)(equal_B)(M_successor_B1);

				B1_in_NATURALS = closure_naturals(B, B1)(B_in_NATURALS, successor_B1);
				equal_B1 = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/successor_unique.html';" onmouseover="popup_window(this, 'successor_unique | 00_zf');" onmouseout="close_popup();">successor_unique</b>(B, B1, M_B1)(successor_B1, M_successor_B1);
				tuple_M_T1 = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltS: <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(Y, S, M_T1)&gt](B1, M_B1)(equal_B1)(tuple_M_T1);
				equal_T1 = <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/tuple_unique.html';" onmouseover="popup_window(this, 'tuple_unique | 01_sets');" onmouseout="close_popup();">tuple_unique</b>(Y, B1, T1, M_T1)(tuple_T1, tuple_M_T1);
				T1_in_FM = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltS: S in FM&gt](T1, M_T1)(equal_T1)(M_T1_in_FM);

				<b style="color: blue;">prove</b> condition: <b style="color: red;">^</b>T1(<b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(Y, B1, T1) <b style="color: red;">&</b> T1 in FN <b style="color: red;">&</b> T1 in FM){
					<b style="color: blue;">choose</b> T1;
					<b style="color: blue;">return</b> tuple_T1, T1_in_FN, T1_in_FM;
				}
				<b style="color: blue;">return</b> Y_condition(B1, N, M, FN, FM)(Y_in_NATURALS, B1_in_NATURALS, addition_class_FN, addition_class_FM, condition);
			}
			<b style="color: blue;">return</b> R_def(Y1)(Y1_in_NATURALS, Y1_in_R);
		}
		NATURALS_subset_R = <b style="cursor: pointer;" onclick="window.location.href = '../03_addition/NATURALS_induction.html';" onmouseover="popup_window(this, 'NATURALS_induction | 03_addition');" onmouseout="close_popup();">NATURALS_induction</b>(R)(ZERO_in_R, closure_R);
		<b style="color: blue;">given</b> <b style="color: red;">|</b>A, B, N, M, FN, FM<b style="color: red;">|</b>;
		<b style="color: blue;">implies</b> premises;
		A_in_NATURALS, rest_of_premises = premises;
		A_in_R = <b style="color: green;">expand</b>(NATURALS_subset_R)(A)(A_in_NATURALS);
		A_in_NATURALS, A_result = R_def(A)(A_in_R);
		<b style="color: blue;">return</b> A_result(B, N, M, FN, FM)(premises);
	}

	//FINALLY! IT'S TIME TO CONSTRUCT THE ADDITION FUNCTION!
	//Here it is!
	addition_function_definition = <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/relation_existence_lemma.html';" onmouseover="popup_window(this, 'relation_existence_lemma | 02_relations');" onmouseout="close_popup();">relation_existence_lemma</b>[&ltT, Y: <b style="color: red;">^</b>F(is_addition_class(Y, F) <b style="color: red;">&</b> T in F)&gt](C, NATURALS)<b style="color: red;">|</b>ADDITION_FUNCTION<b style="color: red;">|</b>;
	<b style="color: blue;">choose</b> ADDITION_FUNCTION;

	//We must first <b style="color: blue;">prove</b> that this is indeed a function
	<b style="color: blue;">prove</b> ADDITION_FUNCTION_is_function: <b style="color: red;">*</b>X<b style="color: red;">*</b>Y<b style="color: red;">*</b>Z(<b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(X, Y, ADDITION_FUNCTION) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(X, Z, ADDITION_FUNCTION) <b style="color: red;">-&gt</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets.html';" onmouseover="popup_window(this, 'equal_sets | 00_zf');" onmouseout="close_popup();">equal_sets</b>(Y, Z)){
		<b style="color: blue;">given</b> <b style="color: red;">|</b>X, Y, Z<b style="color: red;">|</b>;
		<b style="color: blue;">implies</b> related_XY, related_XZ;

		X_in_C, Y_in_NATURALS, F0_exists = addition_function_definition(X, Y)(related_XY);
		addition_class_F0, X_in_F0 = F0_exists<b style="color: red;">|</b>F0<b style="color: red;">|</b>;

		X_in_C, Z_in_NATURALS, F1_exists = addition_function_definition(X, Z)(related_XZ);
		addition_class_F1, X_in_F1 = F1_exists<b style="color: red;">|</b>F1<b style="color: red;">|</b>;

		X0_in_NATURALS, X1_in_NATURALS, tuple_X = C_def(X)(X_in_C)<b style="color: red;">|</b>X0, X1<b style="color: red;">|</b>;
		<b style="color: blue;">prove</b> condition: <b style="color: red;">^</b>X(<b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(X0, X1, X) <b style="color: red;">&</b> X in F0 <b style="color: red;">&</b> X in F1){
			<b style="color: blue;">choose</b> X;
			<b style="color: blue;">return</b> tuple_X, X_in_F0, X_in_F1;
		}

		<b style="color: blue;">return</b> addition_classes_unique(X0, X1, Y, Z, F0, F1)(X0_in_NATURALS, X1_in_NATURALS, addition_class_F0, addition_class_F1, condition);
	}

	ADDITION_FUNCTION_is_function = #<b style="cursor: pointer;" onclick="window.location.href = '../02_relations/is_function.html';" onmouseover="popup_window(this, 'is_function | 02_relations');" onmouseout="close_popup();">is_function</b>(ADDITION_FUNCTION)(ADDITION_FUNCTION_is_function);

	<b style="color: blue;">prove</b> domain_C: <b style="color: red;">*</b>X(X in C <b style="color: red;">-&gt</b> <b style="color: red;">^</b>Y(<b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(X, Y, ADDITION_FUNCTION))){
		<b style="color: blue;">given</b> <b style="color: red;">|</b>X<b style="color: red;">|</b>;
		<b style="color: blue;">implies</b> X_in_C;
		X0_in_NATURALS, X1_in_NATURALS, tuple_X = C_def(X)(X_in_C)<b style="color: red;">|</b>X0, X1<b style="color: red;">|</b>;
		tuple_OTHER_X, Y_in_NATURALS, addition_class_F, OTHER_X_in_F = addition_classes_cover(X1, X0)(X1_in_NATURALS, X0_in_NATURALS)<b style="color: red;">|</b>OTHER_X, Y, F<b style="color: red;">|</b>;
		<b style="color: blue;">choose</b> Y;
		equal_X = <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/tuple_unique.html';" onmouseover="popup_window(this, 'tuple_unique | 01_sets');" onmouseout="close_popup();">tuple_unique</b>(X0, X1, X, OTHER_X)(tuple_X, tuple_OTHER_X);
		X_in_F = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltS: S in F&gt](X, OTHER_X)(equal_X)(OTHER_X_in_F);
		<b style="color: blue;">prove</b> related_XY: <b style="color: red;">^</b>F(is_addition_class(Y, F) <b style="color: red;">&</b> X in F){
			<b style="color: blue;">choose</b> F;
			<b style="color: blue;">return</b> addition_class_F, X_in_F;
		}
		<b style="color: blue;">return</b> addition_function_definition(X, Y)(X_in_C, Y_in_NATURALS, related_XY);
	}

	domain_C = #<b style="cursor: pointer;" onclick="window.location.href = '../02_relations/is_domain.html';" onmouseover="popup_window(this, 'is_domain | 02_relations');" onmouseout="close_popup();">is_domain</b>(ADDITION_FUNCTION, C)(domain_C);

	<b style="color: blue;">prove</b> domain_exists: <b style="color: red;">^</b>T(<b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_cross_product.html';" onmouseover="popup_window(this, 'is_cross_product | 01_sets');" onmouseout="close_popup();">is_cross_product</b>(NATURALS, NATURALS, T) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/is_domain.html';" onmouseover="popup_window(this, 'is_domain | 02_relations');" onmouseout="close_popup();">is_domain</b>(ADDITION_FUNCTION, T)){
		<b style="color: blue;">choose</b> C;
		<b style="color: blue;">return</b> C_cross_product, domain_C;
	}

	<b style="color: blue;">prove</b> codomain_NATURALS: <b style="color: red;">*</b>X<b style="color: red;">*</b>Y(<b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(X, Y, ADDITION_FUNCTION) <b style="color: red;">-&gt</b> Y in NATURALS){
		<b style="color: blue;">given</b> <b style="color: red;">|</b>X, Y<b style="color: red;">|</b>;
		<b style="color: blue;">implies</b> related_XY;
		X_in_C, Y_in_NATURALS, addition_class_exists = addition_function_definition(X, Y)(related_XY);
		<b style="color: blue;">return</b> Y_in_NATURALS;
	}

	codomain_NATURALS = #<b style="cursor: pointer;" onclick="window.location.href = '../02_relations/is_codomain.html';" onmouseover="popup_window(this, 'is_codomain | 02_relations');" onmouseout="close_popup();">is_codomain</b>(ADDITION_FUNCTION, NATURALS)(codomain_NATURALS);

	<b style="color: blue;">prove</b> zero_identity: <b style="color: red;">*</b>X<b style="color: red;">*</b>Z(X in NATURALS <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(ZERO, X, Z) <b style="color: red;">-&gt</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(Z, X, ADDITION_FUNCTION)){
		<b style="color: blue;">given</b> <b style="color: red;">|</b>X, Z<b style="color: red;">|</b>;
		<b style="color: blue;">implies</b> X_in_NATURALS, tuple_Z;
		addition_class_F, F_subset_C = addition_classes_exist(X)(X_in_NATURALS)<b style="color: red;">|</b>F<b style="color: red;">|</b>;
		Z_in_F = addition_class_initial_unique(X, Z, F, X)(addition_class_F, tuple_Z)(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets_reflexive.html';" onmouseover="popup_window(this, 'equal_sets_reflexive | 00_zf');" onmouseout="close_popup();">equal_sets_reflexive</b>(X));
		<b style="color: blue;">prove</b> related_ZX: <b style="color: red;">^</b>F(is_addition_class(X, F) <b style="color: red;">&</b> Z in F){
			<b style="color: blue;">choose</b> F;
			<b style="color: blue;">return</b> addition_class_F, Z_in_F;
		}
		Z_in_C = <b style="color: green;">expand</b>(F_subset_C)(Z)(Z_in_F);
		<b style="color: blue;">return</b> addition_function_definition(Z, X)(Z_in_C, X_in_NATURALS, related_ZX);
	}

	<b style="color: blue;">prove</b> successor_recursion: <b style="color: red;">*</b>X<b style="color: red;">*</b>Y<b style="color: red;">*</b>T0<b style="color: red;">*</b>Z0(<b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(X, Y, T0) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(T0, Z0, ADDITION_FUNCTION) <b style="color: red;">-&gt</b> <b style="color: red;">^</b>SX<b style="color: red;">^</b>T1<b style="color: red;">^</b>Z1(<b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(X, SX) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(SX, Y, T1) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../02_relations/are_related.html';" onmouseover="popup_window(this, 'are_related | 02_relations');" onmouseout="close_popup();">are_related</b>(T1, Z1, ADDITION_FUNCTION) <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/is_successor.html';" onmouseover="popup_window(this, 'is_successor | 00_zf');" onmouseout="close_popup();">is_successor</b>(Z0, Z1))){
		<b style="color: blue;">given</b> <b style="color: red;">|</b>X, Y, T0, Z0<b style="color: red;">|</b>;
		<b style="color: blue;">implies</b> tuple_T0, related_T0Z0;
		T0_in_C, Z0_in_NATURALS, addition_class_exists = addition_function_definition(T0, Z0)(related_T0Z0);
		addition_class_F0, T0_in_F0 = addition_class_exists<b style="color: red;">|</b>F0<b style="color: red;">|</b>;
		OTHER_X_in_NATURALS, OTHER_Y_in_NATURALS, other_tuple_T0 = C_def(T0)(T0_in_C)<b style="color: red;">|</b>OTHER_X, OTHER_Y<b style="color: red;">|</b>;
		equal_X, equal_Y = <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/tuple_equal_condition.html';" onmouseover="popup_window(this, 'tuple_equal_condition | 01_sets');" onmouseout="close_popup();">tuple_equal_condition</b>(X, Y, OTHER_X, OTHER_Y, T0, T0)(tuple_T0, other_tuple_T0, <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equal_sets_reflexive.html';" onmouseover="popup_window(this, 'equal_sets_reflexive | 00_zf');" onmouseout="close_popup();">equal_sets_reflexive</b>(T0));
		X_in_NATURALS = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltS: S in NATURALS&gt](X, OTHER_X)(equal_X)(OTHER_X_in_NATURALS);
		Y_in_NATURALS = <b style="cursor: pointer;" onclick="window.location.href = '../00_zf/equality_consistency.html';" onmouseover="popup_window(this, 'equality_consistency | 00_zf');" onmouseout="close_popup();">equality_consistency</b>[&ltS: S in NATURALS&gt](Y, OTHER_Y)(equal_Y)(OTHER_Y_in_NATURALS);
		successor_SX, successor_Z1, addition_class_F1, tuple_T1, T1_in_F1 = addition_classes_cover_lemma(X)(X_in_NATURALS)(Y, T0, F0, Z0)(Z0_in_NATURALS, addition_class_F0, tuple_T0, T0_in_F0)<b style="color: red;">|</b>SX, T1, Z1, F1<b style="color: red;">|</b>;
		<b style="color: blue;">choose</b> SX, T1, Z1;
		SX_in_NATURALS = closure_naturals(X, SX)(X_in_NATURALS, successor_SX);
		<b style="color: blue;">prove</b> T1_in_C: <b style="color: red;">^</b>SX<b style="color: red;">^</b>Y(SX in NATURALS <b style="color: red;">&</b> Y in NATURALS <b style="color: red;">&</b> <b style="cursor: pointer;" onclick="window.location.href = '../01_sets/is_tuple.html';" onmouseover="popup_window(this, 'is_tuple | 01_sets');" onmouseout="close_popup();">is_tuple</b>(SX, Y, T1)){
			<b style="color: blue;">choose</b> SX, Y;
			<b style="color: blue;">return</b> SX_in_NATURALS, Y_in_NATURALS, tuple_T1;
		}
		T1_in_C = C_def(T1)(T1_in_C);
		Z1_in_NATURALS = closure_naturals(Z0, Z1)(Z0_in_NATURALS, successor_Z1);
		<b style="color: blue;">prove</b> addition_class_exists: <b style="color: red;">^</b>F1(is_addition_class(Z1, F1) <b style="color: red;">&</b> T1 in F1){
			<b style="color: blue;">choose</b> F1;
			<b style="color: blue;">return</b> addition_class_F1, T1_in_F1;
		}
		related_T1Z1 = addition_function_definition(T1, Z1)(T1_in_C, Z1_in_NATURALS, addition_class_exists);
		<b style="color: blue;">return</b> successor_SX, tuple_T1, related_T1Z1, successor_Z1;
	}

	//Holy shit!
	<b style="color: blue;">return</b> #<b style="cursor: pointer;" onclick="window.location.href = '../03_addition/is_addition_function.html';" onmouseover="popup_window(this, 'is_addition_function | 03_addition');" onmouseout="close_popup();">is_addition_function</b>(ADDITION_FUNCTION)(ADDITION_FUNCTION_is_function, domain_exists, codomain_NATURALS, zero_identity, successor_recursion);
}</code></div></div></body>
<div id="popup" style="display: none; position: absolute; padding: 2px; border: 2px solid black; border-radius: 2px; background: white;"></div>
<script type="text/javascript">
popup = document.getElementById("popup");
function popup_window(dom, text){
	rect = dom.getBoundingClientRect()
	popup.innerHTML = text;
	popup.style.top = rect.bottom + window.scrollY + 5 + "px";
	popup.style.left = rect.left + window.scrollX + "px";
	popup.style.display = "inline-block";
}
function close_popup(){
	popup.style.display = "none";
}
</script>
</html>