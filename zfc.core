//First we define when two sets are equal and when a set is non-empty

define equal_sets(A, B): *X((X in A -> X in B) & (X in B -> X in A));
define non_empty(A): ^X(X in A);

//The first axiom of zfc: the axiom of extensionality
//If two sets have the same members, they are members of the same sets
axiom axiom_extensionality: *A*B(equal_sets(A, B) -> *W((A in W -> B in W) & (B in W -> A in W)));

//The second axiom of zfc: the axiom of regularity
//Every nonempty set has an element which is disjoint to it
axiom axiom_regularity: *A(non_empty(A) -> ^B(B in A & *C(~C in B | ~C in A)));

//The third axiom of zfc: the axiom schema of specification
//For every set and proposition, a subset of elements satisfying the proposition can be defined
//This is the first of the axioms which has a bound proposition
axiom axiom_specify[P(1)]: *A^B*X((X in B -> X in A & P(X)) & (X in A & P(X) -> X in B));

//The fourth axiom of zfc: the axiom of pairing
//For any two sets, there is a set which contains both
axiom axiom_pairing: *A*B^C(A in C & B in C);

//The fifth axiom of zfc: the axiom of union
//For any set there is another set contiaining the union over all elements of it
axiom axiom_union: *F^A*Y*X((X in Y & Y in F) -> X in A);

//The sixth axiom of zfc: the axiom of replacement
//Basically, the "image" of a proposition with an independent variable coming from inside of a set lies inside of another set
axiom axiom_replacement[P(3)]: *A(*X(X in A -> ^Y(P(X, Y, A) & *Z(P(X, Z, A) -> equal_sets(Y, Z)))) -> ^B*Y((Y in B -> ^X(X in A & P(X, Y, A))) & (^X(X in A & P(X, Y, A)) -> Y in B)));

//For the axiom of infinity, we need to define the successor of a set S with finite cardinality as S union {S}. To do this we need to show that such a set exists and is unique.

//First we define when A is a subset of B
define is_subset(A, B): *X(X in A -> X in B);

//Here I define the expand of a set

//A set is equal to itself
prove equal_sets_reflexive: *A(equal_sets(A, A)){
	given A{
		prove def: *X((X in A -> X in A) & (X in A -> X in A)){
			given X{
				prove lemma: X in A -> X in A{
					implies p{
						return p;
					}
				}
				return axiom_and_combine[lemma][lemma](lemma)(lemma);
			}
		}
		return #equal_sets(A)(A)(def);
	}
}

//For any S, the set {S} exists
prove successor_lemma0: *S^T(S in T & *X(X in T -> equal_sets(X, S))){
	given S{
		S_in_T = left(axiom_pairing(S)(S)(T));
		define X_equal_S(X): equal_sets(X, S);
		specified = axiom_specify[(X_equal_S)](T)(NEW_T);
		choose NEW_T{
			prove lemma0: *X(X in NEW_T -> equal_sets(X, S)){
				given X{
					implies p{
						return right(left(specified(X))(p));
					}
				}
			}
			prove lemma1: S in NEW_T{
				S_equal_S = equal_sets_reflexive(S);
				a = axiom_and_combine[S_in_T][S_equal_S](S_in_T)(S_equal_S);
				return right(specified(S))(a);
			}
			return axiom_and_combine[lemma1][lemma0](lemma1)(lemma0);
		}
	}
}

//Now we define what {S} is
//B is the expand of A (B = {A})
define is_expand(A, B): *X((X in B -> equal_sets(X, A)) & (equal_sets(X, A) -> X in B));

//Prove that the expand of any set exists
prove expand_exists: *A^B(is_expand(A, B)){
	given A{
		def = successor_lemma0(A)(B);
		right_part = right(def);
		A_in_B = left(def);
		choose B{
			prove lemma: *X(equal_sets(X, A) -> X in B){
				given X{
					implies p{
						ext = axiom_extensionality(X)(A);
						in_same_sets = ext(p);
						return right(in_same_sets(B))(A_in_B);
					}
				}
			}
			prove combine: *X((X in B -> equal_sets(X, A)) & (equal_sets(X, A) -> X in B)){
				given X{
					side0 = right_part(X);
					side1 = lemma(X);
					return axiom_and_combine[side0][side1](side0)(side1);
				}
			}
			return #is_expand(A)(B)(combine);
		}
	}
}

//Prove that the expand is unique
prove expand_unique: *A*B*C(is_expand(A, B) & is_expand(A, C) -> equal_sets(B, C)){
	given A{
		given B{
			given C{
				implies p{
					expandAB = left(p);
					expandAC = right(p);
					prove def: *X((X in B -> X in C) & (X in C -> X in B)){
						given X{
							prove lemma0: X in B -> X in C{
								implies q{
									X_equal_A = left(is_expand#(A)(B)(expandAB)(X))(q);
									return right(is_expand#(A)(C)(expandAC)(X))(X_equal_A);
								}
							}
							prove lemma1: X in C -> X in B{
								implies q{
									X_equal_A = left(is_expand#(A)(C)(expandAC)(X))(q);
									return right(is_expand#(A)(B)(expandAB)(X))(X_equal_A);
								}
							}
							return axiom_and_combine[lemma0][lemma1](lemma0)(lemma1);
						}
					}
					return #equal_sets(B)(C)(def);
				}
			}
		}
	}
}

//Now for any sets A and B, we define when a set C is the set {A, B}
define is_pair(A, B, C): *X((X in C -> equal_sets(X, A) | equal_sets(X, B)) & (equal_sets(X, A) | equal_sets(X, B) -> X in C));

//For any sets A and B, the pair {A, B} exists
prove pair_exists: *A*B^C(is_pair(A, B, C)){
	given A{
		given B{
			pair_statement = axiom_pairing(A)(B)(BIG_C);
			A_in_BIG_C = left(pair_statement);
			B_in_BIG_C = right(pair_statement);
			define restriction(X): equal_sets(X, A) | equal_sets(X, B);
			specify_statement = axiom_specify[(restriction)](BIG_C)(C);
			choose C{
				prove def: *X((X in C -> equal_sets(X, A) | equal_sets(X, B)) & (equal_sets(X, A) | equal_sets(X, B) -> X in C)){
					given X{
						prove part0: X in C -> equal_sets(X, A) | equal_sets(X, B){
							implies p{
								return right(left(specify_statement(X))(p));
							}
						}
						prove part1: equal_sets(X, A) | equal_sets(X, B) -> X in C{
							implies p{
								return branch(p, sets_equal){
									ext = axiom_extensionality(X)(A);
									membership = right(ext(sets_equal)(C));
									A_equals_A = equal_sets_reflexive(A);
									define A_equals_B: equal_sets(A, B);
									or_statement = axiom_or_combine[A_equals_A][(A_equals_B)](A_equals_A);
									and_statement = axiom_and_combine[A_in_BIG_C][or_statement](A_in_BIG_C)(or_statement);
									A_in_C = right(specify_statement(A))(and_statement);
									return membership(A_in_C);
								} or {
									ext = axiom_extensionality(X)(B);
									membership = right(ext(sets_equal)(C));
									B_equals_B = equal_sets_reflexive(B);
									define B_equals_A: equal_sets(B, A);
									or_statement = swap(axiom_or_combine[B_equals_B][(B_equals_A)](B_equals_B));
									and_statement = axiom_and_combine[B_in_BIG_C][or_statement](B_in_BIG_C)(or_statement);
									B_in_C = right(specify_statement(B))(and_statement);
									return membership(B_in_C);
								};
							}
						}
						return axiom_and_combine[part0][part1](part0)(part1);
					}
				}
				return #is_pair(A)(B)(C)(def);
			}
		}
	}
}

//Pairs {A, B} are unique with respect to A and B
prove pair_unique: *A*B*C*D(is_pair(A, B, C) & is_pair(A, B, D) -> equal_sets(C, D)){
	given A{
		given B{
			given C{
				given D{
					implies p{
						pairC = left(p);
						pairD = right(p);
						defC = is_pair#(A)(B)(C)(pairC);
						defD = is_pair#(A)(B)(D)(pairD);
						prove def: *X((X in C -> X in D) & (X in D -> X in C)){
							given X{
								prove lemma0: X in C -> X in D{
									implies q{
										equal_or = left(defC(X))(q);
										return right(defD(X))(equal_or);
									}
								}
								prove lemma1: X in D -> X in C{
									implies q{
										equal_or = left(defD(X))(q);
										return right(defC(X))(equal_or);
									}
								}
								return axiom_and_combine[lemma0][lemma1](lemma0)(lemma1);
							}
						}
						return #equal_sets(C)(D)(def);
					}
				}
			}
		}
	}
}

//To simplify the proof of the existence of the successor, we need the existence and uniqueness of the union
define is_union(A, B): *X((^Y(X in Y & Y in A) -> X in B) & (X in B -> ^Y(X in Y & Y in A)));

//Prove that the union exists
prove union_exists: *A^B(is_union(A, B)){
	given A{
		part0 = axiom_union(A)(BIG_B);
		define restriction(X): ^Y(X in Y & Y in A);
		restrict = axiom_specify[(restriction)](BIG_B)(B);
		choose B{
			prove def: *X((^Y(X in Y & Y in A) -> X in B) & (X in B -> ^Y(X in Y & Y in A))){
				given X{
					prove lemma0: ^Y(X in Y & Y in A) -> X in B{
						implies p{
							new_p = p(Y);
							new_part0 = part0(Y)(X);
							X_in_BIG_B = new_part0(new_p);
							and_premise = axiom_and_combine[X_in_BIG_B][p](X_in_BIG_B)(p);
							return right(restrict(X))(and_premise);
						}
					}
					prove lemma1: X in B -> ^Y(X in Y & Y in A){
						implies X_in_B{
							return right(left(restrict(X))(X_in_B));
						}
					}
					return axiom_and_combine[lemma0][lemma1](lemma0)(lemma1);
				}
			}
			return #is_union(A)(B)(def);
		}
	}
}

prove union_unique: *A*B*C(is_union(A, B) & is_union(A, C) -> equal_sets(B, C)){
	given A{
		given B{
			given C{
				implies both{
					AB = is_union#(A)(B)(left(both));
					AC = is_union#(A)(C)(right(both));
					prove def: *X((X in B -> X in C) & (X in C -> X in B)){
						given X{
							prove lemma0: X in B -> X in C{
								implies X_in_B{
									return left(AC(X))(right(AB(X))(X_in_B));
								}
							}
							prove lemma1: X in C -> X in B{
								implies X_in_C{
									return left(AB(X))(right(AC(X))(X_in_C));
								}
							}
							return axiom_and_combine[lemma0][lemma1](lemma0)(lemma1);
						}
					}
					return #equal_sets(B)(C)(def);
				}
			}
		}
	}
}

//We define the successor of A to be A union {A}
define is_successor(A, B): ^C^D(is_expand(A, C) & is_pair(A, C, D) & is_union(D, B));

prove successor_exists: *A^B(is_successor(A, B)){
	given A{
		expand = expand_exists(A)(C);
		pair = pair_exists(A)(C)(D);
		union = union_exists(D)(B);
		choose B{
			part0 = axiom_and_combine[expand][pair](expand)(pair);
			part1 = axiom_and_combine[part0][union](part0)(union);
			prove def: ^C^D(is_expand(A, C) & is_pair(A, C, D) & is_union(D, B)){
				choose C{
					choose D{
						return part1;
					}
				}
			}
			return #is_successor(A)(B)(def);
		}
	}
}

//In order to really use the results on the uniqueness of pairs and unions, we need the following AXIOM
//What it says is that if two sets are equal under the given definition, then for any proposition depending on a set, that proposition is true for one if and only if it is true for the other
//This axiom is valid because for any particular proposition, one can prove the fact using the definition of equal sets and the axiom of extensionality
//In other words, it doesn't change the strength of the theory, it just makes proofs more convenient
//In theories with an = sign, this says that 'equal_sets' behaves like =
axiom equality_consistency[P(1)]: *X*Y(equal_sets(X, Y) -> ((P(X) -> P(Y)) & (P(Y) -> P(X))));

prove successor_unique: *A*B*C(is_successor(A, B) & is_successor(A, C) -> equal_sets(B, C)){
	given A{
		given B{
			given C{
				implies both{
					defAB = is_successor#(A)(B)(left(both))(C_AB)(D_AB);
					defAC = is_successor#(A)(C)(right(both))(C_AC)(D_AC);
					expand_AB = left(left(defAB));
					expand_AC = left(left(defAC));
					C_AB_equals_C_AC = expand_unique(A)(C_AB)(C_AC)(axiom_and_combine[expand_AB][expand_AC](expand_AB)(expand_AC));
					pair_AB = right(left(defAB));
					pair_AC = right(left(defAC));
					define pair_same(X): is_pair(A, X, D_AB);
					other_pair_AC = left(equality_consistency[(pair_same)](C_AB)(C_AC)(C_AB_equals_C_AC))(pair_AB);
					D_AB_equals_D_AC = pair_unique(A)(C_AC)(D_AB)(D_AC)(axiom_and_combine[other_pair_AC][pair_AC](other_pair_AC)(pair_AC));
					union_AB = right(defAB);
					union_AC = right(defAC);
					define union_same(X): is_union(X, B);
					other_union_AC = left(equality_consistency[(union_same)](D_AB)(D_AC)(D_AB_equals_D_AC))(union_AB);
					return union_unique(D_AC)(B)(C)(axiom_and_combine[other_union_AC][union_AC](other_union_AC)(union_AC));
				}
			}
		}
	}
}

//Define when a set is empty
define is_empty(A): *X(~X in A);

//The seventh axiom of zfc: the axiom of infinity
//A set containing the natural numbers exists
axiom axiom_infinity: ^X(^E(E in X & is_empty(E)) & *Y*Z(Y in X & is_successor(Y, Z) -> Z in X));

//The eighth axiom of zfc: the axiom of the power set
//For any set A there is a set of all subsets of A
axiom axiom_power_set: *X^Y*Z(is_subset(Z, X) -> Z in Y);

