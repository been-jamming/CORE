//First we define when two sets are equal and when a set is non-empty

define equal_sets(A, B): *X((X in A -> X in B) & (X in B -> X in A));
define non_empty(A): ^X(X in A);

//In order to make proofs more convenient, we need the following axiom
//What it says is that if two sets are equal under the given definition, then for any proposition depending on a set, that proposition is true for one if and only if it is true for the other
//This axiom is valid because for any particular proposition, one can prove the fact using the definition of equal sets and the axiom of extensionality
//In other words, it doesn't change the strength of the theory, it just makes proofs more convenient
axiom equality_consistency[P(1)]: *X*Y(equal_sets(X, Y) -> ((P(X) -> P(Y)) & (P(Y) -> P(X))));

//The first axiom of zfc: the axiom of extensionality
//If two sets have the same members, they are members of the same sets
//It can be proven using equality_consistency
prove axiom_extensionality: *A*B(equal_sets(A, B) -> *W((A in W -> B in W) & (B in W -> A in W))){
	given A{
		given B{
			implies A_equal_B{
				given W{
					define in_W(X): X in W;
					return equality_consistency[(in_W)](A)(B)(A_equal_B);
				}
			}
		}
	}
}

//The second axiom of zfc: the axiom of regularity
//Every nonempty set has an element which is disjoint to it
axiom axiom_regularity: *A(non_empty(A) -> ^B(B in A & *C(~C in B | ~C in A)));

//The third axiom of zfc: the axiom schema of specification
//For every set and proposition, a subset of elements satisfying the proposition can be defined
//This is the first of the axioms which has a bound proposition
axiom axiom_specify[P(1)]: *A^B*X((X in B -> X in A & P(X)) & (X in A & P(X) -> X in B));

//The fourth axiom of zfc: the axiom of pairing
//For any two sets, there is a set which contains both
axiom axiom_pairing: *A*B^C(A in C & B in C);

//The fifth axiom of zfc: the axiom of union
//For any set there is another set contiaining the union over all elements of it
axiom axiom_union: *F^A*Y*X((X in Y & Y in F) -> X in A);

//The sixth axiom of zfc: the axiom of replacement
//Basically, the "image" of a proposition with an independent variable coming from inside of a set lies inside of another set
axiom axiom_replacement[P(3)]: *A(*X(X in A -> ^Y(P(X, Y, A) & *Z(P(X, Z, A) -> equal_sets(Y, Z)))) -> ^B*Y((Y in B -> ^X(X in A & P(X, Y, A))) & (^X(X in A & P(X, Y, A)) -> Y in B)));

//For the axiom of infinity, we need to define the successor of a set S with finite cardinality as S union {S}. To do this we need to show that such a set exists and is unique.

//First we define when A is a subset of B
define is_subset(A, B): *X(X in A -> X in B);

//Here I define the expand of a set

//A set is equal to itself
prove equal_sets_reflexive: *A(equal_sets(A, A)){
	given A{
		prove def: *X((X in A -> X in A) & (X in A -> X in A)){
			given X{
				prove lemma: X in A -> X in A{
					implies p{
						return p;
					}
				}
				return and(lemma, lemma);
			}
		}
		return #equal_sets(A)(A)(def);
	}
}

//For any S, the set {S} exists
prove successor_lemma0: *S^T(S in T & *X(X in T -> equal_sets(X, S))){
	given S{
		S_in_T = left(axiom_pairing(S)(S)(T));
		define X_equal_S(X): equal_sets(X, S);
		specified = axiom_specify[(X_equal_S)](T)(NEW_T);
		choose NEW_T{
			prove lemma0: *X(X in NEW_T -> equal_sets(X, S)){
				given X{
					implies p{
						return right(left(specified(X))(p));
					}
				}
			}
			prove lemma1: S in NEW_T{
				S_equal_S = equal_sets_reflexive(S);
				a = and(S_in_T, S_equal_S);
				return right(specified(S))(a);
			}
			return and(lemma1, lemma0);
		}
	}
}

//Now we define what {S} is
//B is the expand of A (B = {A})
define is_expand(A, B): *X((X in B -> equal_sets(X, A)) & (equal_sets(X, A) -> X in B));

//Prove that the expand of any set exists
prove expand_exists: *A^B(is_expand(A, B)){
	given A{
		def = successor_lemma0(A)(B);
		right_part = right(def);
		A_in_B = left(def);
		choose B{
			prove lemma: *X(equal_sets(X, A) -> X in B){
				given X{
					implies p{
						ext = axiom_extensionality(X)(A);
						in_same_sets = ext(p);
						return right(in_same_sets(B))(A_in_B);
					}
				}
			}
			prove combine: *X((X in B -> equal_sets(X, A)) & (equal_sets(X, A) -> X in B)){
				given X{
					side0 = right_part(X);
					side1 = lemma(X);
					return and(side0, side1);
				}
			}
			return #is_expand(A)(B)(combine);
		}
	}
}

//Prove that the expand is unique
prove expand_unique: *A*B*C(is_expand(A, B) & is_expand(A, C) -> equal_sets(B, C)){
	given A{
		given B{
			given C{
				implies p{
					expandAB = left(p);
					expandAC = right(p);
					prove def: *X((X in B -> X in C) & (X in C -> X in B)){
						given X{
							prove lemma0: X in B -> X in C{
								implies q{
									X_equal_A = left(is_expand#(A)(B)(expandAB)(X))(q);
									return right(is_expand#(A)(C)(expandAC)(X))(X_equal_A);
								}
							}
							prove lemma1: X in C -> X in B{
								implies q{
									X_equal_A = left(is_expand#(A)(C)(expandAC)(X))(q);
									return right(is_expand#(A)(B)(expandAB)(X))(X_equal_A);
								}
							}
							return and(lemma0, lemma1);
						}
					}
					return #equal_sets(B)(C)(def);
				}
			}
		}
	}
}

//Now for any sets A and B, we define when a set C is the set {A, B}
define is_pair(A, B, C): *X((X in C -> equal_sets(X, A) | equal_sets(X, B)) & (equal_sets(X, A) | equal_sets(X, B) -> X in C));

//For any sets A and B, the pair {A, B} exists
prove pair_exists: *A*B^C(is_pair(A, B, C)){
	given A{
		given B{
			pair_statement = axiom_pairing(A)(B)(BIG_C);
			A_in_BIG_C = left(pair_statement);
			B_in_BIG_C = right(pair_statement);
			define restriction(X): equal_sets(X, A) | equal_sets(X, B);
			specify_statement = axiom_specify[(restriction)](BIG_C)(C);
			choose C{
				prove def: *X((X in C -> equal_sets(X, A) | equal_sets(X, B)) & (equal_sets(X, A) | equal_sets(X, B) -> X in C)){
					given X{
						prove part0: X in C -> equal_sets(X, A) | equal_sets(X, B){
							implies p{
								return right(left(specify_statement(X))(p));
							}
						}
						prove part1: equal_sets(X, A) | equal_sets(X, B) -> X in C{
							implies p{
								return branch(p, sets_equal, sets_equal){
									ext = axiom_extensionality(X)(A);
									membership = right(ext(sets_equal)(C));
									A_equals_A = equal_sets_reflexive(A);
									define A_equals_B: equal_sets(A, B);
									or_statement = or(A_equals_A, (A_equals_B));
									and_statement = and(A_in_BIG_C, or_statement);
									A_in_C = right(specify_statement(A))(and_statement);
									return membership(A_in_C);
								} or {
									ext = axiom_extensionality(X)(B);
									membership = right(ext(sets_equal)(C));
									B_equals_B = equal_sets_reflexive(B);
									define B_equals_A: equal_sets(B, A);
									or_statement = swap(or(B_equals_B, (B_equals_A)));
									and_statement = and(B_in_BIG_C, or_statement);
									B_in_C = right(specify_statement(B))(and_statement);
									return membership(B_in_C);
								};
							}
						}
						return and(part0, part1);
					}
				}
				return #is_pair(A)(B)(C)(def);
			}
		}
	}
}

//Pairs {A, B} are unique with respect to A and B
prove pair_unique: *A*B*C*D(is_pair(A, B, C) & is_pair(A, B, D) -> equal_sets(C, D)){
	given A{
		given B{
			given C{
				given D{
					implies p{
						pairC = left(p);
						pairD = right(p);
						defC = is_pair#(A)(B)(C)(pairC);
						defD = is_pair#(A)(B)(D)(pairD);
						prove def: *X((X in C -> X in D) & (X in D -> X in C)){
							given X{
								prove lemma0: X in C -> X in D{
									implies q{
										equal_or = left(defC(X))(q);
										return right(defD(X))(equal_or);
									}
								}
								prove lemma1: X in D -> X in C{
									implies q{
										equal_or = left(defD(X))(q);
										return right(defC(X))(equal_or);
									}
								}
								return and(lemma0, lemma1);
							}
						}
						return #equal_sets(C)(D)(def);
					}
				}
			}
		}
	}
}

//To simplify the proof of the existence of the successor, we need the existence and uniqueness of the union
define is_union(A, B): *X((^Y(X in Y & Y in A) -> X in B) & (X in B -> ^Y(X in Y & Y in A)));

//Prove that the union exists
prove union_exists: *A^B(is_union(A, B)){
	given A{
		part0 = axiom_union(A)(BIG_B);
		define restriction(X): ^Y(X in Y & Y in A);
		restrict = axiom_specify[(restriction)](BIG_B)(B);
		choose B{
			prove def: *X((^Y(X in Y & Y in A) -> X in B) & (X in B -> ^Y(X in Y & Y in A))){
				given X{
					prove lemma0: ^Y(X in Y & Y in A) -> X in B{
						implies p{
							new_p = p(Y);
							new_part0 = part0(Y)(X);
							X_in_BIG_B = new_part0(new_p);
							and_premise = and(X_in_BIG_B, p);
							return right(restrict(X))(and_premise);
						}
					}
					prove lemma1: X in B -> ^Y(X in Y & Y in A){
						implies X_in_B{
							return right(left(restrict(X))(X_in_B));
						}
					}
					return and(lemma0, lemma1);
				}
			}
			return #is_union(A)(B)(def);
		}
	}
}

prove union_unique: *A*B*C(is_union(A, B) & is_union(A, C) -> equal_sets(B, C)){
	given A{
		given B{
			given C{
				implies both{
					AB = is_union#(A)(B)(left(both));
					AC = is_union#(A)(C)(right(both));
					prove def: *X((X in B -> X in C) & (X in C -> X in B)){
						given X{
							prove lemma0: X in B -> X in C{
								implies X_in_B{
									return left(AC(X))(right(AB(X))(X_in_B));
								}
							}
							prove lemma1: X in C -> X in B{
								implies X_in_C{
									return left(AB(X))(right(AC(X))(X_in_C));
								}
							}
							return and(lemma0, lemma1);
						}
					}
					return #equal_sets(B)(C)(def);
				}
			}
		}
	}
}

//We define the successor of A to be A union {A}
define is_successor(A, B): ^C^D(is_expand(A, C) & is_pair(A, C, D) & is_union(D, B));

prove successor_exists: *A^B(is_successor(A, B)){
	given A{
		expand = expand_exists(A)(C);
		pair = pair_exists(A)(C)(D);
		union = union_exists(D)(B);
		choose B{
			part0 = and(expand, pair);
			part1 = and(part0, union);
			prove def: ^C^D(is_expand(A, C) & is_pair(A, C, D) & is_union(D, B)){
				choose C{
					choose D{
						return part1;
					}
				}
			}
			return #is_successor(A)(B)(def);
		}
	}
}

prove successor_unique: *A*B*C(is_successor(A, B) & is_successor(A, C) -> equal_sets(B, C)){
	given A{
		given B{
			given C{
				implies both{
					defAB = is_successor#(A)(B)(left(both))(C_AB)(D_AB);
					defAC = is_successor#(A)(C)(right(both))(C_AC)(D_AC);
					expand_AB = left(left(defAB));
					expand_AC = left(left(defAC));
					C_AB_equals_C_AC = expand_unique(A)(C_AB)(C_AC)(and(expand_AB, expand_AC));
					pair_AB = right(left(defAB));
					pair_AC = right(left(defAC));
					define pair_same(X): is_pair(A, X, D_AB);
					other_pair_AC = left(equality_consistency[(pair_same)](C_AB)(C_AC)(C_AB_equals_C_AC))(pair_AB);
					D_AB_equals_D_AC = pair_unique(A)(C_AC)(D_AB)(D_AC)(and(other_pair_AC, pair_AC));
					union_AB = right(defAB);
					union_AC = right(defAC);
					define union_same(X): is_union(X, B);
					other_union_AC = left(equality_consistency[(union_same)](D_AB)(D_AC)(D_AB_equals_D_AC))(union_AB);
					return union_unique(D_AC)(B)(C)(and(other_union_AC, union_AC));
				}
			}
		}
	}
}

//Define when a set is empty
define is_empty(A): *X(~X in A);

//Define what an inductive set is
define is_inductive_set(X): ^E(E in X & is_empty(E)) & *Y*Z(Y in X & is_successor(Y, Z) -> Z in X);

//The seventh axiom of zfc: the axiom of infinity
//There is an inductive set
axiom axiom_infinity: ^X(is_inductive_set(X));

//The eighth axiom of zfc: the axiom of the power set
//For any set A there is a set of all subsets of A
axiom axiom_power_set: *X^Y*Z(is_subset(Z, X) -> Z in Y);

//These are all of the ZF axioms!

//The existence of the empty set
prove empty_set_exists: ^E*X(~X in E){
	inductive = axiom_infinity(X);
	empty = right(left(is_inductive_set#(X)(inductive))(E));
	choose E{
		return is_empty#(E)(empty);
	}
}

//The uniqueness of the empty set
prove empty_set_unique: *E*F(is_empty(E) & is_empty(F) -> equal_sets(E, F)){
	given E{
		given F{
			implies both{
				empty_E = is_empty#(E)(left(both));
				empty_F = is_empty#(F)(right(both));
				prove def: *X((X in E -> X in F) & (X in F -> X in E)){
					given X{
						define X_in_E: X in E;
						define X_in_F: X in F;
						prove lemma0: X in E -> X in F{
							implies p{
								return axiom_absurdity[(X_in_F)](empty_E(X)(p));
							}
						}
						prove lemma1: X in F -> X in E{
							implies p{
								return axiom_absurdity[(X_in_E)](empty_F(X)(p));
							}
						}
						return and(lemma0, lemma1);
					}
				}
				return #equal_sets(E)(F)(def);
			}
		}
	}
}

empty_set_condition = empty_set_exists(EMPTY_SET);

//Now we want to show that the natrual numbers exist
//We do this by taking a restriction of the infinite set given by the axiom of infinity to elements contained in all inductive sets
define is_natural_numbers(N): *X((X in N -> *I(is_inductive_set(I) -> X in I)) & (*I(is_inductive_set(I) -> X in I) -> X in N));

//The natural numbers exist
prove natural_numbers_exist: ^N(is_natural_numbers(N)){
	is_inductive = axiom_infinity(INDUCTIVE_SET);
	define restrict(X): *I(is_inductive_set(I) -> X in I);
	specified = axiom_specify[(restrict)](INDUCTIVE_SET)(N);
	prove def: *X((X in N -> *I(is_inductive_set(I) -> X in I)) & (*I(is_inductive_set(I) -> X in I) -> X in N)){
		given X{
			prove lemma0: X in N -> *I(is_inductive_set(I) -> X in I){
				implies p{
					return right(left(specified(X))(p));
				}
			}
			prove lemma1: *I(is_inductive_set(I) -> X in I) -> X in N{
				implies p{
					define X_in_N: X in N;
					X_in_INDUCTIVE_SET = p(INDUCTIVE_SET)(is_inductive);
					return and_left_implies[X_in_INDUCTIVE_SET][p][(X_in_N)](and(X_in_INDUCTIVE_SET, right(specified(X))))(p);
				}
			}
			return and(lemma0, lemma1);
		}
	}
	choose N{
		return #is_natural_numbers(N)(def);
	}
}

//The natural numbers are an inductive set
prove natural_numbers_inductive_set: *N(is_natural_numbers(N) -> is_inductive_set(N)){
	given N{
		implies p{
			is_natural = is_natural_numbers#(N)(p);
			prove lemma0: ^E(E in N & is_empty(E)){
				choose EMPTY_SET{
					empty_set_empty = #is_empty(EMPTY_SET)(empty_set_condition);
					prove empty_set_in_inductive: *I(is_inductive_set(I) -> EMPTY_SET in I){
						given I{
							implies inductive{
								empty_membership = left(is_inductive_set#(I)(inductive))(E);
								E_equal_EMPTY_SET = empty_set_unique(E)(EMPTY_SET)(and(right(empty_membership), empty_set_empty));
								define X_in_I(X): X in I;
								return left(equality_consistency[(X_in_I)](E)(EMPTY_SET)(E_equal_EMPTY_SET))(left(empty_membership));
							}
						}
					}
					EMPTY_SET_in_N = right(is_natural(EMPTY_SET))(empty_set_in_inductive);
					return and(EMPTY_SET_in_N, empty_set_empty);
				}
			}
			prove lemma1: *Y*Z(Y in N & is_successor(Y, Z) -> Z in N){
				given Y{
					given Z{
						implies both{
							Y_in_N = left(both);
							successor = right(both);
							prove Z_in_inductive_sets: *I(is_inductive_set(I) -> Z in I){
								given I{
									implies inductive{
										inductive_def = is_inductive_set#(I)(inductive);
										Y_in_I = left(is_natural(Y))(Y_in_N)(I)(inductive);
										return right(inductive_def)(Y)(Z)(and(Y_in_I, successor));
									}
								}
							}
							return right(is_natural(Z))(Z_in_inductive_sets);
						}
					}
				}
			}
			return #is_inductive_set(N)(and(lemma0, lemma1));
		}
	}
}

//The natural numbers are unique
prove natural_numbers_unique: *N*M(is_natural_numbers(N) & is_natural_numbers(M) -> equal_sets(N, M)){
	given N{
		given M{
			implies p{
				partN = is_natural_numbers#(N)(left(p));
				partM = is_natural_numbers#(M)(right(p));
				prove def: *X((X in N -> X in M) & (X in M -> X in N)){
					given X{
						prove lemma0: X in N -> X in M{
							implies X_in_N{
								return right(partM(X))(left(partN(X))(X_in_N));
							}
						}
						prove lemma1: X in M -> X in N{
							implies X_in_M{
								return right(partN(X))(left(partM(X))(X_in_M));
							}
						}
						return and(lemma0, lemma1);
					}
				}
				return #equal_sets(N)(M)(def);
			}
		}
	}
}

naturals_definition = natural_numbers_exist(NATURALS);
naturals_definition = is_natural_numbers#(NATURALS)(naturals_definition);

return naturals_definition;
